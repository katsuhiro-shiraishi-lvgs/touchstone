'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@zag-js/core');
const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const elementSize = require('@zag-js/element-size');
const formUtils = require('@zag-js/form-utils');
const numericRange = require('@zag-js/numeric-range');
const utils = require('@zag-js/utils');
const rangeSlider_dom = require('./range-slider.dom.js');
const rangeSlider_utils = require('./range-slider.utils.js');

function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "range-slider",
      initial: "idle",
      context: {
        thumbSizes: [],
        thumbAlignment: "contain",
        threshold: 5,
        activeIndex: -1,
        min: 0,
        max: 100,
        step: 1,
        value: [0, 100],
        initialValues: [],
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        ...ctx
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        spacing: (ctx2) => ctx2.minStepsBetweenThumbs * ctx2.step,
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSizes.length !== 0,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * numericRange.getValuePercent(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["invokeOnChange", "dispatchChangeEvent"]
      },
      entry: ["checkValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementAtIndex"
        },
        DECREMENT: {
          actions: "decrementAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "invokeOnChangeStart", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setActiveIndex"
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "invokeOnChangeStart", "focusActiveThumb"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: "decrementAtIndex"
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: "incrementAtIndex"
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: "incrementAtIndex"
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: "decrementAtIndex"
            },
            PAGE_UP: {
              actions: "incrementAtIndex"
            },
            PAGE_DOWN: {
              actions: "decrementAtIndex"
            },
            HOME: {
              actions: "setActiveThumbToMin"
            },
            END: {
              actions: "setActiveThumbToMax"
            },
            BLUR: {
              target: "idle",
              actions: "clearActiveIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        isVertical: (ctx2) => ctx2.isVertical,
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2) {
          return formUtils.trackFormControl(rangeSlider_dom.dom.getRootEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              if (!ctx2.name)
                return;
              rangeSlider_utils.assignArray(ctx2.value, ctx2.initialValues);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return domEvent.trackPointerMove(rangeSlider_dom.dom.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain")
            return;
          return elementSize.trackElementsSize({
            getNodes() {
              return rangeSlider_dom.dom.getElements(ctx2);
            },
            observeMutation: true,
            callback(size, index) {
              if (size) {
                ctx2.thumbSizes[index] = size;
              }
            }
          });
        }
      },
      actions: {
        invokeOnChangeStart(ctx2) {
          ctx2.onChangeStart?.({ value: ctx2.value });
        },
        invokeOnChangeEnd(ctx2) {
          ctx2.onChangeEnd?.({ value: ctx2.value });
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        dispatchChangeEvent(ctx2) {
          domQuery.raf(() => {
            rangeSlider_dom.dom.dispatchChangeEvent(ctx2);
          });
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = rangeSlider_dom.dom.getValueFromPoint(ctx2, evt.point);
          ctx2.activeIndex = rangeSlider_utils.getClosestIndex(ctx2, pointValue);
        },
        setActiveIndex(ctx2, evt) {
          ctx2.activeIndex = evt.index;
        },
        clearActiveIndex(ctx2) {
          ctx2.activeIndex = -1;
        },
        setPointerValue(ctx2, evt) {
          const value = rangeSlider_dom.dom.getValueFromPoint(ctx2, evt.point);
          if (value == null)
            return;
          ctx2.value[ctx2.activeIndex] = rangeSlider_utils.constrainValue(ctx2, value, ctx2.activeIndex);
        },
        focusActiveThumb(ctx2) {
          domQuery.raf(() => {
            const thumb = rangeSlider_dom.dom.getThumbEl(ctx2, ctx2.activeIndex);
            thumb?.focus();
          });
        },
        decrementAtIndex(ctx2, evt) {
          const nextValue = rangeSlider_utils.decrement(ctx2, evt.index, evt.step);
          rangeSlider_utils.assignArray(ctx2.value, nextValue);
        },
        incrementAtIndex(ctx2, evt) {
          const nextValue = rangeSlider_utils.increment(ctx2, evt.index, evt.step);
          rangeSlider_utils.assignArray(ctx2.value, nextValue);
        },
        setActiveThumbToMin(ctx2) {
          const { min } = rangeSlider_utils.getRangeAtIndex(ctx2, ctx2.activeIndex);
          ctx2.value[ctx2.activeIndex] = min;
        },
        setActiveThumbToMax(ctx2) {
          const { max } = rangeSlider_utils.getRangeAtIndex(ctx2, ctx2.activeIndex);
          ctx2.value[ctx2.activeIndex] = max;
        },
        checkValue(ctx2) {
          const nextValue = rangeSlider_utils.normalizeValues(ctx2, ctx2.value);
          rangeSlider_utils.assignArray(ctx2.value, nextValue);
          rangeSlider_utils.assignArray(ctx2.initialValues, nextValue);
        },
        setValueAtIndex(ctx2, evt) {
          ctx2.value[evt.index] = rangeSlider_utils.constrainValue(ctx2, evt.value, evt.index);
        },
        setValue(ctx2, evt) {
          rangeSlider_utils.assignArray(ctx2.value, rangeSlider_utils.normalizeValues(ctx2, evt.value));
        }
      }
    }
  );
}

exports.machine = machine;
