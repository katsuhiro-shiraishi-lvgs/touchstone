import { getEventStep, getEventKey, getNativeEvent, isLeftClick, isModifiedEvent, getEventPoint } from '@zag-js/dom-event';
import { dataAttr, ariaAttr } from '@zag-js/dom-query';
import { getValuePercent, getPercentValue } from '@zag-js/numeric-range';
import { parts } from './range-slider.anatomy.mjs';
import { dom } from './range-slider.dom.mjs';
import { getRangeAtIndex } from './range-slider.utils.mjs';

function connect(state, send, normalize) {
  const ariaLabel = state.context["aria-label"];
  const ariaLabelledBy = state.context["aria-labelledby"];
  const sliderValue = state.context.value;
  const isFocused = state.matches("focus");
  const isDragging = state.matches("dragging");
  const isDisabled = state.context.disabled;
  const isInvalid = state.context.invalid;
  const isInteractive = state.context.isInteractive;
  function getValuePercentFn(value) {
    return getValuePercent(value, state.context.min, state.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state.context.min, state.context.max, state.context.step);
  }
  return {
    /**
     * The value of the slider.
     */
    value: state.context.value,
    /**
     * Whether the slider is being dragged.
     */
    isDragging,
    /**
     * Whether the slider is focused.
     */
    isFocused,
    /**
     * Function to set the value of the slider.
     */
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    /**
     * Returns the value of the thumb at the given index.
     */
    getThumbValue(index) {
      return sliderValue[index];
    },
    /**
     * Sets the value of the thumb at the given index.
     */
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    /**
     * Returns the percent of the thumb at the given index.
     */
    getValuePercent: getValuePercentFn,
    /**
     * Returns the value of the thumb at the given percent.
     */
    getPercentValue: getPercentValueFn,
    /**
     * Returns the percent of the thumb at the given index.
     */
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    /**
     * Sets the percent of the thumb at the given index.
     */
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    /**
     * Returns the min value of the thumb at the given index.
     */
    getThumbMin(index) {
      return getRangeAtIndex(state.context, index).min;
    },
    /**
     * Returns the max value of the thumb at the given index.
     */
    getThumbMax(index) {
      return getRangeAtIndex(state.context, index).max;
    },
    /**
     * Function to increment the value of the slider at the given index.
     */
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    /**
     * Function to decrement the value of the slider at the given index.
     */
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    /**
     * Function to focus the slider. This focuses the first thumb.
     */
    focus() {
      if (!isInteractive)
        return;
      send({ type: "FOCUS", index: 0 });
    },
    labelProps: normalize.label({
      ...parts.label.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-focus": dataAttr(isFocused),
      id: dom.getLabelId(state.context),
      htmlFor: dom.getHiddenInputId(state.context, 0),
      onClick(event) {
        if (!isInteractive)
          return;
        event.preventDefault();
        dom.getFirstEl(state.context)?.focus();
      },
      style: {
        userSelect: "none"
      }
    }),
    rootProps: normalize.element({
      ...parts.root.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-orientation": state.context.orientation,
      "data-invalid": dataAttr(isInvalid),
      id: dom.getRootId(state.context),
      dir: state.context.dir,
      style: dom.getRootStyle(state.context)
    }),
    outputProps: normalize.output({
      ...parts.output.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      id: dom.getOutputId(state.context),
      htmlFor: sliderValue.map((_v, i) => dom.getHiddenInputId(state.context, i)).join(" "),
      "aria-live": "off"
    }),
    trackProps: normalize.element({
      ...parts.track.attrs,
      id: dom.getTrackId(state.context),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-orientation": state.context.orientation,
      "data-focus": dataAttr(isFocused),
      style: { position: "relative" }
    }),
    getThumbProps(index) {
      const value = sliderValue[index];
      const range = getRangeAtIndex(state.context, index);
      const ariaValueText = state.context.getAriaValueText?.(value, index);
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize.element({
        ...parts.thumb.attrs,
        "data-index": index,
        id: dom.getThumbId(state.context, index),
        "data-disabled": dataAttr(isDisabled),
        "data-orientation": state.context.orientation,
        "data-focus": dataAttr(isFocused && state.context.activeIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(isDisabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom.getLabelId(state.context),
        "aria-orientation": state.context.orientation,
        "aria-valuemax": range.max,
        "aria-valuemin": range.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": ariaValueText,
        role: "slider",
        tabIndex: isDisabled ? void 0 : 0,
        style: dom.getThumbStyle(state.context, index),
        onBlur() {
          if (!isInteractive)
            return;
          send("BLUR");
        },
        onFocus() {
          if (!isInteractive)
            return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (!isInteractive)
            return;
          const step = getEventStep(event) * state.context.step;
          let prevent = true;
          const keyMap = {
            ArrowUp() {
              send({ type: "ARROW_UP", step });
              prevent = state.context.isVertical;
            },
            ArrowDown() {
              send({ type: "ARROW_DOWN", step });
              prevent = state.context.isVertical;
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT", step });
              prevent = state.context.isHorizontal;
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT", step });
              prevent = state.context.isHorizontal;
            },
            PageUp() {
              send({ type: "PAGE_UP", step });
            },
            PageDown() {
              send({ type: "PAGE_DOWN", step });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state.context);
          const exec = keyMap[key];
          if (!exec)
            return;
          exec(event);
          if (prevent) {
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(index) {
      return normalize.input({
        ...parts.hiddenInput.attrs,
        name: `${state.context.name}[${index}]`,
        form: state.context.form,
        type: "text",
        hidden: true,
        defaultValue: state.context.value[index],
        id: dom.getHiddenInputId(state.context, index)
      });
    },
    rangeProps: normalize.element({
      id: dom.getRangeId(state.context),
      ...parts.range.attrs,
      "data-focus": dataAttr(isFocused),
      "data-invalid": dataAttr(isInvalid),
      "data-disabled": dataAttr(isDisabled),
      "data-orientation": state.context.orientation,
      style: dom.getRangeStyle(state.context)
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      id: dom.getControlId(state.context),
      "data-disabled": dataAttr(isDisabled),
      "data-orientation": state.context.orientation,
      "data-invalid": dataAttr(isInvalid),
      "data-focus": dataAttr(isFocused),
      style: dom.getControlStyle(),
      onPointerDown(event) {
        if (!isInteractive)
          return;
        const evt = getNativeEvent(event);
        if (!isLeftClick(evt) || isModifiedEvent(evt))
          return;
        const point = getEventPoint(evt);
        send({ type: "POINTER_DOWN", point });
        event.preventDefault();
        event.stopPropagation();
      }
    }),
    markerGroupProps: normalize.element({
      ...parts.markerGroup.attrs,
      role: "presentation",
      "aria-hidden": true,
      "data-orientation": state.context.orientation,
      style: dom.getMarkerGroupStyle()
    }),
    getMarkerProps({ value }) {
      const percent = getValuePercentFn(value);
      const style = dom.getMarkerStyle(state.context, percent);
      let markerState;
      if (Math.max(...state.context.value) < value) {
        markerState = "over-value";
      } else if (Math.min(...state.context.value) > value) {
        markerState = "under-value";
      } else {
        markerState = "at-value";
      }
      return normalize.element({
        ...parts.marker.attrs,
        id: dom.getMarkerId(state.context, value),
        role: "presentation",
        "data-orientation": state.context.orientation,
        "data-value": value,
        "data-disabled": dataAttr(isDisabled),
        "data-state": markerState,
        style
      });
    }
  };
}

export { connect };
