'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const utils = require('@zag-js/utils');
const visuallyHidden = require('@zag-js/visually-hidden');
const pinInput_anatomy = require('./pin-input.anatomy.js');
const pinInput_dom = require('./pin-input.dom.js');

function connect(state, send, normalize) {
  const isValueComplete = state.context.isValueComplete;
  const isInvalid = state.context.invalid;
  const focusedIndex = state.context.focusedIndex;
  const translations = state.context.translations;
  function focus() {
    pinInput_dom.dom.getFirstInputEl(state.context)?.focus();
  }
  return {
    /**
     * The value of the input as an array of strings.
     */
    value: state.context.value,
    /**
     * The value of the input as a string.
     */
    valueAsString: state.context.valueAsString,
    /**
     * Whether all inputs are filled.
     */
    isValueComplete,
    /**
     * Function to set the value of the inputs.
     */
    setValue(value) {
      if (!Array.isArray(value)) {
        utils.invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "SET_VALUE", value });
    },
    /**
     * Function to clear the value of the inputs.
     */
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    /**
     * Function to set the value of the input at a specific index.
     */
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE", value, index });
    },
    /**
     * Function to focus the pin-input. This will focus the first input.
     */
    focus,
    rootProps: normalize.element({
      dir: state.context.dir,
      ...pinInput_anatomy.parts.root.attrs,
      id: pinInput_dom.dom.getRootId(state.context),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-disabled": domQuery.dataAttr(state.context.disabled),
      "data-complete": domQuery.dataAttr(isValueComplete)
    }),
    labelProps: normalize.label({
      ...pinInput_anatomy.parts.label.attrs,
      htmlFor: pinInput_dom.dom.getHiddenInputId(state.context),
      id: pinInput_dom.dom.getLabelId(state.context),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-disabled": domQuery.dataAttr(state.context.disabled),
      "data-complete": domQuery.dataAttr(isValueComplete),
      onClick: (event) => {
        event.preventDefault();
        focus();
      }
    }),
    hiddenInputProps: normalize.input({
      ...pinInput_anatomy.parts.hiddenInput.attrs,
      "aria-hidden": true,
      type: "text",
      tabIndex: -1,
      id: pinInput_dom.dom.getHiddenInputId(state.context),
      name: state.context.name,
      form: state.context.form,
      style: visuallyHidden.visuallyHiddenStyle,
      maxLength: state.context.valueLength,
      defaultValue: state.context.valueAsString
    }),
    controlProps: normalize.element({
      ...pinInput_anatomy.parts.control.attrs,
      id: pinInput_dom.dom.getControlId(state.context)
    }),
    getInputProps({ index }) {
      const inputType = state.context.type === "numeric" ? "tel" : "text";
      return normalize.input({
        ...pinInput_anatomy.parts.input.attrs,
        disabled: state.context.disabled,
        "data-disabled": domQuery.dataAttr(state.context.disabled),
        "data-complete": domQuery.dataAttr(isValueComplete),
        id: pinInput_dom.dom.getInputId(state.context, index.toString()),
        "data-ownedby": pinInput_dom.dom.getRootId(state.context),
        "aria-label": translations.inputLabel(index, state.context.valueLength),
        inputMode: state.context.otp || state.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": domQuery.ariaAttr(isInvalid),
        "data-invalid": domQuery.dataAttr(isInvalid),
        type: state.context.mask ? "password" : inputType,
        defaultValue: state.context.value[index] || "",
        autoCapitalize: "none",
        autoComplete: state.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state.context.placeholder,
        onChange(event) {
          const evt = domEvent.getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "PASTE", value });
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("BACKSPACE");
            return;
          }
          send({ type: "INPUT", value, index });
        },
        onKeyDown(event) {
          const evt = domEvent.getNativeEvent(event);
          if (evt.isComposing || domEvent.isModifiedEvent(evt))
            return;
          const keyMap = {
            Backspace() {
              send("BACKSPACE");
            },
            Delete() {
              send("DELETE");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
            }
          };
          const key = domEvent.getEventKey(event, { dir: state.context.dir });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          } else {
            if (key === "Tab")
              return;
            send({ type: "KEY_DOWN", value: key, preventDefault: () => event.preventDefault() });
          }
        },
        onFocus() {
          send({ type: "FOCUS", index });
        },
        onBlur() {
          send({ type: "BLUR", index });
        }
      });
    }
  };
}

exports.connect = connect;
