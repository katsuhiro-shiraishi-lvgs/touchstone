import { createMachine, guards } from '@zag-js/core';
import { raf } from '@zag-js/dom-query';
import { dispatchInputValueEvent } from '@zag-js/form-utils';
import { compact } from '@zag-js/utils';
import { dom } from './pin-input.dom.mjs';

const { and, not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "pin-input",
      initial: ctx.autoFocus ? "focused" : "idle",
      context: {
        value: [],
        focusedIndex: -1,
        placeholder: "â—‹",
        otp: false,
        type: "numeric",
        ...ctx,
        translations: {
          inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => v?.trim() !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex]
      },
      watch: {
        focusedIndex: ["focusInput", "setInputSelection"],
        value: ["dispatchInputEvent", "syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      entry: ctx.autoFocus ? ["setupValue", "setFocusIndexToFirst"] : ["setupValue"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex", "invokeOnChange"]
          },
          { actions: ["setValue", "invokeOnChange"] }
        ],
        CLEAR_VALUE: [
          {
            guard: "isDisabled",
            actions: ["clearValue", "invokeOnChange"]
          },
          {
            actions: ["clearValue", "invokeOnChange", "setFocusIndexToFirst"]
          }
        ]
      },
      states: {
        idle: {
          on: {
            FOCUS: {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            INPUT: [
              {
                guard: and("isFinalValue", "isValidValue"),
                actions: ["setFocusedValue", "invokeOnChange", "syncInputValue"]
              },
              {
                guard: "isValidValue",
                actions: ["setFocusedValue", "invokeOnChange", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            PASTE: [
              {
                guard: "isValidValue",
                actions: ["setPastedValue", "invokeOnChange", "setLastValueFocusIndex"]
              },
              { actions: ["resetFocusedValue", "invokeOnChange"] }
            ],
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            DELETE: {
              guard: "hasValue",
              actions: ["clearFocusedValue", "invokeOnChange"]
            },
            ARROW_LEFT: {
              actions: "setPrevFocusedIndex"
            },
            ARROW_RIGHT: {
              actions: "setNextFocusedIndex"
            },
            BACKSPACE: [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue", "invokeOnChange"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue", "invokeOnChange"]
              }
            ],
            ENTER: {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            KEY_DOWN: {
              guard: not("isValidValue"),
              actions: ["preventDefault", "invokeOnInvalid"]
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isValidValue: (ctx2, evt) => {
          if (!ctx2.pattern)
            return isValidType(evt.value, ctx2.type);
          const regex = new RegExp(ctx2.pattern, "g");
          return regex.test(evt.value);
        },
        isFinalValue: (ctx2) => {
          return ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex;
        },
        isLastInputFocused: (ctx2) => ctx2.focusedIndex === ctx2.valueLength - 1,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue: (ctx2) => {
          if (ctx2.value.length)
            return;
          const inputs = dom.getElements(ctx2);
          const emptyValues = Array.from({ length: inputs.length }).fill("");
          assign(ctx2, emptyValues);
        },
        focusInput: (ctx2) => {
          raf(() => {
            if (ctx2.focusedIndex === -1)
              return;
            dom.getFocusedInputEl(ctx2)?.focus();
          });
        },
        setInputSelection: (ctx2) => {
          raf(() => {
            if (ctx2.focusedIndex === -1)
              return;
            const input = dom.getFocusedInputEl(ctx2);
            const length = input.value.length;
            input.selectionStart = ctx2.selectOnFocus ? 0 : length;
            input.selectionEnd = length;
          });
        },
        invokeOnComplete: (ctx2) => {
          if (!ctx2.isValueComplete)
            return;
          ctx2.onComplete?.({ value: Array.from(ctx2.value), valueAsString: ctx2.valueAsString });
        },
        invokeOnChange: (ctx2) => {
          ctx2.onChange?.({ value: Array.from(ctx2.value) });
        },
        dispatchInputEvent: (ctx2) => {
          const inputEl = dom.getHiddenInputEl(ctx2);
          dispatchInputValueEvent(inputEl, { value: ctx2.valueAsString });
        },
        invokeOnInvalid: (ctx2, evt) => {
          ctx2.onInvalid?.({ value: evt.value, index: ctx2.focusedIndex });
        },
        clearFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = -1;
        },
        setValue: (ctx2, evt) => {
          assign(ctx2, evt.value);
        },
        setFocusedIndex: (ctx2, evt) => {
          ctx2.focusedIndex = evt.index;
        },
        setFocusedValue: (ctx2, evt) => {
          ctx2.value[ctx2.focusedIndex] = getNextValue(ctx2.focusedValue, evt.value);
        },
        syncInputValue(ctx2, evt) {
          const input = dom.getInputEl(ctx2, evt.index.toString());
          if (!input)
            return;
          input.value = ctx2.value[evt.index];
        },
        syncInputElements(ctx2) {
          const inputs = dom.getElements(ctx2);
          inputs.forEach((input, index) => {
            input.value = ctx2.value[index];
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = ctx2.focusedValue ? 1 : 0;
            const value = evt.value.substring(startIndex, startIndex + ctx2.valueLength);
            assign(ctx2, value);
          });
        },
        setValueAtIndex: (ctx2, evt) => {
          ctx2.value[evt.index] = getNextValue(ctx2.focusedValue, evt.value);
        },
        clearValue: (ctx2) => {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          assign(ctx2, nextValue);
        },
        clearFocusedValue: (ctx2) => {
          ctx2.value[ctx2.focusedIndex] = "";
        },
        resetFocusedValue: (ctx2) => {
          const input = dom.getFocusedInputEl(ctx2);
          input.value = ctx2.focusedValue;
        },
        setFocusIndexToFirst: (ctx2) => {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex: (ctx2) => {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        preventDefault(_, evt) {
          evt.preventDefault();
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete)
            return;
          raf(() => {
            dom.getFocusedInputEl(ctx2)?.blur();
          });
        },
        requestFormSubmit(ctx2) {
          if (!ctx2.name || !ctx2.isValueComplete)
            return;
          const input = dom.getHiddenInputEl(ctx2);
          input?.form?.requestSubmit();
        }
      }
    }
  );
}
const REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(value, type) {
  if (!type)
    return true;
  return !!REGEX[type]?.test(value);
}
function assign(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next) {
  let nextValue = next;
  if (current[0] === next[0])
    nextValue = next[1];
  else if (current[0] === next[1])
    nextValue = next[0];
  return nextValue;
}

export { machine };
