'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@zag-js/core');
const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const textSelection = require('@zag-js/text-selection');
const utils = require('@zag-js/utils');
const pressable_dom = require('./pressable.dom.js');
const pressable_utils = require('./pressable.utils.js');

function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "pressable",
      initial: "idle",
      context: {
        longPressDelay: 500,
        ...ctx,
        wasPressedDown: false,
        ignoreClickAfterPress: false,
        target: null,
        pointerId: null,
        pointerType: null,
        cleanups: core.ref([])
      },
      exit: ["restoreTextSelection", "removeDocumentListeners"],
      states: {
        idle: {
          entry: ["resetPointerContext", "restoreTextSelection", "removeDocumentListeners"],
          on: {
            POINTER_DOWN: [
              {
                guard: "isVirtualPointer",
                actions: "setPointerType"
              },
              {
                target: "pressed:in",
                actions: [
                  "setPressedDown",
                  "setPointerType",
                  "setPointerId",
                  "setTarget",
                  "focusIfNeeded",
                  "disableTextSelection",
                  "invokeOnPressStart",
                  "trackDocumentPointerEvents"
                ]
              }
            ],
            KEY_DOWN: {
              target: "pressed:in",
              actions: ["setTarget", "setPointerType", "invokeOnPressStart", "trackDocumentKeyup"]
            },
            CLICK: {
              actions: [
                "focusIfNeeded",
                "invokeOnPressStart",
                "enableClickAfterPress",
                "invokeOnPressEnd",
                "invokeOnPress"
              ]
            }
          }
        },
        "pressed:in": {
          tags: "pressed",
          entry: "preventContextMenu",
          after: {
            LONG_PRESS_DELAY: {
              guard: "wasPressedDown",
              actions: ["clearPressedDown", "invokeOnLongPress"]
            }
          },
          on: {
            POINTER_LEAVE: [
              {
                guard: "cancelOnPointerExit",
                target: "idle",
                actions: ["clearPressedDown", "invokeOnPressEnd"]
              },
              {
                target: "pressed:out",
                actions: ["invokeOnPressEnd"]
              }
            ],
            DOC_POINTER_UP: [
              {
                guard: "wasPressedDown",
                target: "idle",
                actions: [
                  "clearPressedDown",
                  "invokeOnPressUp",
                  "enableClickAfterPress",
                  "invokeOnPressEnd",
                  "invokeOnPress"
                ]
              },
              {
                target: "idle",
                actions: ["clearPressedDown", "invokeOnPressUp", "enableClickAfterPress", "invokeOnPressEnd"]
              }
            ],
            DOC_KEY_UP: {
              target: "idle",
              actions: [
                "clearPressedDown",
                "invokeOnPressUp",
                "disableClickAfterPress",
                "invokeOnPressEnd",
                "invokeOnPress",
                "triggerClickIfAnchor"
              ]
            },
            DOC_POINTER_CANCEL: {
              target: "idle",
              actions: "clearPressedDown"
            },
            DRAG_START: {
              target: "idle",
              actions: "clearPressedDown"
            }
          }
        },
        "pressed:out": {
          on: {
            POINTER_ENTER: {
              target: "pressed:in",
              actions: "invokeOnPressStart"
            },
            DOC_POINTER_UP: {
              target: "idle"
            },
            DOC_POINTER_CANCEL: "idle",
            DRAG_START: "idle"
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: (ctx2) => ctx2.longPressDelay
      },
      guards: {
        isVirtualPointer: (_ctx, evt) => evt.pointerType === "virtual",
        cancelOnPointerExit: (ctx2) => !!ctx2.cancelOnPointerExit,
        wasPressedDown: (ctx2) => ctx2.wasPressedDown
      },
      actions: {
        trackDocumentPointerEvents(ctx2, _evt, { send }) {
          const doc = pressable_dom.dom.getDoc(ctx2);
          const onPointerMove = (event) => {
            if (event.pointerId !== ctx2.pointerId)
              return;
            const isOver = pressable_utils.isOverTarget(event, ctx2.target);
            send({
              type: isOver ? "POINTER_ENTER" : "POINTER_LEAVE",
              currentTarget: event.currentTarget,
              pointerType: event.pointerType
            });
          };
          const onPointerUp = (event) => {
            if (event.pointerId !== ctx2.pointerId || event.button !== 0)
              return;
            send({
              type: "DOC_POINTER_UP",
              currentTarget: event.currentTarget,
              pointerType: event.pointerType
            });
          };
          const onPointerCancel = (event) => {
            send({
              type: "DOC_POINTER_CANCEL",
              currentTarget: event.currentTarget
            });
          };
          const cleanup = [
            domEvent.addDomEvent(doc, "pointermove", onPointerMove, false),
            domEvent.addDomEvent(doc, "pointerup", onPointerUp, false),
            domEvent.addDomEvent(doc, "pointercancel", onPointerCancel, false)
          ];
          if (ctx2.pointerType !== "touch") {
            cleanup.push(domEvent.addDomEvent(doc, "contextmenu", onPointerCancel, false));
          }
          ctx2.cleanups.push(...cleanup);
        },
        trackDocumentKeyup(ctx2, evt, { send }) {
          const doc = pressable_dom.dom.getDoc(ctx2);
          const onKeyup = (event) => {
            if (!pressable_utils.isValidKeyboardEvent(event))
              return;
            if (pressable_utils.shouldPreventDefaultKeyboard(event.target)) {
              event.preventDefault();
            }
            send({
              type: "DOC_KEY_UP",
              // forward the previously store keyboard type
              pointerType: evt.pointerType
            });
          };
          const cleanup = domEvent.addDomEvent(doc, "keyup", onKeyup, false);
          ctx2.cleanups.push(cleanup);
        },
        removeDocumentListeners(ctx2) {
          ctx2.cleanups.forEach((fn) => fn?.());
          ctx2.cleanups = core.ref([]);
        },
        resetPointerContext(ctx2) {
          ctx2.pointerId = null;
          ctx2.pointerType = null;
        },
        disableTextSelection(ctx2) {
          if (!ctx2.target || ctx2.allowTextSelectionOnPress)
            return;
          textSelection.disableTextSelection({ target: ctx2.target, doc: pressable_dom.dom.getDoc(ctx2) });
        },
        restoreTextSelection(ctx2) {
          if (ctx2.allowTextSelectionOnPress || !ctx2.target)
            return;
          textSelection.restoreTextSelection({ target: ctx2.target, doc: pressable_dom.dom.getDoc(ctx2) });
        },
        setPointerToVirtual(ctx2) {
          ctx2.pointerType = "virtual";
        },
        setPointerType(ctx2, evt) {
          ctx2.pointerType = evt.pointerType;
        },
        setPointerId(ctx2, evt) {
          ctx2.pointerId = evt.pointerId;
        },
        setTarget(ctx2, evt) {
          ctx2.target = core.ref(evt.currentTarget);
        },
        focusIfNeeded(ctx2, evt) {
          if (ctx2.disabled || ctx2.preventFocusOnPress)
            return;
          evt.currentTarget.focus({ preventScroll: true });
        },
        invokeOnPressStart(ctx2, evt) {
          if (ctx2.disabled)
            return;
          ctx2.onPressStart?.({
            type: "pressstart",
            pointerType: evt.pointerType || ctx2.pointerType,
            target: evt.currentTarget
          });
        },
        invokeOnPressUp(ctx2, evt) {
          if (ctx2.disabled)
            return;
          ctx2.onPressUp?.({
            type: "pressup",
            pointerType: evt.pointerType || ctx2.pointerType,
            target: evt.currentTarget
          });
        },
        invokeOnPressEnd(ctx2, evt) {
          if (ctx2.disabled)
            return;
          ctx2.onPressEnd?.({
            type: "pressend",
            pointerType: evt.pointerType || ctx2.pointerType,
            target: evt.currentTarget
          });
        },
        invokeOnPress(ctx2, evt) {
          if (ctx2.disabled)
            return;
          ctx2.onPress?.({
            type: "press",
            pointerType: evt.pointerType || ctx2.pointerType,
            target: evt.currentTarget
          });
        },
        triggerClickIfAnchor(ctx2, evt) {
          let target = evt.currentTarget;
          if (!domQuery.isHTMLElement(ctx2.target))
            return;
          const isAnchor = pressable_utils.isHTMLAnchorLink(ctx2.target) || ctx2.target.getAttribute("role") === "link";
          if (ctx2.target.contains(target) && isAnchor) {
            ctx2.target.click();
          }
        },
        invokeOnLongPress(ctx2, evt) {
          if (!ctx2.target)
            return;
          ctx2.onLongPress?.({
            type: "longpress",
            pointerType: evt.pointerType || ctx2.pointerType,
            target: ctx2.target
          });
        },
        disableClickAfterPress(ctx2) {
          ctx2.ignoreClickAfterPress = true;
        },
        enableClickAfterPress(ctx2) {
          ctx2.ignoreClickAfterPress = false;
        },
        setPressedDown(ctx2) {
          ctx2.wasPressedDown = true;
        },
        clearPressedDown(ctx2) {
          ctx2.wasPressedDown = false;
        },
        preventContextMenu(ctx2) {
          if (ctx2.pointerType !== "touch" || !ctx2.onLongPress)
            return;
          const onContextMenu = (event) => event.preventDefault();
          const cleanup = domEvent.addDomEvent(ctx2.target, "contextmenu", onContextMenu, { once: true });
          const onPointerUp = () => void setTimeout(cleanup, 30);
          domEvent.addDomEvent(pressable_dom.dom.getWin(ctx2), "pointerup", onPointerUp, { once: true });
        }
      }
    }
  );
}

exports.machine = machine;
