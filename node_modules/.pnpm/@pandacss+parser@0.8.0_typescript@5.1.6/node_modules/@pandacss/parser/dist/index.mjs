// src/project.ts
import { Obj, pipe, tap } from "lil-fp";
import { Project as TsProject, ScriptKind } from "ts-morph";

// src/parser.ts
import { extract, unbox, box } from "@pandacss/extractor";
import { logger } from "@pandacss/logger";
import { astish, memo as memo2 } from "@pandacss/shared";
import { Node } from "ts-morph";
import { match } from "ts-pattern";

// src/import.ts
import { memo } from "@pandacss/shared";
var getModuleSpecifierValue = (node) => {
  try {
    return node.getModuleSpecifierValue();
  } catch {
    return;
  }
};
function getImportDeclarations(file, options) {
  const { match: match2 } = options;
  const result = [];
  file.getImportDeclarations().forEach((node) => {
    const source = getModuleSpecifierValue(node);
    if (!source)
      return;
    const specifiers = node.getNamedImports();
    specifiers.forEach((specifier) => {
      const name = specifier.getNameNode().getText();
      const alias = specifier.getAliasNode()?.getText() || name;
      const importMapValue = match2({ name, alias, mod: source });
      if (!importMapValue)
        return;
      result.push({ name, alias, mod: source, importMapValue });
    });
  });
  return {
    value: result,
    toString() {
      return result.map((item) => item.alias).join(", ");
    },
    find(id) {
      return result.find((o) => o.alias === id);
    },
    createMatch(mod) {
      const mods = result.filter((o) => o.mod.includes(mod) || o.importMapValue === mod);
      return memo((id) => !!mods.find((mod2) => mod2.alias === id || mod2.name === id));
    },
    match(id) {
      return !!this.find(id);
    },
    getName(id) {
      return this.find(id)?.name || id;
    },
    getAlias(id) {
      return result.find((o) => o.name === id)?.alias || id;
    }
  };
}

// src/parser-result.ts
var ParserResult = class _ParserResult {
  jsx = /* @__PURE__ */ new Set();
  css = /* @__PURE__ */ new Set();
  cva = /* @__PURE__ */ new Set();
  recipe = /* @__PURE__ */ new Map();
  pattern = /* @__PURE__ */ new Map();
  filePath;
  set(name, result) {
    this[name].add({ type: "object", ...result });
  }
  setCva(result) {
    this.cva.add({ type: "cva", ...result });
  }
  setJsx(result) {
    this.jsx.add({ type: "jsx", ...result });
  }
  setPattern(name, result) {
    this.pattern.get(name) ?? this.pattern.set(name, /* @__PURE__ */ new Set());
    this.pattern.get(name)?.add({ type: "pattern", name, ...result });
  }
  setRecipe(name, result) {
    this.recipe.get(name) ?? this.recipe.set(name, /* @__PURE__ */ new Set());
    this.recipe.get(name)?.add({ type: "recipe", ...result });
  }
  isEmpty() {
    return this.css.size === 0 && this.cva.size === 0 && this.recipe.size === 0 && this.pattern.size === 0 && this.jsx.size === 0;
  }
  setFilePath(filePath) {
    this.filePath = filePath;
    return this;
  }
  toArray() {
    const result = [];
    this.css.forEach((item) => result.push(item));
    this.cva.forEach((item) => result.push(item));
    this.recipe.forEach((items) => items.forEach((item) => result.push(item)));
    this.pattern.forEach((items) => items.forEach((item) => result.push(item)));
    this.jsx.forEach((item) => result.push(item));
    return result;
  }
  toJSON() {
    return {
      css: Array.from(this.css),
      cva: Array.from(this.cva),
      recipe: Object.fromEntries(Array.from(this.recipe.entries()).map(([key, value]) => [key, Array.from(value)])),
      pattern: Object.fromEntries(Array.from(this.pattern.entries()).map(([key, value]) => [key, Array.from(value)])),
      jsx: Array.from(this.jsx)
    };
  }
  merge(result) {
    result.css.forEach((item) => this.css.add(item));
    result.cva.forEach((item) => this.cva.add(item));
    result.recipe.forEach((items, name) => {
      this.recipe.get(name) ?? this.recipe.set(name, /* @__PURE__ */ new Set());
      items.forEach((item) => this.recipe.get(name)?.add(item));
    });
    result.pattern.forEach((items, name) => {
      this.pattern.get(name) ?? this.pattern.set(name, /* @__PURE__ */ new Set());
      items.forEach((item) => this.pattern.get(name)?.add(item));
    });
    result.jsx.forEach((item) => this.jsx.add(item));
    return this;
  }
  static fromJSON(json) {
    const data = JSON.parse(json);
    const result = new _ParserResult();
    result.css = new Set(data.css);
    result.cva = new Set(data.cva);
    result.recipe = new Map(Object.entries(data.recipe));
    result.pattern = new Map(Object.entries(data.pattern));
    result.jsx = new Set(data.jsx);
    return result;
  }
};
var createParserResult = () => new ParserResult();

// src/parser.ts
import { resolveTsPathPattern } from "@pandacss/config/ts-path";
var isNodeRecipe = (node) => node.type === "recipe";
var cvaProps = ["compoundVariants", "defaultVariants", "variants", "base"];
var isCva = (map) => cvaProps.some((prop) => map.has(prop));
function createImportMatcher(mod, values) {
  const regex = values ? new RegExp(`^(${values.join("|")})$`) : /.*/;
  return {
    mod,
    regex,
    match(value) {
      return regex.test(value);
    }
  };
}
var combineResult = (unboxed) => {
  return [...unboxed.conditions, unboxed.raw, ...unboxed.spreadConditions];
};
var fallback = (box2) => ({
  value: void 0,
  getNode: () => box2.getNode(),
  getStack: () => box2.getStack()
});
var defaultEnv = { preset: "NONE" };
function createParser(options) {
  const { jsx, getRecipesByJsxName, tsOptions, join } = options;
  const importMap = Object.fromEntries(Object.entries(options.importMap).map(([key, value]) => [key, join(...value)]));
  const importRegex = [
    createImportMatcher(importMap.css, ["css", "cva"]),
    createImportMatcher(importMap.recipe),
    createImportMatcher(importMap.pattern)
  ];
  if (jsx) {
    importRegex.push(createImportMatcher(importMap.jsx, [jsx.factory, ...jsx.nodes.map((node) => node.name)]));
  }
  return function parse2(sourceFile) {
    if (!sourceFile)
      return;
    const filePath = sourceFile.getFilePath();
    const imports = getImportDeclarations(sourceFile, {
      match(value) {
        let found = false;
        for (const { regex, mod } of importRegex) {
          if (!regex.test(value.name))
            continue;
          if (value.mod.includes(mod)) {
            found = true;
            break;
          }
          if (tsOptions?.pathMappings) {
            const filename = resolveTsPathPattern(tsOptions.pathMappings, value.mod);
            if (filename?.includes(mod)) {
              found = mod;
              break;
            }
          }
        }
        return found;
      }
    });
    const collector = createParserResult();
    logger.debug(
      "ast:import",
      imports.value.length ? `Found import { ${imports} } in ${filePath}` : `No import found in ${filePath}`
    );
    const [css] = importRegex;
    const jsxFactoryAlias = jsx ? imports.getAlias(jsx.factory) : "styled";
    const isValidPattern = imports.createMatch(importMap.pattern);
    const isValidRecipe = imports.createMatch(importMap.recipe);
    const isValidStyleFn = (name) => name === jsx?.factory;
    const isFactory = (name) => Boolean(jsx && name.startsWith(jsxFactoryAlias));
    const isRawFn = (fullName) => {
      const name = fullName.split(".raw")[0] ?? "";
      return name === "css" || isValidPattern(name) || isValidRecipe(name);
    };
    const jsxPatternNodes = new RegExp(
      `^(${jsx?.nodes.filter((node) => node.type === "pattern").map((node) => node.name).join("|")})$`
    );
    const recipes = /* @__PURE__ */ new Set();
    const patterns = /* @__PURE__ */ new Set();
    imports.value.forEach((importDeclaration) => {
      const { alias } = importDeclaration;
      if (isValidRecipe(alias)) {
        recipes.add(alias);
      }
      if (isValidPattern(alias)) {
        patterns.add(alias);
      }
    });
    const functions = /* @__PURE__ */ new Map();
    const components = /* @__PURE__ */ new Map();
    const propertiesMap = /* @__PURE__ */ new Map();
    const recipePropertiesByName = /* @__PURE__ */ new Map();
    const recipeJsxLists = (jsx?.nodes ?? []).filter(isNodeRecipe).reduce(
      (acc, recipe) => {
        recipePropertiesByName.set(recipe.baseName, new Set(recipe.props ?? []));
        recipe.jsx?.forEach((jsx2) => {
          if (typeof jsx2 === "string") {
            acc.string.add(jsx2);
          } else {
            acc.regex.push(jsx2);
          }
        });
        return acc;
      },
      { string: /* @__PURE__ */ new Set(), regex: [] }
    );
    const cvaAlias = imports.getAlias("cva");
    const cssAlias = imports.getAlias("css");
    if (options.jsx) {
      options.jsx.nodes.forEach((node) => {
        const alias = imports.getAlias(node.name);
        node.props?.forEach((prop) => propertiesMap.set(prop, true));
        functions.set(node.baseName, propertiesMap);
        functions.set(alias, propertiesMap);
        components.set(alias, propertiesMap);
      });
    }
    const isJsxTagRecipe = memo2(
      (tagName) => recipeJsxLists.string.has(tagName) || recipeJsxLists.regex.some((regex) => regex.test(tagName))
    );
    const matchTag = memo2((tagName) => {
      if (!tagName)
        return false;
      return components.has(tagName) || isUpperCase(tagName) || isFactory(tagName) || isJsxTagRecipe(tagName);
    });
    const matchTagProp = memo2((tagName, propName) => {
      if (Boolean(components.get(tagName)?.has(propName)) || options.jsx?.isStyleProp(propName) || propertiesMap.has(propName))
        return true;
      if (isJsxTagRecipe(tagName)) {
        const recipeList = getRecipesByJsxName(tagName);
        return recipeList.some((recipe) => recipePropertiesByName.get(recipe.name)?.has(propName));
      }
      return false;
    });
    const matchFn = memo2((fnName) => {
      if (recipes.has(fnName) || patterns.has(fnName))
        return true;
      if (fnName === cvaAlias || fnName === cssAlias || isRawFn(fnName) || isFactory(fnName))
        return true;
      return functions.has(fnName);
    });
    const measure = logger.time.debug(`Tokens extracted from ${filePath}`);
    const extractResultByName = extract({
      ast: sourceFile,
      components: {
        matchTag: (prop) => matchTag(prop.tagName),
        matchProp: (prop) => matchTagProp(prop.tagName, prop.propName)
      },
      functions: {
        matchFn: (prop) => matchFn(prop.fnName),
        matchProp: () => true,
        matchArg: (prop) => {
          if (prop.fnName === jsxFactoryAlias && prop.index === 1 && Node.isIdentifier(prop.argNode))
            return false;
          return true;
        }
      },
      taggedTemplates: {
        matchTaggedTemplate: (tag) => matchFn(tag.fnName)
      },
      getEvaluateOptions: (node) => ({ node, environment: defaultEnv }),
      flags: { skipTraverseFiles: true }
    });
    measure();
    extractResultByName.forEach((result, alias) => {
      let name = imports.getName(alias);
      if (isRawFn(name))
        name = name.replace(".raw", "");
      logger.debug(`ast:${name}`, name !== alias ? { kind: result.kind, alias } : { kind: result.kind });
      if (result.kind === "function") {
        match(name).when(css.match, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              collector.set(name2, {
                name: name2,
                box: query.box.value[0] ?? fallback(query.box),
                data: combineResult(unbox(query.box.value[0]))
              });
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set(name2, {
                name: name2,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).when(isValidPattern, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              collector.setPattern(name2, {
                name: name2,
                box: query.box.value[0] ?? fallback(query.box),
                data: combineResult(unbox(query.box.value[0]))
              });
            }
          });
        }).when(isValidRecipe, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              collector.setRecipe(name2, {
                name: name2,
                box: query.box.value[0] ?? fallback(query.box),
                data: combineResult(unbox(query.box.value[0]))
              });
            }
          });
        }).when(isValidStyleFn, () => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression" && query.box.value[1]) {
              const map = query.box.value[1];
              const boxNode = box.isMap(map) ? map : fallback(query.box);
              const result2 = { name, box: boxNode, data: combineResult(unbox(boxNode)) };
              if (box.isMap(map) && isCva(map.value)) {
                collector.setCva(result2);
              } else {
                collector.set("css", result2);
              }
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set("css", {
                name,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).when(isFactory, (name2) => {
          result.queryList.forEach((query) => {
            if (query.kind === "call-expression") {
              const map = query.box.value[0];
              const boxNode = box.isMap(map) ? map : fallback(query.box);
              const result2 = { name: name2, box: boxNode, data: combineResult(unbox(boxNode)) };
              if (box.isMap(map) && isCva(map.value)) {
                collector.setCva(result2);
              } else {
                collector.set("css", result2);
              }
            } else if (query.kind === "tagged-template") {
              const obj = astish(query.box.value);
              collector.set("css", {
                name: name2,
                box: query.box ?? fallback(query.box),
                data: [obj]
              });
            }
          });
        }).otherwise(() => {
        });
      } else if (result.kind === "component") {
        result.queryList.forEach((query) => {
          const data = combineResult(unbox(query.box));
          match(name).when(isFactory, (name2) => {
            collector.setJsx({ name: name2, box: query.box, type: "jsx-factory", data });
          }).when(
            (name2) => jsxPatternNodes.test(name2),
            (name2) => {
              collector.setPattern(name2, { type: "jsx-pattern", name: name2, box: query.box, data });
            }
          ).when(isJsxTagRecipe, (name2) => {
            const recipeList = getRecipesByJsxName(name2);
            recipeList.map((recipe) => {
              collector.setRecipe(recipe.name, { type: "jsx-recipe", name: name2, box: query.box, data });
            });
          }).otherwise(() => {
            collector.setJsx({ name, box: query.box, type: "jsx", data });
          });
        });
      }
    });
    return collector;
  };
}
var isUpperCase = (value) => value[0] === value[0]?.toUpperCase();

// src/vue-to-tsx.ts
import { parse } from "@vue/compiler-sfc";
import MagicString from "magic-string";
var NodeTypes = {
  ROOT: 0,
  ELEMENT: 1,
  TEXT: 2,
  COMMENT: 3,
  SIMPLE_EXPRESSION: 4,
  INTERPOLATION: 5,
  ATTRIBUTE: 6,
  DIRECTIVE: 7,
  COMPOUND_EXPRESSION: 8,
  IF: 9,
  IF_BRANCH: 10,
  FOR: 11,
  TEXT_CALL: 12,
  VNODE_CALL: 13,
  JS_CALL_EXPRESSION: 14,
  JS_OBJECT_EXPRESSION: 15,
  JS_PROPERTY: 16,
  JS_ARRAY_EXPRESSION: 17,
  JS_FUNCTION_EXPRESSION: 18,
  JS_CONDITIONAL_EXPRESSION: 19,
  JS_CACHE_EXPRESSION: 20,
  JS_BLOCK_STATEMENT: 21,
  JS_TEMPLATE_LITERAL: 22,
  JS_IF_STATEMENT: 23,
  JS_ASSIGNMENT_EXPRESSION: 24,
  JS_SEQUENCE_EXPRESSION: 25,
  JS_RETURN_STATEMENT: 26
};
var vueToTsx = (code) => {
  try {
    const parsed = parse(code);
    const fileStr = new MagicString(code);
    const rewriteProp = (prop) => {
      if (prop.type === NodeTypes.DIRECTIVE && prop.exp?.type === NodeTypes.SIMPLE_EXPRESSION && prop.arg?.type === NodeTypes.SIMPLE_EXPRESSION) {
        fileStr.update(prop.loc.start.offset, prop.loc.end.offset, `${prop.arg.content}={${prop.exp.content}}`);
      }
    };
    const stack = [...parsed.descriptor.template.ast.children];
    while (stack.length) {
      const node = stack.pop();
      if (!node)
        continue;
      if (node.type === NodeTypes.ELEMENT) {
        node.props.forEach(rewriteProp);
        node.children.forEach((child) => stack.push(child));
      }
    }
    const templateStart = code.indexOf("<template");
    const templateEnd = code.indexOf("</template>") + "</template>".length;
    const scriptContent = (parsed.descriptor.scriptSetup ?? parsed.descriptor.script)?.content + "\n";
    const transformed = new MagicString(
      `${scriptContent}
const render = ${fileStr.snip(templateStart, templateEnd).toString()}`
    );
    return transformed.toString();
  } catch (err) {
    return "";
  }
};

// src/svelte-to-tsx.ts
import MagicString2 from "magic-string";
var regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
var regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
var svelteToTsx = (code) => {
  try {
    const scripts = [];
    const original = new MagicString2(code);
    let match2;
    while ((match2 = regex_script_tags.exec(code)) != null) {
      const [fullMatch, _attributesStr, scriptContent] = match2;
      if (scriptContent) {
        scripts.push(scriptContent);
        original.remove(match2.index, match2.index + fullMatch.length);
      }
    }
    const templateContent = original.toString().trimStart().replace(regex_style_tags, "").replace(regex_style_tags, "");
    const transformed = `${scripts.join("")}
const render = <div>${templateContent}</div>`;
    return transformed.toString().trim();
  } catch (err) {
    return "";
  }
};

// src/project.ts
var createTsProject = (options) => new TsProject({
  skipAddingFilesFromTsConfig: true,
  skipFileDependencyResolution: true,
  skipLoadingLibFiles: true,
  ...options,
  compilerOptions: {
    allowJs: true,
    strictNullChecks: false,
    skipLibCheck: true,
    ...options.compilerOptions
  }
});
var createProject = ({ getFiles, readFile, parserOptions, hooks, ...projectOptions }) => pipe(
  {
    project: createTsProject(projectOptions),
    parser: createParser(parserOptions)
  },
  Obj.assign(({ project, parser }) => ({
    getSourceFile: (filePath) => project.getSourceFile(filePath),
    removeSourceFile: (filePath) => {
      const sourceFile = project.getSourceFile(filePath);
      if (sourceFile)
        project.removeSourceFile(sourceFile);
    },
    createSourceFile: (filePath) => project.createSourceFile(filePath, readFile(filePath), {
      overwrite: true,
      scriptKind: ScriptKind.TSX
    }),
    addSourceFile: (filePath, content) => project.createSourceFile(filePath, content, {
      overwrite: true,
      scriptKind: ScriptKind.TSX
    }),
    parseSourceFile: (filePath) => {
      if (filePath.endsWith(".json")) {
        const content2 = readFile(filePath);
        hooks.callHook("parser:before", filePath, content2);
        const result2 = ParserResult.fromJSON(content2).setFilePath(filePath);
        hooks.callHook("parser:after", filePath, result2);
        return result2;
      }
      const sourceFile = project.getSourceFile(filePath);
      if (!sourceFile)
        return;
      const content = sourceFile.getText();
      const transformed = transformFile(filePath, content);
      if (content !== transformed) {
        sourceFile.replaceWithText(transformed);
      }
      hooks.callHook("parser:before", filePath, content);
      const result = parser(sourceFile)?.setFilePath(filePath);
      hooks.callHook("parser:after", filePath, result);
      return result;
    }
  })),
  tap(({ createSourceFile }) => {
    const files = getFiles();
    for (const file of files) {
      createSourceFile(file);
    }
  }),
  Obj.assign(({ getSourceFile, project }) => ({
    reloadSourceFile: (filePath) => getSourceFile(filePath)?.refreshFromFileSystemSync(),
    reloadSourceFiles: () => {
      const files = getFiles();
      for (const file of files) {
        const source = getSourceFile(file);
        source?.refreshFromFileSystemSync() ?? project.addSourceFileAtPath(file);
      }
    }
  })),
  Obj.omit(["project", "parser"])
);
var transformFile = (filePath, content) => {
  if (filePath.endsWith(".vue")) {
    return vueToTsx(content);
  }
  if (filePath.endsWith(".svelte")) {
    return svelteToTsx(content);
  }
  return content;
};
export {
  ParserResult,
  createParserResult,
  createProject
};
