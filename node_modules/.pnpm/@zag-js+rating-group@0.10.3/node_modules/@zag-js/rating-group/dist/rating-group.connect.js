'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const ratingGroup_anatomy = require('./rating-group.anatomy.js');
const ratingGroup_dom = require('./rating-group.dom.js');

function connect(state, send, normalize) {
  const isInteractive = state.context.isInteractive;
  const value = state.context.value;
  const hoveredValue = state.context.hoveredValue;
  const isDisabled = state.context.disabled;
  const translations = state.context.translations;
  const api = {
    /**
     * Sets the value of the rating group
     */
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    /**
     * Clears the value of the rating group
     */
    clearValue() {
      send("CLEAR_VALUE");
    },
    /**
     * Whether the rating group is being hovered
     */
    isHovering: state.context.isHovering,
    /**
     * The current value of the rating group
     */
    value,
    /**
     * The value of the currently hovered rating
     */
    hoveredValue,
    /**
     * The maximum value of the rating group
     */
    size: state.context.max,
    /**
     * The array of rating values. Returns an array of numbers from 1 to the max value.
     */
    sizeArray: Array.from({ length: state.context.max }).map((_, index) => index + 1),
    /**
     * Returns the state of a rating item
     */
    getRatingState(props) {
      const value2 = state.context.isHovering ? state.context.hoveredValue : state.context.value;
      const isEqual = Math.ceil(value2) === props.index;
      const isHighlighted = props.index <= value2 || isEqual;
      const isHalf = isEqual && Math.abs(value2 - props.index) === 0.5;
      return {
        isEqual,
        isValueEmpty: state.context.value === -1,
        isHighlighted,
        isHalf,
        isChecked: isEqual || state.context.value === -1 && props.index === 1
      };
    },
    rootProps: normalize.element({
      dir: state.context.dir,
      ...ratingGroup_anatomy.parts.root.attrs,
      id: ratingGroup_dom.dom.getRootId(state.context)
    }),
    hiddenInputProps: normalize.input({
      ...ratingGroup_anatomy.parts.hiddenInput.attrs,
      name: state.context.name,
      form: state.context.form,
      type: "text",
      hidden: true,
      id: ratingGroup_dom.dom.getHiddenInputId(state.context),
      defaultValue: state.context.value
    }),
    labelProps: normalize.element({
      ...ratingGroup_anatomy.parts.label.attrs,
      id: ratingGroup_dom.dom.getLabelId(state.context),
      "data-disabled": domQuery.dataAttr(isDisabled)
    }),
    controlProps: normalize.element({
      id: ratingGroup_dom.dom.getControlId(state.context),
      ...ratingGroup_anatomy.parts.control.attrs,
      role: "radiogroup",
      "aria-orientation": "horizontal",
      "aria-labelledby": ratingGroup_dom.dom.getLabelId(state.context),
      tabIndex: state.context.readOnly ? 0 : -1,
      "data-disabled": domQuery.dataAttr(isDisabled),
      onPointerMove(event) {
        if (!isInteractive || event.pointerType === "touch")
          return;
        send("GROUP_POINTER_OVER");
      },
      onPointerLeave(event) {
        if (!isInteractive || event.pointerType === "touch")
          return;
        send("GROUP_POINTER_LEAVE");
      }
    }),
    getRatingProps(props) {
      const { index } = props;
      const { isHalf, isHighlighted, isChecked } = api.getRatingState(props);
      const valueText = translations.ratingValueText(index);
      return normalize.element({
        ...ratingGroup_anatomy.parts.rating.attrs,
        id: ratingGroup_dom.dom.getRatingId(state.context, index.toString()),
        role: "radio",
        tabIndex: isDisabled ? void 0 : isChecked ? 0 : -1,
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": isDisabled,
        "data-disabled": domQuery.dataAttr(isDisabled),
        "aria-readonly": domQuery.ariaAttr(state.context.readOnly),
        "data-readonly": domQuery.dataAttr(state.context.readOnly),
        "aria-setsize": state.context.max,
        "aria-checked": isChecked,
        "data-checked": domQuery.dataAttr(isChecked),
        "aria-posinset": index,
        "data-highlighted": domQuery.dataAttr(isHighlighted),
        "data-half": domQuery.dataAttr(isHalf),
        onPointerDown(event) {
          if (!isInteractive)
            return;
          const evt = domEvent.getNativeEvent(event);
          if (domEvent.isLeftClick(evt)) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!isInteractive)
            return;
          const point = domEvent.getEventPoint(domEvent.getNativeEvent(event));
          const relativePoint = domEvent.getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (!isInteractive)
            return;
          const keyMap = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = domEvent.getEventKey(event, state.context);
          const exec = keyMap[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        },
        onClick() {
          if (!isInteractive)
            return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!isInteractive)
            return;
          send("FOCUS");
        },
        onBlur() {
          if (!isInteractive)
            return;
          send("BLUR");
        }
      });
    }
  };
  return api;
}

exports.connect = connect;
