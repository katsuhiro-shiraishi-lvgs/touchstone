import { createMachine } from '@zag-js/core';
import { raf } from '@zag-js/dom-query';
import { trackFormControl } from '@zag-js/form-utils';
import { compact } from '@zag-js/utils';
import { dom } from './rating-group.dom.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        max: 5,
        dir: "ltr",
        value: -1,
        hoveredValue: -1,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"],
        value: ["invokeOnChange", "dispatchChangeEvent"]
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => !!dom.getControlEl(ctx2)?.contains(dom.getActiveEl(ctx2))
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              ctx2.value = initialContext.value;
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          ctx2.hoveredValue = -1;
        },
        focusActiveRadio(ctx2) {
          raf(() => dom.getRadioEl(ctx2)?.focus());
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          ctx2.value = Math.max(0, ctx2.value - factor);
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          ctx2.value = Math.min(ctx2.max, value + factor);
        },
        setValueToMin(ctx2) {
          ctx2.value = 1;
        },
        setValueToMax(ctx2) {
          ctx2.value = ctx2.max;
        },
        setValue(ctx2, evt) {
          ctx2.value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
        },
        clearValue(ctx2) {
          ctx2.value = -1;
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          let value = evt.index - factor;
          ctx2.hoveredValue = value;
        },
        dispatchChangeEvent(ctx2) {
          dom.dispatchChangeEvent(ctx2);
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        invokeOnHover(ctx2) {
          ctx2.onHover?.({ value: ctx2.hoveredValue });
        },
        roundValueIfNeeded(ctx2) {
          if (!ctx2.allowHalf) {
            ctx2.value = Math.round(ctx2.value);
          }
        }
      }
    }
  );
}

export { machine };
