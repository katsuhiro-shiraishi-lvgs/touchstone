'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domQuery = require('@zag-js/dom-query');
const carousel_anatomy = require('./carousel.anatomy.js');
const carousel_dom = require('./carousel.dom.js');
const getSlideInView = require('./utils/get-slide-in-view.js');

function connect(state, send, normalize) {
  const canScrollNext = state.context.canScrollNext;
  const canScrollPrev = state.context.canScrollPrev;
  const isHorizontal = state.context.isHorizontal;
  const isAutoplay = state.matches("autoplay");
  const activeSnap = state.context.scrollSnaps[state.context.index];
  const slidesInView = domQuery.isDom() ? getSlideInView.getSlidesInView(state.context)(activeSnap) : [];
  function getSlideState(props) {
    const { index } = props;
    return {
      valueText: `Slide ${index + 1}`,
      isCurrent: index === state.context.index,
      isNext: index === state.context.index + 1,
      isPrevious: index === state.context.index - 1,
      isInView: slidesInView.includes(index)
    };
  }
  return {
    /**
     * The current index of the carousel
     */
    index: state.context.index,
    /**
     * The current scroll progress of the carousel
     */
    scrollProgress: state.context.scrollProgress,
    /**
     * Whether the carousel is currently auto-playing
     */
    isAutoplay,
    /**
     * Whether the carousel is can scroll to the next slide
     */
    canScrollNext,
    /**
     * Whether the carousel is can scroll to the previous slide
     */
    canScrollPrev,
    /**
     * Function to scroll to a specific slide index
     */
    scrollTo(index, jump) {
      send({ type: "GOTO", index, jump });
    },
    /**
     * Function to scroll to the next slide
     */
    scrollToNext() {
      send("NEXT");
    },
    /**
     * Function to scroll to the previous slide
     */
    scrollToPrevious() {
      send("PREV");
    },
    /**
     *  Returns the state of a specific slide
     */
    getSlideState,
    /**
     * Function to start/resume autoplay
     */
    play() {
      send("PLAY");
    },
    /**
     * Function to pause autoplay
     */
    pause() {
      send("PAUSE");
    },
    rootProps: normalize.element({
      ...carousel_anatomy.parts.root.attrs,
      id: carousel_dom.dom.getRootId(state.context),
      role: "region",
      "aria-roledescription": "carousel",
      "data-orientation": state.context.orientation,
      "aria-label": "Carousel",
      style: {
        "--slide-spacing": state.context.spacing,
        "--slide-size": `calc(100% / ${state.context.slidesPerView} - var(--slide-spacing))`
      }
    }),
    viewportProps: normalize.element({
      ...carousel_anatomy.parts.viewport.attrs,
      id: carousel_dom.dom.getViewportId(state.context),
      "data-orientation": state.context.orientation
    }),
    slideGroupProps: normalize.element({
      ...carousel_anatomy.parts.slideGroup.attrs,
      id: carousel_dom.dom.getSlideGroupId(state.context),
      "data-orientation": state.context.orientation,
      style: {
        display: "flex",
        flexDirection: isHorizontal ? "row" : "column",
        [isHorizontal ? "height" : "width"]: "auto",
        gap: "var(--slide-spacing)",
        transform: state.context.translateValue,
        transitionProperty: "transform",
        willChange: "transform",
        transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
        transitionDuration: "0.3s"
      }
    }),
    getSlideProps(props) {
      const { index } = props;
      const sliderState = getSlideState(props);
      return normalize.element({
        ...carousel_anatomy.parts.slide.attrs,
        id: carousel_dom.dom.getSlideId(state.context, index),
        "data-current": domQuery.dataAttr(sliderState.isCurrent),
        "data-inview": domQuery.dataAttr(sliderState.isInView),
        role: "group",
        "aria-roledescription": "slide",
        "data-orientation": state.context.orientation,
        "aria-label": sliderState.valueText,
        style: {
          position: "relative",
          flex: "0 0 var(--slide-size)",
          [isHorizontal ? "minWidth" : "minHeight"]: "0px"
        }
      });
    },
    prevTriggerProps: normalize.button({
      ...carousel_anatomy.parts.previousTrigger.attrs,
      id: carousel_dom.dom.getPrevTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      disabled: !canScrollPrev,
      "aria-label": "Previous Slide",
      "data-orientation": state.context.orientation,
      "aria-controls": carousel_dom.dom.getSlideGroupId(state.context),
      onClick() {
        send("PREV");
      }
    }),
    nextTriggerProps: normalize.button({
      ...carousel_anatomy.parts.nextTrigger.attrs,
      id: carousel_dom.dom.getNextTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      "aria-label": "Next Slide",
      "data-orientation": state.context.orientation,
      "aria-controls": carousel_dom.dom.getSlideGroupId(state.context),
      disabled: !canScrollNext,
      onClick() {
        send("NEXT");
      }
    }),
    indicatorGroupProps: normalize.element({
      ...carousel_anatomy.parts.indicatorGroup.attrs,
      "data-orientation": state.context.orientation
    }),
    getIndicatorProps(props) {
      const { index } = props;
      return normalize.button({
        ...carousel_anatomy.parts.indicator.attrs,
        id: carousel_dom.dom.getIndicatorId(state.context, index),
        type: "button",
        "data-orientation": state.context.orientation,
        "data-index": index,
        "data-current": domQuery.dataAttr(index === state.context.index)
      });
    }
  };
}

exports.connect = connect;
