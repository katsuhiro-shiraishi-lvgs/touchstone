import { createMachine, ref } from '@zag-js/core';
import { compact, nextIndex, prevIndex } from '@zag-js/utils';
import { dom } from './carousel.dom.mjs';
import { getScrollSnaps } from './utils/get-scroll-snaps.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "carousel",
      initial: "idle",
      context: {
        index: 0,
        orientation: "horizontal",
        align: "start",
        loop: false,
        slidesPerView: 1,
        spacing: "0px",
        ...ctx,
        scrollSnaps: [],
        scrollProgress: 0,
        containerSize: 0,
        slideRects: []
      },
      watch: {
        index: ["invokeOnSlideChange", "setScrollSnaps"]
      },
      on: {
        NEXT: {
          actions: ["scrollToNext"]
        },
        PREV: {
          actions: ["scrollToPrev"]
        },
        GOTO: {
          actions: ["scrollTo"]
        },
        MEASURE_DOM: {
          actions: ["measureElements", "setScrollSnaps"]
        },
        PLAY: "autoplay"
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: "dragging"
          }
        },
        autoplay: {
          activities: ["trackDocumentVisibility"],
          every: {
            2e3: ["scrollToNext"]
          },
          on: {
            PAUSE: "idle"
          }
        },
        dragging: {
          on: {
            POINTER_UP: "idle",
            POINTER_MOVE: {
              actions: ["setScrollSnaps"]
            }
          }
        }
      },
      activities: ["trackContainerResize", "trackSlideMutation"],
      entry: ["measureElements", "setScrollSnaps"],
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        canScrollNext: (ctx2) => ctx2.loop || ctx2.index < ctx2.scrollSnaps.length - 1,
        canScrollPrev: (ctx2) => ctx2.loop || ctx2.index > 0,
        startEdge(ctx2) {
          if (ctx2.isVertical)
            return "top";
          return ctx2.isRtl ? "right" : "left";
        },
        endEdge(ctx2) {
          if (ctx2.isVertical)
            return "bottom";
          return ctx2.isRtl ? "left" : "right";
        },
        translateValue: (ctx2) => {
          const scrollSnap = ctx2.scrollSnaps[ctx2.index];
          return ctx2.isHorizontal ? `translate3d(${scrollSnap}px, 0, 0)` : `translate3d(0, ${scrollSnap}px, 0)`;
        }
      }
    },
    {
      activities: {
        trackSlideMutation(ctx2, _evt, { send }) {
          const container = dom.getSlideGroupEl(ctx2);
          const win = dom.getWin(ctx2);
          const observer = new win.MutationObserver(() => {
            send({ type: "MEASURE_DOM", src: "mutation" });
          });
          observer.observe(container, { childList: true });
          return () => {
            observer.disconnect();
          };
        },
        trackContainerResize(ctx2, _evt, { send }) {
          const container = dom.getSlideGroupEl(ctx2);
          const win = dom.getWin(ctx2);
          const observer = new win.ResizeObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.target === container) {
                send({ type: "MEASURE_DOM", src: "resize" });
              }
            });
          });
          observer.observe(container);
          return () => {
            observer.disconnect();
          };
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          const doc = dom.getDoc(ctx2);
          const onVisibilityChange = () => {
            if (doc.visibilityState !== "visible") {
              send({ type: "PAUSE", src: "document-hidden" });
            }
          };
          doc.addEventListener("visibilitychange", onVisibilityChange);
          return () => {
            doc.removeEventListener("visibilitychange", onVisibilityChange);
          };
        }
      },
      guards: {
        loop: (ctx2) => ctx2.loop,
        isLastSlide: (ctx2) => ctx2.index === ctx2.slideRects.length - 1,
        isFirstSlide: (ctx2) => ctx2.index === 0
      },
      actions: {
        invokeOnSlideChange(ctx2, _evt) {
          ctx2.onSlideChange?.({ index: ctx2.index });
        },
        scrollToNext(ctx2) {
          ctx2.index = nextIndex(ctx2.slideRects, ctx2.index);
        },
        scrollToPrev(ctx2) {
          ctx2.index = prevIndex(ctx2.slideRects, ctx2.index);
        },
        setScrollSnaps(ctx2) {
          const { snapsAligned, scrollProgress } = getScrollSnaps(ctx2);
          ctx2.scrollSnaps = snapsAligned;
          ctx2.scrollProgress = scrollProgress;
        },
        scrollTo(ctx2, evt) {
          ctx2.index = Math.max(0, Math.min(evt.index, ctx2.slideRects.length - 1));
        },
        measureElements
      }
    }
  );
}
const measureElements = (ctx) => {
  const container = dom.getSlideGroupEl(ctx);
  ctx.containerRect = ref(container.getBoundingClientRect());
  ctx.containerSize = ctx.isHorizontal ? ctx.containerRect.width : ctx.containerRect.height;
  ctx.slideRects = ref(dom.getSlideEls(ctx).map((slide) => slide.getBoundingClientRect()));
};

export { machine };
