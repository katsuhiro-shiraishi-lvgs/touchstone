"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Token: () => Token,
  TokenDictionary: () => TokenDictionary2
});
module.exports = __toCommonJS(src_exports);

// src/create-dictionary.ts
var import_shared7 = require("@pandacss/shared");

// src/dictionary.ts
var import_shared3 = require("@pandacss/shared");
var import_ts_pattern = require("ts-pattern");

// src/token.ts
var import_shared2 = require("@pandacss/shared");

// src/utils.ts
var import_shared = require("@pandacss/shared");
var REFERENCE_REGEX = /(\$[^\s,]+\w)|({([^}]*)})/g;
var curlyBracketRegex = /[{}]/g;
function getReferences(value) {
  if (typeof value !== "string")
    return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches)
    return [];
  return matches.map((match3) => match3.replace(curlyBracketRegex, "")).map((value2) => value2.trim());
}
function hasReference(value) {
  return REFERENCE_REGEX.test(value);
}
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
var isToken = (value) => {
  return (0, import_shared.isObject)(value) && "value" in value;
};
function assertTokenFormat(token) {
  if (!isToken(token)) {
    throw new Error(`Invalid token format: ${JSON.stringify(token)}`);
  }
}

// src/token.ts
var Token = class _Token {
  name;
  value;
  originalValue;
  path;
  type;
  description;
  extensions;
  constructor(data) {
    this.name = data.name;
    this.value = data.value;
    this.originalValue = data.value;
    this.path = data.path ?? [];
    if (data.type) {
      this.type = data.type;
    }
    if (data.description) {
      this.description = data.description;
    }
    this.extensions = data.extensions ?? {};
    this.extensions.condition = data.extensions?.condition ?? "base";
    this.setType();
  }
  /**
   * The unique identifier of the token.
   */
  get id() {
    return (0, import_shared2.toHash)(`${this.name}-${this.extensions.condition}-${this.value}`);
  }
  /**
   * Whether the token is a conditional token.
   * Conditional tokens are tokens that have multiple values based on a condition.
   */
  get isConditional() {
    return !!this.extensions?.conditions;
  }
  /**
   * Whether the token has a reference in its value.
   * e.g. {color.gray.100}
   */
  get hasReference() {
    return !!this.extensions?.references;
  }
  /**
   * Whether the token is a complex or composite token.
   */
  get isComposite() {
    return (0, import_shared2.isObject)(this.originalValue) || Array.isArray(this.originalValue);
  }
  /**
   * Returns the token value with the references expanded.
   * e.g. {color.gray.100} => #f7fafc
   *
   */
  expandReferences() {
    if (!this.hasReference)
      return this.value;
    const references = this.extensions.references ?? {};
    this.value = Object.keys(references).reduce((valueStr, key) => {
      const referenceToken = references[key];
      if (referenceToken.isConditional) {
        return valueStr;
      }
      const value = referenceToken.expandReferences();
      return valueStr.replace(`{${key}}`, value);
    }, this.value);
    delete this.extensions.references;
    return this.value;
  }
  /**
   * Whether this token has a reference to another token
   */
  get isReference() {
    return hasReference(this.originalValue);
  }
  /**
   * Returns the list of references in the token value
   */
  get references() {
    return getReferences(this.originalValue);
  }
  clone() {
    return new _Token({
      name: this.name,
      value: this.value,
      type: this.type,
      path: [...this.path],
      description: this.description,
      extensions: cloneDeep(this.extensions)
    });
  }
  /**
   * Returns an array of tokens per conditions.
   * It is commonly used in semantic tokens, and can have multiple values based on a condition.
   * e.g. primary: { light: '#000', dark: '#fff' }
   */
  getConditionTokens() {
    if (!this.isConditional)
      return;
    const conditions = this.extensions.conditions ?? {};
    const conditionalTokens = [];
    (0, import_shared2.walkObject)(conditions, (value, path) => {
      const newPath = path.filter((v) => !(0, import_shared2.isBaseCondition)(v));
      if (!newPath.length)
        return;
      const token = this.clone();
      token.value = value;
      token.extensions.condition = newPath.join(":");
      conditionalTokens.push(token);
    });
    return conditionalTokens;
  }
  /**
   * Add more extensions to the token
   */
  setExtensions(extensions) {
    this.extensions = { ...this.extensions, ...extensions };
    this.setType();
    return this;
  }
  setType() {
    if (this.type)
      return;
    if (this.extensions.category) {
      this.type = TOKEN_TYPES[this.extensions.category];
    }
  }
};
function cloneDeep(value) {
  if (value instanceof Token) {
    return value.clone();
  }
  if (Array.isArray(value)) {
    return value.map((child) => cloneDeep(child));
  }
  if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, cloneDeep(v)]));
  }
  return value;
}
var TOKEN_TYPES = {
  colors: "color",
  spacing: "dimension",
  sizing: "dimension",
  shadows: "shadow",
  fonts: "fontFamily",
  fontSizes: "fontSize",
  fontWeights: "fontWeight",
  letterSpacings: "letterSpacing",
  durations: "duration",
  transitions: "transition",
  radii: "borderRadius",
  gradients: "gradient",
  easings: "cubicBezier",
  borders: "border",
  components: "cti",
  assets: "asset"
};

// src/dictionary.ts
function expandBreakpoints(breakpoints) {
  if (!breakpoints)
    return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: (0, import_shared3.mapObject)(breakpoints, (value) => ({ value })),
    sizes: Object.fromEntries(Object.entries(breakpoints).map(([key, value]) => [`breakpoint-${key}`, { value }]))
  };
}
function filterDefault(path) {
  if (path[0] === "DEFAULT")
    return path;
  return path.filter((item) => item !== "DEFAULT");
}
var TokenDictionary = class {
  allTokens = [];
  prefix;
  hash;
  get allNames() {
    return Array.from(new Set(this.allTokens.map((token) => token.name)));
  }
  constructor(options) {
    const { tokens = {}, semanticTokens = {}, breakpoints, prefix, hash } = options;
    const breakpointTokens = expandBreakpoints(breakpoints);
    const computedTokens = (0, import_shared3.compact)({
      ...tokens,
      breakpoints: breakpointTokens.breakpoints,
      sizes: {
        ...tokens.sizes,
        ...breakpointTokens.sizes
      }
    });
    this.prefix = prefix;
    this.hash = hash;
    (0, import_shared3.walkObject)(
      computedTokens,
      (token, path) => {
        path = filterDefault(path);
        assertTokenFormat(token);
        const category = path[0];
        const name = path.join(".");
        const node = new Token({ ...token, name, path });
        node.setExtensions({
          category,
          prop: path.slice(1).join(".")
        });
        this.allTokens.push(node);
      },
      { stop: isToken }
    );
    (0, import_shared3.walkObject)(
      semanticTokens,
      (token, path) => {
        path = filterDefault(path);
        assertTokenFormat(token);
        const category = path[0];
        const name = path.join(".");
        const normalizedToken = (0, import_shared3.isString)(token.value) ? { value: { base: token.value } } : token;
        const { value, ...restData } = normalizedToken;
        const node = new Token({
          ...restData,
          name,
          value: value.base || "",
          path
        });
        node.setExtensions({
          category,
          conditions: value,
          prop: path.slice(1).join(".")
        });
        this.allTokens.push(node);
      },
      { stop: isToken }
    );
  }
  getByName = (0, import_shared3.memo)((name) => {
    for (const token of this.allTokens) {
      if (token.name === name)
        return token;
    }
  });
  transforms = /* @__PURE__ */ new Map();
  registerTransform(...transforms2) {
    transforms2.forEach((transform) => {
      transform.type ||= "value";
      transform.enforce ||= "pre";
      this.transforms.set(transform.name, transform);
    });
    return this;
  }
  execTransform(name) {
    const transform = this.transforms.get(name);
    if (!transform)
      return;
    this.allTokens.forEach((token) => {
      if (token.extensions.hasReference)
        return;
      if (typeof transform.match === "function" && !transform.match(token))
        return;
      const transformed = transform.transform(token, {
        prefix: this.prefix,
        hash: this.hash
      });
      (0, import_ts_pattern.match)(transform).with({ type: "extensions" }, () => {
        token.setExtensions(transformed);
      }).with({ type: "value" }, () => {
        token.value = transformed;
        if (token.isComposite) {
          token.originalValue = transformed;
        }
      }).otherwise(() => {
        token[transform.type] = transformed;
      });
    });
  }
  transformTokens(enforce) {
    this.transforms.forEach((transform) => {
      if (transform.enforce === enforce) {
        this.execTransform(transform.name);
      }
    });
    return this;
  }
  middlewares = [];
  registerMiddleware(...middlewares2) {
    for (const middleware of middlewares2) {
      middleware.enforce ||= "pre";
      this.middlewares.push(middleware);
    }
    return this;
  }
  applyMiddlewares(enforce) {
    this.middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(this, { prefix: this.prefix });
      }
    });
  }
  getReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref) => this.getByName(ref)).filter(Boolean);
  }
  usesReference(value) {
    if (!(0, import_shared3.isString)(value))
      return false;
    return this.getReferences(value).length > 0;
  }
  addReferences() {
    this.allTokens.forEach((token) => {
      if (!this.usesReference(token.value))
        return;
      const references = this.getReferences(token.value);
      token.setExtensions({
        references: references.reduce((object, reference) => {
          object[reference.name] = reference;
          return object;
        }, {})
      });
    });
    return this;
  }
  filter(pattern) {
    const predicate = typeof pattern === "function" ? pattern : (0, import_ts_pattern.isMatching)(pattern);
    return this.allTokens.filter(predicate);
  }
  addConditionalTokens() {
    const tokens = [];
    this.allTokens.forEach((token) => {
      tokens.push(token);
      const conditionalTokens = token.getConditionTokens();
      if (conditionalTokens && conditionalTokens.length > 0) {
        tokens.push(...conditionalTokens);
      }
    });
    this.allTokens = tokens;
    return this;
  }
  expandReferences() {
    this.allTokens.forEach((token) => {
      token.expandReferences();
    });
    return this;
  }
  build() {
    this.applyMiddlewares("pre");
    this.transformTokens("pre");
    this.addConditionalTokens();
    this.addReferences();
    this.expandReferences();
    this.applyMiddlewares("post");
    this.transformTokens("post");
  }
  get isEmpty() {
    return this.allTokens.length === 0;
  }
};

// src/format.ts
var import_shared4 = require("@pandacss/shared");
var formats = {
  groupByCondition(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { condition } = token.extensions;
      if (!condition)
        return;
      grouped.get(condition) || grouped.set(condition, /* @__PURE__ */ new Set());
      grouped.set(condition, grouped.get(condition).add(token));
    });
    return grouped;
  },
  groupByColorPalette(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette || token.extensions.isVirtual)
        return;
      grouped.get(colorPalette) || grouped.set(colorPalette, /* @__PURE__ */ new Map());
      const virtualName = token.name.replace(colorPalette, "colorPalette");
      const virtualToken = dictionary.getByName(virtualName);
      if (!virtualToken)
        return;
      const virtualVar = virtualToken.extensions.var;
      grouped.get(colorPalette).set(virtualVar, token.extensions.varRef);
    });
    return grouped;
  },
  groupByCategory(dictionary) {
    const grouped = /* @__PURE__ */ new Map();
    dictionary.allTokens.forEach((token) => {
      const { category, prop } = token.extensions;
      if (!category)
        return;
      grouped.get(category) || grouped.set(category, /* @__PURE__ */ new Map());
      grouped.set(category, grouped.get(category).set(prop, token));
    });
    return grouped;
  },
  getFlattenedValues(dictionary) {
    const grouped = formats.groupByCategory(dictionary);
    const result = /* @__PURE__ */ new Map();
    grouped.forEach((tokens, category) => {
      result.get(category) || result.set(category, /* @__PURE__ */ new Map());
      tokens.forEach((token) => {
        const { prop, varRef, isNegative } = token.extensions;
        const value = isNegative ? token.isConditional ? token.originalValue : token.value : varRef;
        result.set(category, result.get(category).set(prop, value));
      });
    });
    return result;
  },
  getVars(dictionary) {
    const grouped = formats.groupByCondition(dictionary);
    const result = /* @__PURE__ */ new Map();
    grouped.forEach((tokens, condition) => {
      result.get(condition) || result.set(condition, /* @__PURE__ */ new Map());
      tokens.forEach((token) => {
        if (token.extensions.isNegative || token.extensions.isVirtual)
          return;
        result.get(condition).set(token.extensions.var, token.value);
      });
    });
    return result;
  },
  createVarGetter(dictionary) {
    const flatValues = mapToJson(formats.getFlattenedValues(dictionary));
    return function getToken(path, fallback) {
      return (0, import_shared4.getDotPath)(flatValues, path, fallback);
    };
  },
  getColorPaletteValues(dictionary) {
    const values = /* @__PURE__ */ new Set();
    dictionary.allTokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette || token.extensions.isVirtual)
        return;
      values.add(colorPalette);
    });
    return values;
  }
};

// src/middleware.ts
var import_shared5 = require("@pandacss/shared");
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary, { prefix, hash }) {
    const tokens = dictionary.filter({
      extensions: { category: "spacing" }
    });
    tokens.forEach((token) => {
      const originalPath = [...token.path];
      const originalVar = (0, import_shared5.cssVar)(originalPath.join("-"), { prefix, hash });
      if (token.value === "0rem") {
        return;
      }
      const node = token.clone();
      node.setExtensions({
        isNegative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      node.value = import_shared5.calc.negate(originalVar);
      const last = node.path.at(-1);
      if (last != null) {
        node.path[node.path.length - 1] = `-${last}`;
      }
      if (node.path) {
        node.name = node.path.join(".");
      }
      dictionary.allTokens.push(node);
    });
  }
};
var units = /* @__PURE__ */ new Set(["spacing", "sizes", "borderWidths", "fontSizes", "radii"]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.isNegative;
    });
    tokens.forEach((token) => {
      token.setExtensions({
        pixelValue: (0, import_shared5.toPx)(token.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter({
      extensions: { category: "colors" }
    });
    const keys = /* @__PURE__ */ new Set();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette)
        return;
      const list = colorPalettes.get(colorPalette) || [];
      keys.add(token.path.at(-1));
      list.push(token);
      colorPalettes.set(colorPalette, list);
    });
    keys.forEach((key) => {
      const node = new Token({
        name: `colors.colorPalette.${key}`,
        value: `{colors.colorPalette.${key}}`,
        path: ["colors", "colorPalette", key]
      });
      node.setExtensions({
        category: "colors",
        prop: `colorPalette.${key}`,
        isVirtual: true
      });
      dictionary.allTokens.push(node);
    });
    dictionary.transformTokens("pre");
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter((token) => token.value !== "");
  }
};
var middlewares = [addNegativeTokens, addVirtualPalette, removeEmptyTokens, addPixelUnit];

// src/transform.ts
var import_shared6 = require("@pandacss/shared");
var import_ts_pattern2 = require("ts-pattern");

// src/mini-svg-uri.ts
var shorterNames = {
  aqua: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  azure: /#f0ffff(ff)?(?!\w)/gi,
  beige: /#f5f5dc(ff)?(?!\w)/gi,
  bisque: /#ffe4c4(ff)?(?!\w)/gi,
  black: /#000000(ff)?(?!\w)|#000(f)?(?!\w)/gi,
  blue: /#0000ff(ff)?(?!\w)|#00f(f)?(?!\w)/gi,
  brown: /#a52a2a(ff)?(?!\w)/gi,
  coral: /#ff7f50(ff)?(?!\w)/gi,
  cornsilk: /#fff8dc(ff)?(?!\w)/gi,
  crimson: /#dc143c(ff)?(?!\w)/gi,
  cyan: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  darkblue: /#00008b(ff)?(?!\w)/gi,
  darkcyan: /#008b8b(ff)?(?!\w)/gi,
  darkgrey: /#a9a9a9(ff)?(?!\w)/gi,
  darkred: /#8b0000(ff)?(?!\w)/gi,
  deeppink: /#ff1493(ff)?(?!\w)/gi,
  dimgrey: /#696969(ff)?(?!\w)/gi,
  gold: /#ffd700(ff)?(?!\w)/gi,
  green: /#008000(ff)?(?!\w)/gi,
  grey: /#808080(ff)?(?!\w)/gi,
  honeydew: /#f0fff0(ff)?(?!\w)/gi,
  hotpink: /#ff69b4(ff)?(?!\w)/gi,
  indigo: /#4b0082(ff)?(?!\w)/gi,
  ivory: /#fffff0(ff)?(?!\w)/gi,
  khaki: /#f0e68c(ff)?(?!\w)/gi,
  lavender: /#e6e6fa(ff)?(?!\w)/gi,
  lime: /#00ff00(ff)?(?!\w)|#0f0(f)?(?!\w)/gi,
  linen: /#faf0e6(ff)?(?!\w)/gi,
  maroon: /#800000(ff)?(?!\w)/gi,
  moccasin: /#ffe4b5(ff)?(?!\w)/gi,
  navy: /#000080(ff)?(?!\w)/gi,
  oldlace: /#fdf5e6(ff)?(?!\w)/gi,
  olive: /#808000(ff)?(?!\w)/gi,
  orange: /#ffa500(ff)?(?!\w)/gi,
  orchid: /#da70d6(ff)?(?!\w)/gi,
  peru: /#cd853f(ff)?(?!\w)/gi,
  pink: /#ffc0cb(ff)?(?!\w)/gi,
  plum: /#dda0dd(ff)?(?!\w)/gi,
  purple: /#800080(ff)?(?!\w)/gi,
  red: /#ff0000(ff)?(?!\w)|#f00(f)?(?!\w)/gi,
  salmon: /#fa8072(ff)?(?!\w)/gi,
  seagreen: /#2e8b57(ff)?(?!\w)/gi,
  seashell: /#fff5ee(ff)?(?!\w)/gi,
  sienna: /#a0522d(ff)?(?!\w)/gi,
  silver: /#c0c0c0(ff)?(?!\w)/gi,
  skyblue: /#87ceeb(ff)?(?!\w)/gi,
  snow: /#fffafa(ff)?(?!\w)/gi,
  tan: /#d2b48c(ff)?(?!\w)/gi,
  teal: /#008080(ff)?(?!\w)/gi,
  thistle: /#d8bfd8(ff)?(?!\w)/gi,
  tomato: /#ff6347(ff)?(?!\w)/gi,
  violet: /#ee82ee(ff)?(?!\w)/gi,
  wheat: /#f5deb3(ff)?(?!\w)/gi,
  white: /#ffffff(ff)?(?!\w)|#fff(f)?(?!\w)/gi
};
var REGEX = {
  whitespace: /\s+/g,
  urlHexPairs: /%[\dA-F]{2}/g,
  quotes: /"/g
};
function collapseWhitespace(str) {
  return str.trim().replace(REGEX.whitespace, " ");
}
function dataURIPayload(string) {
  return encodeURIComponent(string).replace(REGEX.urlHexPairs, specialHexEncode);
}
function colorCodeToShorterNames(string) {
  objectKeys(shorterNames).forEach((key) => {
    if (shorterNames[key].test(string)) {
      string = string.replace(shorterNames[key], key);
    }
  });
  return string;
}
function specialHexEncode(match3) {
  switch (match3) {
    case "%20":
      return " ";
    case "%3D":
      return "=";
    case "%3A":
      return ":";
    case "%2F":
      return "/";
    default:
      return match3.toLowerCase();
  }
}
function svgToDataUri(svgString) {
  if (typeof svgString !== "string") {
    throw new TypeError("Expected a string, but received " + typeof svgString);
  }
  if (svgString.charCodeAt(0) === 65279) {
    svgString = svgString.slice(1);
  }
  const body = colorCodeToShorterNames(collapseWhitespace(svgString)).replace(REGEX.quotes, "'");
  return "data:image/svg+xml," + dataURIPayload(body);
}
var objectKeys = (obj) => Object.keys(obj);

// src/transform.ts
var isCompositeShadow = (0, import_ts_pattern2.isMatching)({
  inset: import_ts_pattern2.P.optional(import_ts_pattern2.P.boolean),
  offsetX: import_ts_pattern2.P.number,
  offsetY: import_ts_pattern2.P.number,
  blur: import_ts_pattern2.P.number,
  spread: import_ts_pattern2.P.number,
  color: import_ts_pattern2.P.string
});
var transformShadow = {
  name: "tokens/shadow",
  match: (token) => token.extensions.category === "shadows",
  transform(token, { prefix }) {
    if ((0, import_shared6.isString)(token.value)) {
      return token.value;
    }
    if (Array.isArray(token.value)) {
      if (token.extensions.conditions) {
        const conditions = token.extensions.conditions;
        for (const [prop, value] of Object.entries(conditions)) {
          if (Array.isArray(value)) {
            conditions[prop] = value.map((value2) => this.transform({ value: value2 }, { prefix })).join(", ");
          }
        }
        if (token.extensions.conditions?.base && Array.isArray(token.originalValue)) {
          return token.extensions.conditions.base;
        }
      }
      return token.value.map((value) => this.transform({ value }, { prefix })).join(", ");
    }
    if (isCompositeShadow(token.value)) {
      const { offsetX, offsetY, blur, spread, color, inset } = token.value;
      return `${inset ? "inset " : ""}${offsetX}px ${offsetY}px ${blur}px ${spread}px ${color}`;
    }
    return token.value;
  }
};
var isCompositeGradient = (0, import_ts_pattern2.isMatching)({
  type: import_ts_pattern2.P.string,
  placement: import_ts_pattern2.P.string,
  stops: import_ts_pattern2.P.union(
    import_ts_pattern2.P.array(import_ts_pattern2.P.string),
    import_ts_pattern2.P.array({
      color: import_ts_pattern2.P.string,
      position: import_ts_pattern2.P.number
    })
  )
});
var transformGradient = {
  name: "tokens/gradient",
  match: (token) => token.extensions.category === "gradients",
  transform(token) {
    if ((0, import_shared6.isString)(token.value)) {
      return token.value;
    }
    if (isCompositeGradient(token.value)) {
      const { type, stops, placement } = token.value;
      const rawStops = stops.map((stop) => {
        if ((0, import_shared6.isString)(stop))
          return stop;
        const { color, position } = stop;
        return `${color} ${position}px`;
      });
      return `${type}-gradient(${placement}, ${rawStops.join(", ")})`;
    }
    return token.value;
  }
};
var transformFonts = {
  name: "tokens/fonts",
  match: (token) => token.extensions.category === "fonts",
  transform(token) {
    if (Array.isArray(token.value)) {
      return token.value.join(", ");
    }
    return token.value;
  }
};
var transformEasings = {
  name: "tokens/easings",
  match: (token) => token.extensions.category === "easings",
  transform(token) {
    if ((0, import_shared6.isString)(token.value)) {
      return token.value;
    }
    return `cubic-bezier(${token.value.join(", ")})`;
  }
};
var transformBorders = {
  name: "tokens/borders",
  match: (token) => token.extensions.category === "borders",
  transform(token) {
    if ((0, import_shared6.isString)(token.value)) {
      return token.value;
    }
    const { width, style, color } = token.value;
    return `${width}px ${style} ${color}`;
  }
};
var transformAssets = {
  name: "tokens/assets",
  match: (token) => token.extensions.category === "assets",
  transform(token) {
    const raw = token.value;
    return (0, import_ts_pattern2.match)(raw).with(import_ts_pattern2.P.string, (value) => value).with({ type: "url" }, ({ value }) => `url(${value})`).with({ type: "svg" }, ({ value }) => `url(${svgToDataUri(value)})`).exhaustive();
  }
};
var addCssVariables = {
  type: "extensions",
  name: "tokens/css-var",
  transform(token, { prefix, hash }) {
    const { isNegative, originalPath } = token.extensions;
    const pathValue = isNegative ? originalPath : token.path;
    const variable = (0, import_shared6.cssVar)(pathValue.join("-"), { prefix, hash });
    return {
      var: variable.var,
      varRef: variable.ref
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  name: "tokens/conditionals",
  transform(token, { prefix, hash }) {
    const refs = getReferences(token.value);
    if (!refs.length)
      return token.value;
    refs.forEach((ref) => {
      const variable = (0, import_shared6.cssVar)(ref.split(".").join("-"), { prefix, hash }).ref;
      token.value = token.value.replace(`{${ref}}`, variable);
    });
    return token.value;
  }
};
function getColorPaletteName(path) {
  if (path.includes("colorPalette"))
    return "";
  const clone = [...path];
  clone.pop();
  clone.shift();
  return clone.join(".");
}
var addColorPalette = {
  type: "extensions",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors";
  },
  transform(token) {
    return { colorPalette: getColorPaletteName(token.path) };
  }
};
var transforms = [
  transformShadow,
  transformGradient,
  transformFonts,
  transformEasings,
  transformBorders,
  transformAssets,
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// src/create-dictionary.ts
var TokenDictionary2 = class extends TokenDictionary {
  constructor(options) {
    super(options);
    this.registerTransform(...transforms);
    this.registerMiddleware(...middlewares);
    this.build();
  }
  get get() {
    return formats.createVarGetter(this);
  }
  get conditionMap() {
    return formats.groupByCondition(this);
  }
  get categoryMap() {
    return formats.groupByCategory(this);
  }
  get values() {
    return formats.getFlattenedValues(this);
  }
  get colorPalettes() {
    return (0, import_shared7.mapToJson)(formats.groupByColorPalette(this));
  }
  get vars() {
    return formats.getVars(this);
  }
  getValue(path) {
    const result = this.values.get(path);
    if (result != null) {
      return Object.fromEntries(result);
    }
  }
  getTokenVar(path) {
    const json = (0, import_shared7.mapToJson)(this.values);
    return (0, import_shared7.getDotPath)(json, path);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Token,
  TokenDictionary
});
