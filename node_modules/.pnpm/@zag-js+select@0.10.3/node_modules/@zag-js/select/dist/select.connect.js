'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const popper = require('@zag-js/popper');
const visuallyHidden = require('@zag-js/visually-hidden');
const select_anatomy = require('./select.anatomy.js');
const select_dom = require('./select.dom.js');
const select_utils = require('./select.utils.js');

function connect(state, send, normalize) {
  const disabled = state.context.disabled;
  const invalid = state.context.invalid;
  const isInteractive = state.context.isInteractive;
  const isOpen = state.matches("open");
  const highlightedOption = state.context.highlightedOption;
  const selectedOption = state.context.selectedOption;
  const isTypingAhead = state.context.isTypingAhead;
  function getOptionState(props) {
    const id = select_dom.dom.getOptionId(state.context, props.value);
    return {
      isDisabled: Boolean(props.disabled || disabled),
      isHighlighted: state.context.highlightedId === id,
      isSelected: state.context.selectedOption?.value === props.value
    };
  }
  const popperStyles = popper.getPlacementStyles({
    placement: state.context.currentPlacement
  });
  return {
    /**
     * Whether the select is open
     */
    isOpen,
    /**
     * The currently highlighted option
     */
    highlightedOption,
    /**
     * The currently selected option
     */
    selectedOption,
    /**
     * Function to focus the select
     */
    focus() {
      select_dom.dom.getTriggerElement(state.context)?.focus();
    },
    /**
     * Function to open the select
     */
    open() {
      send("OPEN");
    },
    /**
     * Function to close the select
     */
    close() {
      send("CLOSE");
    },
    /**
     * Function to set the selected option
     */
    setSelectedOption(value) {
      select_utils.validateOptionData(value);
      send({ type: "SELECT_OPTION", value });
    },
    /**
     * Function to set the highlighted option
     */
    setHighlightedOption(value) {
      select_utils.validateOptionData(value);
      send({ type: "HIGHLIGHT_OPTION", value });
    },
    /**
     * Function to clear the selected option
     */
    clearSelectedOption() {
      send({ type: "CLEAR_SELECTED" });
    },
    /**
     * Returns the state details of an option
     */
    getOptionState,
    labelProps: normalize.label({
      dir: state.context.dir,
      id: select_dom.dom.getLabelId(state.context),
      ...select_anatomy.parts.label.attrs,
      "data-disabled": domQuery.dataAttr(disabled),
      "data-invalid": domQuery.dataAttr(invalid),
      "data-readonly": domQuery.dataAttr(state.context.readOnly),
      htmlFor: select_dom.dom.getHiddenSelectId(state.context),
      onClick() {
        if (disabled)
          return;
        select_dom.dom.getTriggerElement(state.context)?.focus();
      }
    }),
    positionerProps: normalize.element({
      ...select_anatomy.parts.positioner.attrs,
      id: select_dom.dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    triggerProps: normalize.button({
      id: select_dom.dom.getTriggerId(state.context),
      disabled,
      dir: state.context.dir,
      type: "button",
      "aria-controls": select_dom.dom.getContentId(state.context),
      "aria-expanded": isOpen,
      "data-expanded": domQuery.dataAttr(isOpen),
      "aria-haspopup": "listbox",
      "aria-labelledby": select_dom.dom.getLabelId(state.context),
      ...select_anatomy.parts.trigger.attrs,
      "data-disabled": domQuery.dataAttr(disabled),
      "data-invalid": domQuery.dataAttr(invalid),
      "aria-invalid": invalid,
      "data-readonly": domQuery.dataAttr(state.context.readOnly),
      "data-placement": state.context.currentPlacement,
      "data-placeholder-shown": domQuery.dataAttr(!state.context.hasSelectedOption),
      onPointerDown(event) {
        if (event.button || event.ctrlKey || !isInteractive)
          return;
        event.currentTarget.dataset.pointerType = event.pointerType;
        if (disabled || event.pointerType === "touch")
          return;
        send({ type: "TRIGGER_CLICK" });
      },
      onClick(event) {
        if (!isInteractive || event.button)
          return;
        if (event.currentTarget.dataset.pointerType === "touch") {
          send({ type: "TRIGGER_CLICK" });
        }
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          ArrowLeft() {
            send({ type: "ARROW_LEFT" });
          },
          ArrowRight() {
            send({ type: "ARROW_RIGHT" });
          },
          Home() {
            send({ type: "HOME" });
          },
          Enter() {
            send({ type: "TRIGGER_CLICK" });
          },
          End() {
            send({ type: "END" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              send({ type: "TRIGGER_KEY" });
            }
          }
        };
        const exec = keyMap[domEvent.getEventKey(event, state.context)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (domQuery.getByTypeahead.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    getOptionProps(props) {
      const { value, label, valueText } = props;
      const optionState = getOptionState(props);
      return normalize.element({
        id: select_dom.dom.getOptionId(state.context, value),
        role: "option",
        ...select_anatomy.parts.option.attrs,
        "data-label": label,
        "data-value": value,
        "data-valuetext": valueText ?? label,
        "aria-selected": optionState.isSelected,
        "data-selected": domQuery.dataAttr(optionState.isSelected),
        "data-focus": domQuery.dataAttr(optionState.isHighlighted),
        "data-disabled": domQuery.dataAttr(optionState.isDisabled),
        "aria-disabled": domQuery.ariaAttr(optionState.isDisabled)
      });
    },
    getOptionGroupLabelProps(props) {
      const { htmlFor } = props;
      return normalize.element({
        id: select_dom.dom.getOptionGroupId(state.context, htmlFor),
        role: "group",
        ...select_anatomy.parts.optionGroupLabel.attrs
      });
    },
    getOptionGroupProps(props) {
      const { id } = props;
      return normalize.element({
        ...select_anatomy.parts.optionGroup.attrs,
        "data-disabled": domQuery.dataAttr(disabled),
        id: select_dom.dom.getOptionGroupId(state.context, id),
        "aria-labelledby": select_dom.dom.getOptionGroupLabelId(state.context, id)
      });
    },
    hiddenSelectProps: normalize.select({
      ...select_anatomy.parts.hiddenSelect.attrs,
      name: state.context.name,
      form: state.context.form,
      disabled: !isInteractive,
      "aria-hidden": true,
      id: select_dom.dom.getHiddenSelectId(state.context),
      defaultValue: state.context.selectedOption?.value,
      style: visuallyHidden.visuallyHiddenStyle,
      tabIndex: -1,
      // Some browser extensions will focus the hidden select.
      // Let's forward the focus to the trigger.
      onFocus() {
        select_dom.dom.getTriggerElement(state.context)?.focus();
      },
      "aria-labelledby": select_dom.dom.getLabelId(state.context)
    }),
    contentProps: normalize.element({
      hidden: !isOpen,
      dir: state.context.dir,
      id: select_dom.dom.getContentId(state.context),
      role: "listbox",
      ...select_anatomy.parts.content.attrs,
      "aria-activedescendant": state.context.highlightedId || "",
      "aria-labelledby": select_dom.dom.getLabelId(state.context),
      tabIndex: 0,
      onPointerMove(event) {
        if (!isInteractive)
          return;
        const option = select_dom.dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled")) {
          send({ type: "POINTER_LEAVE" });
        } else {
          send({ type: "POINTER_MOVE", id: option.id, target: option });
        }
      },
      onPointerUp(event) {
        if (!isInteractive)
          return;
        const option = select_dom.dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "pointerup", id: option.id });
      },
      onPointerLeave() {
        send({ type: "POINTER_LEAVE" });
      },
      onClick(event) {
        if (!isInteractive)
          return;
        const option = select_dom.dom.getClosestOption(event.target);
        if (!option || option.hasAttribute("data-disabled"))
          return;
        send({ type: "OPTION_CLICK", src: "click", id: option.id });
      },
      onKeyDown(event) {
        if (!isInteractive || !domQuery.isSelfEvent(event))
          return;
        const keyMap = {
          ArrowUp() {
            send({ type: "ARROW_UP" });
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN" });
          },
          Home() {
            send({ type: "HOME" });
          },
          End() {
            send({ type: "END" });
          },
          Tab(event2) {
            if (event2.shiftKey)
              return;
            send({ type: "TAB" });
          },
          Enter() {
            send({ type: "TRIGGER_KEY" });
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          }
        };
        const exec = keyMap[domEvent.getEventKey(event)];
        if (exec) {
          exec(event);
          event.preventDefault();
          return;
        }
        if (domQuery.isEditableElement(event.target)) {
          return;
        }
        if (domQuery.getByTypeahead.isValidEvent(event)) {
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    })
  };
}

exports.connect = connect;
