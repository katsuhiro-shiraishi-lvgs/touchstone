import { createMachine, guards } from '@zag-js/core';
import { raf, nextTick } from '@zag-js/dom-query';
import { trackElementRect } from '@zag-js/element-rect';
import { getFocusables } from '@zag-js/tabbable';
import { compact } from '@zag-js/utils';
import { dom } from './tabs.dom.mjs';

const { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        focusedValue: null,
        previousValues: [],
        indicatorRect: {
          left: "0px",
          top: "0px",
          width: "0px",
          height: "0px"
        },
        canIndicatorTransition: false,
        isIndicatorRendered: false,
        loop: true,
        translations: {},
        ...ctx
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical"
      },
      created: ["setPrevSelectedTabs"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "setContentTabIndex"],
      exit: ["cleanupObserver"],
      watch: {
        focusedValue: "invokeOnFocus",
        value: [
          "enableIndicatorTransition",
          "invokeOnChange",
          "setPrevSelectedTabs",
          "syncIndicatorRect",
          "setContentTabIndex"
        ],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        }
      },
      states: {
        idle: {
          on: {
            TAB_FOCUS: [
              {
                guard: "selectOnFocus",
                target: "focused",
                actions: ["setFocusedValue", "setValue"]
              },
              {
                target: "focused",
                actions: "setFocusedValue"
              }
            ],
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: "focusPrevTab"
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: "focusNextTab"
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: "focusPrevTab"
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: "focusNextTab"
            },
            HOME: {
              actions: "focusFirstTab"
            },
            END: {
              actions: "focusLastTab"
            },
            ENTER: {
              guard: not("selectOnFocus"),
              actions: "setValue"
            },
            TAB_FOCUS: [
              {
                guard: "selectOnFocus",
                actions: ["setFocusedValue", "setValue"]
              },
              { actions: "setFocusedValue" }
            ],
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        isVertical: (ctx2) => ctx2.isVertical,
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        setFocusedValue(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        clearFocusedValue(ctx2) {
          ctx2.focusedValue = null;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        clearValue(ctx2) {
          ctx2.value = null;
        },
        focusFirstTab(ctx2) {
          raf(() => dom.getFirstEl(ctx2)?.focus());
        },
        focusLastTab(ctx2) {
          raf(() => dom.getLastEl(ctx2)?.focus());
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const next = dom.getNextEl(ctx2, ctx2.focusedValue);
          raf(() => next?.focus());
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const prev = dom.getPrevEl(ctx2, ctx2.focusedValue);
          raf(() => prev?.focus());
        },
        checkRenderedElements(ctx2) {
          ctx2.isIndicatorRendered = !!dom.getIndicatorEl(ctx2);
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        invokeOnFocus(ctx2) {
          ctx2.onFocus?.({ value: ctx2.focusedValue });
        },
        setPrevSelectedTabs(ctx2) {
          if (ctx2.value != null) {
            ctx2.previousValues = pushUnique(ctx2.previousValues, ctx2.value);
          }
        },
        // if tab panel contains focusable elements, remove the tabindex attribute
        setContentTabIndex(ctx2) {
          raf(() => {
            const panel = dom.getActiveContentEl(ctx2);
            if (!panel)
              return;
            const focusables = getFocusables(panel);
            if (focusables.length > 0) {
              panel.removeAttribute("tabindex");
            } else {
              panel.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        enableIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.isIndicatorRendered || !value)
            return;
          const tabEl = dom.getTriggerEl(ctx2, value);
          if (!tabEl)
            return;
          ctx2.indicatorRect = dom.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.canIndicatorTransition = false;
          });
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          const value = ctx2.value;
          if (!ctx2.isIndicatorRendered || !value)
            return;
          const tabEl = dom.getActiveTabEl(ctx2);
          if (!tabEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(tabEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect, ctx2.orientation);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        }
      }
    }
  );
}
function pushUnique(arr, value) {
  const newArr = Array.from(arr).slice();
  const index = newArr.indexOf(value);
  if (index > -1) {
    newArr.splice(index, 1);
  }
  newArr.push(value);
  return newArr;
}

export { machine };
