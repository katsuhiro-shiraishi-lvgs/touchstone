import { createMachine, guards } from '@zag-js/core';
import { contains, raf } from '@zag-js/dom-query';
import { trackInteractOutside } from '@zag-js/interact-outside';
import { compact } from '@zag-js/utils';
import { dom } from './editable.dom.mjs';

const { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.startWithEditView ? "edit" : "preview",
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["invokeOnChange", "syncInputValue"]
      },
      computed: {
        submitOnEnter: (ctx2) => ["both", "enter"].includes(ctx2.submitMode),
        submitOnBlur: (ctx2) => ["both", "blur"].includes(ctx2.submitMode),
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isPreviewFocusable: (ctx2) => ctx2.activationMode === "focus"
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            EDIT: {
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            DBLCLICK: {
              guard: "activateOnDblClick",
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            FOCUS: {
              guard: "activateOnFocus",
              target: "edit",
              actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
            }
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              guard: not("isAtMaxLength"),
              actions: "setValue"
            },
            BLUR: [
              {
                guard: "submitOnBlur",
                target: "preview",
                actions: ["restoreFocusIfNeeded", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["resetValueIfNeeded", "restoreFocusIfNeeded", "invokeOnCancel"]
              }
            ],
            CANCEL: {
              target: "preview",
              actions: ["restoreFocusIfNeeded", "resetValueIfNeeded", "invokeOnCancel"]
            },
            ENTER: {
              guard: "submitOnEnter",
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocusIfNeeded"]
            },
            SUBMIT: {
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocusIfNeeded"]
            }
          }
        }
      }
    },
    {
      guards: {
        submitOnBlur: (ctx2) => ctx2.submitOnBlur,
        submitOnEnter: (ctx2) => ctx2.submitOnEnter,
        isAtMaxLength: (ctx2) => ctx2.maxLength != null && ctx2.value.length === ctx2.maxLength,
        activateOnDblClick: (ctx2) => ctx2.activationMode === "dblclick",
        activateOnFocus: (ctx2) => ctx2.activationMode === "focus"
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom.getCancelTriggerEl(ctx2), dom.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (event.defaultPrevented)
                return;
              const { focusable } = event.detail;
              send({ type: "BLUR", src: "interact-outside", focusable });
            }
          });
        }
      },
      actions: {
        restoreFocusIfNeeded(ctx2, evt) {
          if (evt.focusable)
            return;
          raf(() => {
            const finalEl = ctx2.finalFocusEl?.() ?? dom.getEditTriggerEl(ctx2);
            finalEl?.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const input = dom.getInputEl(ctx2);
            if (!input)
              return;
            if (ctx2.selectOnFocus) {
              input.select();
            } else {
              input.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          ctx2.onCancel?.({ value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          ctx2.onSubmit?.({ value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          ctx2.onEdit?.();
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        syncInputValue(ctx2) {
          const input = dom.getInputEl(ctx2);
          if (!input)
            return;
          input.value = ctx2.value;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        resetValueIfNeeded(ctx2) {
          if (!ctx2.previousValue)
            return;
          ctx2.value = ctx2.previousValue;
        },
        blurInputIfNeeded(ctx2) {
          dom.getInputEl(ctx2)?.blur();
        }
      }
    }
  );
}

export { machine };
