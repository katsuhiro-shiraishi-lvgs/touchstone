import { flip, offset, shift, arrow, size, computePosition } from '@floating-ui/dom';
import { raf } from '@zag-js/dom-query';
import { callAll } from '@zag-js/utils';
import { autoUpdate } from './auto-update.mjs';
import { shiftArrow, transformOrigin } from './middleware.mjs';

const defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
function getPlacementImpl(reference, floating, opts = {}) {
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [];
  const boundary = typeof options.boundary === "function" ? options.boundary() : options.boundary;
  if (options.flip) {
    middleware.push(
      flip({
        boundary,
        padding: options.overflowPadding
      })
    );
  }
  if (options.gutter || options.offset) {
    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;
    const data = options.offset ? options.offset : { mainAxis: options.gutter };
    if (data?.mainAxis != null)
      data.mainAxis += arrowOffset;
    middleware.push(offset(data));
  }
  middleware.push(
    shift({
      boundary,
      crossAxis: options.overlap,
      padding: options.overflowPadding
    })
  );
  if (arrowEl) {
    middleware.push(
      arrow({ element: arrowEl, padding: 8 }),
      shiftArrow({ element: arrowEl })
    );
  }
  middleware.push(transformOrigin);
  middleware.push(
    size({
      padding: options.overflowPadding,
      apply({ rects, availableHeight, availableWidth }) {
        const referenceWidth = Math.round(rects.reference.width);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
        if (options.sameWidth) {
          Object.assign(floating.style, {
            width: `${referenceWidth}px`,
            minWidth: "unset"
          });
        }
        if (options.fitViewport) {
          Object.assign(floating.style, {
            maxWidth: `${availableWidth}px`,
            maxHeight: `${availableHeight}px`
          });
        }
      }
    })
  );
  function compute(config = {}) {
    if (!reference || !floating)
      return;
    const { placement, strategy, onComplete } = options;
    computePosition(reference, floating, {
      placement,
      middleware,
      strategy,
      ...config
    }).then((data) => {
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: data.strategy,
        top: "0px",
        left: "0px",
        transform: `translate3d(${x}px, ${y}px, 0)`
      });
      onComplete?.(data);
    });
  }
  compute();
  return callAll(
    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,
    options.onCleanup
  );
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...restOptions } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, restOptions));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

export { getBasePlacement, getPlacement };
