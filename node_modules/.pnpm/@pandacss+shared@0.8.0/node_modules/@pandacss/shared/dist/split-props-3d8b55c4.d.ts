declare const isString: (v: any) => v is string;
type AnyFunction = (...args: any[]) => any;
declare const isFunction: (v: any) => v is AnyFunction;
declare function isObject(value: any): value is Record<string, any>;

declare const astish: (val: string, tree?: any[]) => Record<string, any>;

type CreateCssContext = {
    hash?: boolean;
    /**
     * Partial properties from the Utility class
     */
    utility: {
        prefix: string;
        hasShorthand: boolean;
        resolveShorthand: (prop: string) => string;
        transform: (prop: string, value: any) => {
            className: string;
        };
    };
    /**
     * Partial properties from the Condition class
     */
    conditions?: {
        breakpoints: {
            keys: string[];
        };
        shift: (paths: string[]) => string[];
        finalize: (paths: string[]) => string[];
    };
};
declare function createCss(context: CreateCssContext): (styleObject?: Record<string, any>) => string;
type StyleObject = Record<string, any>;
declare function createMergeCss(context: CreateCssContext): {
    mergeCss: (...styles: StyleObject[]) => StyleObject;
    assignCss: (...styles: StyleObject[]) => any;
};

declare function compact<T extends Record<string, any>>(value: T): T;

declare const isBaseCondition: (v: string) => boolean;
declare function filterBaseConditions(c: string[]): string[];

declare function isImportant(value: string): boolean;
declare function withoutImportant(value: string): string;
declare function withoutSpace(str: string): string;

type Predicate<R = any> = (value: any, path: string[]) => R;
type MappedObject<T, K> = {
    [Prop in keyof T]: T[Prop] extends Array<any> ? MappedObject<T[Prop][number], K>[] : T[Prop] extends Record<string, unknown> ? MappedObject<T[Prop], K> : K;
};
type WalkObjectStopFn = (value: any, path: string[]) => boolean;
type WalkObjectOptions = {
    stop?: WalkObjectStopFn;
    getKey?(prop: string): string;
};
declare function walkObject<T, K>(target: T, predicate: Predicate<K>, options?: WalkObjectOptions): MappedObject<T, ReturnType<Predicate<K>>>;
declare function mapObject(obj: any, fn: (value: any) => any): any;

declare function toHash(value: string): string;

declare const hypenateProperty: (property: string) => string;

declare function mergeProps<T extends Record<string, unknown>>(...sources: T[]): T;

type Dict = Record<string, unknown>;
type PredicateFn = (key: string) => boolean;
type Key = PredicateFn | string[];
declare function splitProps(props: Dict, ...keys: Key[]): Dict[];

export { CreateCssContext as C, MappedObject as M, WalkObjectStopFn as W, isFunction as a, isObject as b, astish as c, createCss as d, createMergeCss as e, compact as f, isBaseCondition as g, filterBaseConditions as h, isString as i, isImportant as j, withoutSpace as k, hypenateProperty as l, mergeProps as m, WalkObjectOptions as n, walkObject as o, mapObject as p, splitProps as s, toHash as t, withoutImportant as w };
