'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const date = require('@internationalized/date');
const core = require('@zag-js/core');
const dateUtils = require('@zag-js/date-utils');
const dismissable = require('@zag-js/dismissable');
const domQuery = require('@zag-js/dom-query');
const liveRegion = require('@zag-js/live-region');
const textSelection = require('@zag-js/text-selection');
const utils = require('@zag-js/utils');
const datePicker_dom = require('./date-picker.dom.js');
const datePicker_utils = require('./date-picker.utils.js');

const { and, not } = core.guards;
const getInitialContext = (ctx) => {
  const locale = ctx.locale || "en-US";
  const timeZone = ctx.timeZone || "UTC";
  const selectionMode = ctx.selectionMode || "single";
  const numOfMonths = ctx.numOfMonths || 1;
  let value = datePicker_utils.sortDates(ctx.value || []);
  value = value.map((date) => dateUtils.constrainValue(date, ctx.min, ctx.max));
  let focusedValue = value.at(0) || ctx.focusedValue || dateUtils.getTodayDate(timeZone);
  focusedValue = dateUtils.constrainValue(focusedValue, ctx.min, ctx.max);
  const startValue = dateUtils.alignDate(focusedValue, "start", { months: numOfMonths }, locale);
  const inputValue = ctx.format?.(value) ?? datePicker_utils.formatValue({ locale, timeZone, selectionMode, value });
  return {
    locale,
    numOfMonths,
    focusedValue,
    startValue,
    timeZone,
    value,
    inputValue,
    selectionMode,
    view: "day",
    activeIndex: 0,
    valueText: "",
    hoveredValue: null,
    ...ctx
  };
};
function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "datepicker",
      initial: ctx.inline ? "open" : "idle",
      context: getInitialContext(ctx),
      computed: {
        isInteractive: (ctx2) => !ctx2.disabled && !ctx2.readOnly,
        visibleDuration: (ctx2) => ({ months: ctx2.numOfMonths }),
        endValue: (ctx2) => dateUtils.getEndDate(ctx2.startValue, ctx2.visibleDuration),
        visibleRange: (ctx2) => ({ start: ctx2.startValue, end: ctx2.endValue }),
        visibleRangeText(ctx2) {
          const formatter = new date.DateFormatter(ctx2.locale, { month: "long", year: "numeric", timeZone: ctx2.timeZone });
          const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));
          const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));
          const formatted = ctx2.selectionMode === "range" ? `${start} - ${end}` : start;
          return { start, end, formatted };
        },
        isPrevVisibleRangeValid: (ctx2) => !dateUtils.isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),
        isNextVisibleRangeValid: (ctx2) => !dateUtils.isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max)
      },
      activities: ["setupLiveRegion"],
      watch: {
        locale: ["setStartValue", "setInputValue"],
        focusedValue: [
          "adjustStartDate",
          "syncMonthSelectElement",
          "syncYearSelectElement",
          "focusActiveCellIfNeeded",
          "setHoveredValueIfKeyboard",
          "invokeOnFocusChange"
        ],
        value: ["setValueText", "announceValueText", "setInputValue"],
        inputValue: ["syncInputElement"],
        view: ["focusActiveCell", "invokeOnViewChange"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setSelectedDate", "setFocusedDate"]
        },
        "VIEW.SET": {
          actions: ["setView"]
        },
        "FOCUS.SET": {
          actions: ["setFocusedDate"]
        },
        "VALUE.CLEAR": {
          target: "focused",
          actions: ["clearSelectedDate", "clearFocusedDate", "focusInputElement"]
        },
        "GOTO.NEXT": [
          { guard: "isYearView", actions: ["focusNextDecade", "announceVisibleRange"] },
          { guard: "isMonthView", actions: ["focusNextYear", "announceVisibleRange"] },
          { actions: ["focusNextPage"] }
        ],
        "GOTO.PREV": [
          { guard: "isYearView", actions: ["focusPreviousDecade", "announceVisibleRange"] },
          { guard: "isMonthView", actions: ["focusPreviousYear", "announceVisibleRange"] },
          { actions: ["focusPreviousPage"] }
        ]
      },
      states: {
        idle: {
          tags: "closed",
          on: {
            "INPUT.FOCUS": {
              target: "focused"
            },
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["focusFirstSelectedDate"]
            }
          }
        },
        focused: {
          tags: "closed",
          on: {
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["setViewToDay", "focusFirstSelectedDate"]
            },
            "INPUT.CHANGE": {
              actions: ["focusParsedDate"]
            },
            "INPUT.ENTER": {
              actions: ["focusParsedDate", "selectFocusedDate"]
            },
            "INPUT.BLUR": {
              target: "idle"
            },
            "CELL.FOCUS": {
              target: "open",
              actions: ["setView"]
            }
          }
        },
        open: {
          tags: "open",
          activities: ["trackDismissableElement"],
          entry: ctx.inline ? void 0 : ["focusActiveCell"],
          exit: ["clearHoveredDate", "resetView"],
          on: {
            "INPUT.CHANGE": {
              actions: ["focusParsedDate"]
            },
            "CELL.CLICK": [
              {
                guard: "isMonthView",
                actions: ["setFocusedMonth", "setViewToDay"]
              },
              {
                guard: "isYearView",
                actions: ["setFocusedYear", "setViewToMonth"]
              },
              {
                guard: and("isRangePicker", "hasSelectedRange"),
                actions: ["setStartIndex", "clearSelectedDate", "setFocusedDate", "setSelectedDate", "setEndIndex"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: and("isRangePicker", "isSelectingEndDate", "isInline"),
                actions: ["setFocusedDate", "setSelectedDate", "setStartIndex", "clearHoveredDate"]
              },
              {
                target: "focused",
                guard: and("isRangePicker", "isSelectingEndDate"),
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setStartIndex",
                  "clearHoveredDate",
                  "focusInputElement"
                ]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setFocusedDate", "setSelectedDate", "setEndIndex"]
              },
              {
                guard: "isMultiPicker",
                actions: ["setFocusedDate", "toggleSelectedDate"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: "isInline",
                actions: ["setFocusedDate", "setSelectedDate"]
              },
              {
                target: "focused",
                actions: ["setFocusedDate", "setSelectedDate", "focusInputElement"]
              }
              // ===
            ],
            "CELL.POINTER_MOVE": {
              guard: and("isRangePicker", "isSelectingEndDate"),
              actions: ["setHoveredDate", "setFocusedDate"]
            },
            "GRID.POINTER_LEAVE": {
              guard: "isRangePicker",
              actions: ["clearHoveredDate"]
            },
            "GRID.POINTER_DOWN": {
              guard: not("isInline"),
              actions: ["disableTextSelection"]
            },
            "GRID.POINTER_UP": {
              guard: not("isInline"),
              actions: ["enableTextSelection"]
            },
            "GRID.ESCAPE": {
              guard: not("isInline"),
              target: "focused",
              actions: ["setViewToDay", "focusFirstSelectedDate", "focusTriggerElement"]
            },
            "GRID.ENTER": [
              {
                guard: "isMonthView",
                actions: "setViewToDay"
              },
              {
                guard: "isYearView",
                actions: "setViewToMonth"
              },
              {
                guard: and("isRangePicker", "hasSelectedRange"),
                actions: ["setStartIndex", "clearSelectedDate", "setSelectedDate", "setEndIndex"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: and("isRangePicker", "isSelectingEndDate", "isInline"),
                actions: ["setSelectedDate", "setStartIndex"]
              },
              {
                target: "focused",
                guard: and("isRangePicker", "isSelectingEndDate"),
                actions: ["setSelectedDate", "setStartIndex", "focusInputElement"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setSelectedDate", "setEndIndex", "focusNextDay"]
              },
              {
                guard: "isMultiPicker",
                actions: ["toggleSelectedDate"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: "isInline",
                actions: ["selectFocusedDate"]
              },
              {
                target: "focused",
                actions: ["selectFocusedDate", "focusInputElement"]
              }
              // ===
            ],
            "GRID.ARROW_RIGHT": [
              { guard: "isMonthView", actions: "focusNextMonth" },
              { guard: "isYearView", actions: "focusNextYear" },
              { actions: ["focusNextDay", "setHoveredDate"] }
            ],
            "GRID.ARROW_LEFT": [
              { guard: "isMonthView", actions: "focusPreviousMonth" },
              { guard: "isYearView", actions: "focusPreviousYear" },
              { actions: ["focusPreviousDay"] }
            ],
            "GRID.ARROW_UP": [
              { guard: "isMonthView", actions: "focusPreviousMonthColumn" },
              { guard: "isYearView", actions: "focusPreviousYearColumn" },
              { actions: ["focusPreviousWeek"] }
            ],
            "GRID.ARROW_DOWN": [
              { guard: "isMonthView", actions: "focusNextMonthColumn" },
              { guard: "isYearView", actions: "focusNextYearColumn" },
              { actions: ["focusNextWeek"] }
            ],
            "GRID.PAGE_UP": {
              actions: ["focusPreviousSection"]
            },
            "GRID.PAGE_DOWN": {
              actions: ["focusNextSection"]
            },
            "GRID.HOME": [
              { guard: "isMonthView", actions: ["focusFirstMonth"] },
              { guard: "isYearView", actions: ["focusFirstYear"] },
              { actions: ["focusSectionStart"] }
            ],
            "GRID.END": [
              { guard: "isMonthView", actions: ["focusLastMonth"] },
              { guard: "isYearView", actions: ["focusLastYear"] },
              { actions: ["focusSectionEnd"] }
            ],
            "TRIGGER.CLICK": {
              target: "focused"
            },
            "VIEW.CHANGE": [
              {
                guard: "isDayView",
                actions: ["setViewToMonth"]
              },
              {
                guard: "isMonthView",
                actions: ["setViewToYear"]
              }
            ],
            DISMISS: [
              {
                guard: "isTargetFocusable",
                target: "idle",
                actions: ["setStartIndex"]
              },
              {
                target: "focused",
                actions: ["focusTriggerElement", "setStartIndex"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isDayView: (ctx2, evt) => (evt.view || ctx2.view) === "day",
        isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === "month",
        isYearView: (ctx2, evt) => (evt.view || ctx2.view) === "year",
        isRangePicker: (ctx2) => ctx2.selectionMode === "range",
        hasSelectedRange: (ctx2) => ctx2.value.length === 2,
        isMultiPicker: (ctx2) => ctx2.selectionMode === "multiple",
        isTargetFocusable: (_ctx, evt) => evt.focusable,
        isSelectingEndDate: (ctx2) => ctx2.activeIndex === 1,
        isInline: (ctx2) => !!ctx2.inline
      },
      activities: {
        setupLiveRegion(ctx2) {
          const doc = datePicker_dom.dom.getDoc(ctx2);
          ctx2.announcer = liveRegion.createLiveRegion({ level: "assertive", document: doc });
          return () => ctx2.announcer?.destroy?.();
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          if (ctx2.inline)
            return;
          let focusable = false;
          return dismissable.trackDismissableElement(datePicker_dom.dom.getContentEl(ctx2), {
            exclude: [datePicker_dom.dom.getInputEl(ctx2), datePicker_dom.dom.getTriggerEl(ctx2), datePicker_dom.dom.getClearTriggerEl(ctx2)],
            onInteractOutside(event) {
              focusable = event.detail.focusable;
            },
            onDismiss() {
              send({ type: "DISMISS", src: "dismissable", focusable });
            },
            onEscapeKeyDown(event) {
              event.preventDefault();
              send({ type: "GRID.ESCAPE", src: "dismissable" });
            }
          });
        }
      },
      actions: {
        setViewToDay(ctx2) {
          ctx2.view = "day";
        },
        setViewToMonth(ctx2) {
          ctx2.view = "month";
        },
        setViewToYear(ctx2) {
          ctx2.view = "year";
        },
        setView(ctx2, evt) {
          ctx2.view = evt.cell;
        },
        setValueText(ctx2) {
          if (!ctx2.value.length)
            return;
          ctx2.valueText = ctx2.value.map((date) => dateUtils.formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone)).join(", ");
        },
        announceValueText(ctx2) {
          ctx2.announcer?.announce(ctx2.valueText, 3e3);
        },
        announceVisibleRange(ctx2) {
          const { formatted } = ctx2.visibleRangeText;
          ctx2.announcer?.announce(formatted);
        },
        disableTextSelection(ctx2) {
          textSelection.disableTextSelection({ target: datePicker_dom.dom.getContentEl(ctx2), doc: datePicker_dom.dom.getDoc(ctx2) });
        },
        enableTextSelection(ctx2) {
          textSelection.restoreTextSelection({ doc: datePicker_dom.dom.getDoc(ctx2), target: datePicker_dom.dom.getContentEl(ctx2) });
        },
        focusFirstSelectedDate(ctx2) {
          if (!ctx2.value.length)
            return;
          ctx2.focusedValue = ctx2.value[0];
        },
        setInputValue(ctx2) {
          const input = datePicker_dom.dom.getInputEl(ctx2);
          if (!input)
            return;
          ctx2.inputValue = ctx2.format?.(ctx2.value) ?? datePicker_utils.formatValue(ctx2);
        },
        syncInputElement(ctx2) {
          const input = datePicker_dom.dom.getInputEl(ctx2);
          if (!input || input.value === ctx2.inputValue)
            return;
          domQuery.raf(() => {
            input.value = ctx2.inputValue;
            input.setSelectionRange(input.value.length, input.value.length);
          });
        },
        setFocusedDate(ctx2, evt) {
          const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;
          ctx2.focusedValue = dateUtils.constrainValue(value, ctx2.min, ctx2.max);
        },
        setFocusedMonth(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: evt.value });
        },
        focusNextMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: 1 });
        },
        focusPreviousMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ months: 1 });
        },
        setFocusedYear(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.set({ year: evt.value });
        },
        setSelectedDate(ctx2, evt) {
          const nextValue = [...ctx2.value];
          nextValue[ctx2.activeIndex] = evt.value ?? ctx2.focusedValue;
          ctx2.value = datePicker_utils.adjustStartAndEndDate(nextValue);
        },
        toggleSelectedDate(ctx2, evt) {
          const currentValue = evt.value ?? ctx2.focusedValue;
          const index = ctx2.value.findIndex((date) => dateUtils.isDateEqual(date, currentValue));
          if (index === -1) {
            const nextValues = [...ctx2.value, currentValue];
            ctx2.value = datePicker_utils.sortDates(nextValues);
          } else {
            const nextValues = [...ctx2.value];
            nextValues.splice(index, 1);
            ctx2.value = datePicker_utils.sortDates(nextValues);
          }
        },
        setHoveredDate(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        clearHoveredDate(ctx2) {
          ctx2.hoveredValue = null;
        },
        selectFocusedDate(ctx2) {
          const nextValue = [...ctx2.value];
          nextValue[ctx2.activeIndex] = ctx2.focusedValue.copy();
          ctx2.value = datePicker_utils.adjustStartAndEndDate(nextValue);
        },
        adjustStartDate(ctx2) {
          const adjust = dateUtils.getAdjustedDateFn(ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);
          const { startDate, focusedDate } = adjust({ focusedDate: ctx2.focusedValue, startDate: ctx2.startValue });
          ctx2.startValue = startDate;
          ctx2.focusedValue = focusedDate;
        },
        setPreviousDate(ctx2) {
          ctx2.focusedValue = dateUtils.getPreviousDay(ctx2.focusedValue);
        },
        setNextDate(ctx2) {
          ctx2.focusedValue = dateUtils.getNextDay(ctx2.focusedValue);
        },
        focusPreviousDay(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ days: 1 });
        },
        focusNextDay(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ days: 1 });
        },
        focusPreviousWeek(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ weeks: 1 });
        },
        focusNextWeek(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ weeks: 1 });
        },
        focusNextPage(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: 1 });
        },
        focusPreviousPage(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract(ctx2.visibleDuration);
        },
        focusSectionStart(ctx2) {
          ctx2.focusedValue = ctx2.startValue.copy();
        },
        focusSectionEnd(ctx2) {
          ctx2.focusedValue = ctx2.endValue.copy();
        },
        focusNextSection(ctx2, evt) {
          const section = dateUtils.getNextSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!section)
            return;
          ctx2.focusedValue = section.focusedDate;
        },
        focusPreviousSection(ctx2, evt) {
          const section = dateUtils.getPreviousSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!section)
            return;
          ctx2.focusedValue = section.focusedDate;
        },
        focusNextYear(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: 1 });
        },
        focusPreviousYear(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: 1 });
        },
        focusNextDecade(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: 10 });
        },
        focusPreviousDecade(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: 10 });
        },
        clearSelectedDate(ctx2) {
          ctx2.value = [];
        },
        clearFocusedDate(ctx2) {
          ctx2.focusedValue = dateUtils.getTodayDate(ctx2.timeZone);
        },
        focusPreviousMonthColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ months: evt.columns });
        },
        focusNextMonthColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: evt.columns });
        },
        focusPreviousYearColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: evt.columns });
        },
        focusNextYearColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: evt.columns });
        },
        focusFirstMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: 0 });
        },
        focusLastMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: 12 });
        },
        focusFirstYear(ctx2) {
          const range = dateUtils.getDecadeRange(ctx2.focusedValue.year);
          ctx2.focusedValue = ctx2.focusedValue.set({ year: range.at(0) });
        },
        focusLastYear(ctx2) {
          const range = dateUtils.getDecadeRange(ctx2.focusedValue.year);
          ctx2.focusedValue = ctx2.focusedValue.set({ year: range.at(-1) });
        },
        setEndIndex(ctx2) {
          ctx2.activeIndex = 1;
        },
        setStartIndex(ctx2) {
          ctx2.activeIndex = 0;
        },
        focusActiveCell(ctx2) {
          domQuery.raf(() => {
            datePicker_dom.dom.getFocusedCell(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusActiveCellIfNeeded(ctx2, evt) {
          if (!evt.focus)
            return;
          domQuery.raf(() => {
            datePicker_dom.dom.getFocusedCell(ctx2)?.focus({ preventScroll: true });
          });
        },
        setHoveredValueIfKeyboard(ctx2, evt) {
          if (!evt.type.startsWith("GRID.ARROW") || ctx2.selectionMode !== "range" || ctx2.activeIndex === 0)
            return;
          ctx2.hoveredValue = ctx2.focusedValue.copy();
        },
        focusTriggerElement(ctx2) {
          domQuery.raf(() => {
            datePicker_dom.dom.getTriggerEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusInputElement(ctx2) {
          domQuery.raf(() => {
            datePicker_dom.dom.getInputEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        syncMonthSelectElement(ctx2) {
          const month = datePicker_dom.dom.getMonthSelectEl(ctx2);
          if (!month)
            return;
          month.value = ctx2.focusedValue.month.toString();
        },
        syncYearSelectElement(ctx2) {
          const year = datePicker_dom.dom.getYearSelectEl(ctx2);
          if (!year)
            return;
          year.value = ctx2.focusedValue.year.toString();
        },
        invokeOnFocusChange(ctx2) {
          ctx2.onFocusChange?.({ focusedValue: ctx2.focusedValue, value: ctx2.value, view: ctx2.view });
        },
        invokeOnViewChange(ctx2) {
          ctx2.onViewChange?.({ view: ctx2.view });
        },
        focusParsedDate(ctx2, evt) {
          ctx2.inputValue = evt.value;
          const date = dateUtils.parseDateString(ctx2.inputValue, ctx2.locale, ctx2.timeZone);
          if (!date)
            return;
          ctx2.focusedValue = date;
        },
        resetView(ctx2, _evt, { initialContext }) {
          ctx2.view = initialContext.view;
        },
        setStartValue(ctx2) {
          const startValue = dateUtils.alignDate(ctx2.focusedValue, "start", { months: ctx2.numOfMonths }, ctx2.locale);
          ctx2.startValue = startValue;
        }
      },
      compareFns: {
        startValue: (a, b) => a.toString() === b.toString(),
        focusedValue: (a, b) => a.toString() === b.toString(),
        value: (a, b) => a?.toString() === b?.toString()
      }
    }
  );
}

exports.machine = machine;
