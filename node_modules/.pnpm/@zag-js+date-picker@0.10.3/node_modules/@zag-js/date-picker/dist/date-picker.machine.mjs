import { DateFormatter } from '@internationalized/date';
import { createMachine, guards } from '@zag-js/core';
import { getEndDate, isPreviousVisibleRangeInvalid, isNextVisibleRangeInvalid, formatSelectedDate, constrainValue, isDateEqual, getAdjustedDateFn, getPreviousDay, getNextDay, getNextSection, getPreviousSection, getTodayDate, getDecadeRange, parseDateString, alignDate } from '@zag-js/date-utils';
import { trackDismissableElement } from '@zag-js/dismissable';
import { raf } from '@zag-js/dom-query';
import { createLiveRegion } from '@zag-js/live-region';
import { disableTextSelection, restoreTextSelection } from '@zag-js/text-selection';
import { compact } from '@zag-js/utils';
import { dom } from './date-picker.dom.mjs';
import { formatValue, adjustStartAndEndDate, sortDates } from './date-picker.utils.mjs';

const { and, not } = guards;
const getInitialContext = (ctx) => {
  const locale = ctx.locale || "en-US";
  const timeZone = ctx.timeZone || "UTC";
  const selectionMode = ctx.selectionMode || "single";
  const numOfMonths = ctx.numOfMonths || 1;
  let value = sortDates(ctx.value || []);
  value = value.map((date) => constrainValue(date, ctx.min, ctx.max));
  let focusedValue = value.at(0) || ctx.focusedValue || getTodayDate(timeZone);
  focusedValue = constrainValue(focusedValue, ctx.min, ctx.max);
  const startValue = alignDate(focusedValue, "start", { months: numOfMonths }, locale);
  const inputValue = ctx.format?.(value) ?? formatValue({ locale, timeZone, selectionMode, value });
  return {
    locale,
    numOfMonths,
    focusedValue,
    startValue,
    timeZone,
    value,
    inputValue,
    selectionMode,
    view: "day",
    activeIndex: 0,
    valueText: "",
    hoveredValue: null,
    ...ctx
  };
};
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "datepicker",
      initial: ctx.inline ? "open" : "idle",
      context: getInitialContext(ctx),
      computed: {
        isInteractive: (ctx2) => !ctx2.disabled && !ctx2.readOnly,
        visibleDuration: (ctx2) => ({ months: ctx2.numOfMonths }),
        endValue: (ctx2) => getEndDate(ctx2.startValue, ctx2.visibleDuration),
        visibleRange: (ctx2) => ({ start: ctx2.startValue, end: ctx2.endValue }),
        visibleRangeText(ctx2) {
          const formatter = new DateFormatter(ctx2.locale, { month: "long", year: "numeric", timeZone: ctx2.timeZone });
          const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));
          const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));
          const formatted = ctx2.selectionMode === "range" ? `${start} - ${end}` : start;
          return { start, end, formatted };
        },
        isPrevVisibleRangeValid: (ctx2) => !isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),
        isNextVisibleRangeValid: (ctx2) => !isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max)
      },
      activities: ["setupLiveRegion"],
      watch: {
        locale: ["setStartValue", "setInputValue"],
        focusedValue: [
          "adjustStartDate",
          "syncMonthSelectElement",
          "syncYearSelectElement",
          "focusActiveCellIfNeeded",
          "setHoveredValueIfKeyboard",
          "invokeOnFocusChange"
        ],
        value: ["setValueText", "announceValueText", "setInputValue"],
        inputValue: ["syncInputElement"],
        view: ["focusActiveCell", "invokeOnViewChange"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setSelectedDate", "setFocusedDate"]
        },
        "VIEW.SET": {
          actions: ["setView"]
        },
        "FOCUS.SET": {
          actions: ["setFocusedDate"]
        },
        "VALUE.CLEAR": {
          target: "focused",
          actions: ["clearSelectedDate", "clearFocusedDate", "focusInputElement"]
        },
        "GOTO.NEXT": [
          { guard: "isYearView", actions: ["focusNextDecade", "announceVisibleRange"] },
          { guard: "isMonthView", actions: ["focusNextYear", "announceVisibleRange"] },
          { actions: ["focusNextPage"] }
        ],
        "GOTO.PREV": [
          { guard: "isYearView", actions: ["focusPreviousDecade", "announceVisibleRange"] },
          { guard: "isMonthView", actions: ["focusPreviousYear", "announceVisibleRange"] },
          { actions: ["focusPreviousPage"] }
        ]
      },
      states: {
        idle: {
          tags: "closed",
          on: {
            "INPUT.FOCUS": {
              target: "focused"
            },
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["focusFirstSelectedDate"]
            }
          }
        },
        focused: {
          tags: "closed",
          on: {
            "TRIGGER.CLICK": {
              target: "open",
              actions: ["setViewToDay", "focusFirstSelectedDate"]
            },
            "INPUT.CHANGE": {
              actions: ["focusParsedDate"]
            },
            "INPUT.ENTER": {
              actions: ["focusParsedDate", "selectFocusedDate"]
            },
            "INPUT.BLUR": {
              target: "idle"
            },
            "CELL.FOCUS": {
              target: "open",
              actions: ["setView"]
            }
          }
        },
        open: {
          tags: "open",
          activities: ["trackDismissableElement"],
          entry: ctx.inline ? void 0 : ["focusActiveCell"],
          exit: ["clearHoveredDate", "resetView"],
          on: {
            "INPUT.CHANGE": {
              actions: ["focusParsedDate"]
            },
            "CELL.CLICK": [
              {
                guard: "isMonthView",
                actions: ["setFocusedMonth", "setViewToDay"]
              },
              {
                guard: "isYearView",
                actions: ["setFocusedYear", "setViewToMonth"]
              },
              {
                guard: and("isRangePicker", "hasSelectedRange"),
                actions: ["setStartIndex", "clearSelectedDate", "setFocusedDate", "setSelectedDate", "setEndIndex"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: and("isRangePicker", "isSelectingEndDate", "isInline"),
                actions: ["setFocusedDate", "setSelectedDate", "setStartIndex", "clearHoveredDate"]
              },
              {
                target: "focused",
                guard: and("isRangePicker", "isSelectingEndDate"),
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setStartIndex",
                  "clearHoveredDate",
                  "focusInputElement"
                ]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setFocusedDate", "setSelectedDate", "setEndIndex"]
              },
              {
                guard: "isMultiPicker",
                actions: ["setFocusedDate", "toggleSelectedDate"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: "isInline",
                actions: ["setFocusedDate", "setSelectedDate"]
              },
              {
                target: "focused",
                actions: ["setFocusedDate", "setSelectedDate", "focusInputElement"]
              }
              // ===
            ],
            "CELL.POINTER_MOVE": {
              guard: and("isRangePicker", "isSelectingEndDate"),
              actions: ["setHoveredDate", "setFocusedDate"]
            },
            "GRID.POINTER_LEAVE": {
              guard: "isRangePicker",
              actions: ["clearHoveredDate"]
            },
            "GRID.POINTER_DOWN": {
              guard: not("isInline"),
              actions: ["disableTextSelection"]
            },
            "GRID.POINTER_UP": {
              guard: not("isInline"),
              actions: ["enableTextSelection"]
            },
            "GRID.ESCAPE": {
              guard: not("isInline"),
              target: "focused",
              actions: ["setViewToDay", "focusFirstSelectedDate", "focusTriggerElement"]
            },
            "GRID.ENTER": [
              {
                guard: "isMonthView",
                actions: "setViewToDay"
              },
              {
                guard: "isYearView",
                actions: "setViewToMonth"
              },
              {
                guard: and("isRangePicker", "hasSelectedRange"),
                actions: ["setStartIndex", "clearSelectedDate", "setSelectedDate", "setEndIndex"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: and("isRangePicker", "isSelectingEndDate", "isInline"),
                actions: ["setSelectedDate", "setStartIndex"]
              },
              {
                target: "focused",
                guard: and("isRangePicker", "isSelectingEndDate"),
                actions: ["setSelectedDate", "setStartIndex", "focusInputElement"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setSelectedDate", "setEndIndex", "focusNextDay"]
              },
              {
                guard: "isMultiPicker",
                actions: ["toggleSelectedDate"]
              },
              // === Grouped transitions (based on isInline) ===
              {
                guard: "isInline",
                actions: ["selectFocusedDate"]
              },
              {
                target: "focused",
                actions: ["selectFocusedDate", "focusInputElement"]
              }
              // ===
            ],
            "GRID.ARROW_RIGHT": [
              { guard: "isMonthView", actions: "focusNextMonth" },
              { guard: "isYearView", actions: "focusNextYear" },
              { actions: ["focusNextDay", "setHoveredDate"] }
            ],
            "GRID.ARROW_LEFT": [
              { guard: "isMonthView", actions: "focusPreviousMonth" },
              { guard: "isYearView", actions: "focusPreviousYear" },
              { actions: ["focusPreviousDay"] }
            ],
            "GRID.ARROW_UP": [
              { guard: "isMonthView", actions: "focusPreviousMonthColumn" },
              { guard: "isYearView", actions: "focusPreviousYearColumn" },
              { actions: ["focusPreviousWeek"] }
            ],
            "GRID.ARROW_DOWN": [
              { guard: "isMonthView", actions: "focusNextMonthColumn" },
              { guard: "isYearView", actions: "focusNextYearColumn" },
              { actions: ["focusNextWeek"] }
            ],
            "GRID.PAGE_UP": {
              actions: ["focusPreviousSection"]
            },
            "GRID.PAGE_DOWN": {
              actions: ["focusNextSection"]
            },
            "GRID.HOME": [
              { guard: "isMonthView", actions: ["focusFirstMonth"] },
              { guard: "isYearView", actions: ["focusFirstYear"] },
              { actions: ["focusSectionStart"] }
            ],
            "GRID.END": [
              { guard: "isMonthView", actions: ["focusLastMonth"] },
              { guard: "isYearView", actions: ["focusLastYear"] },
              { actions: ["focusSectionEnd"] }
            ],
            "TRIGGER.CLICK": {
              target: "focused"
            },
            "VIEW.CHANGE": [
              {
                guard: "isDayView",
                actions: ["setViewToMonth"]
              },
              {
                guard: "isMonthView",
                actions: ["setViewToYear"]
              }
            ],
            DISMISS: [
              {
                guard: "isTargetFocusable",
                target: "idle",
                actions: ["setStartIndex"]
              },
              {
                target: "focused",
                actions: ["focusTriggerElement", "setStartIndex"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isDayView: (ctx2, evt) => (evt.view || ctx2.view) === "day",
        isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === "month",
        isYearView: (ctx2, evt) => (evt.view || ctx2.view) === "year",
        isRangePicker: (ctx2) => ctx2.selectionMode === "range",
        hasSelectedRange: (ctx2) => ctx2.value.length === 2,
        isMultiPicker: (ctx2) => ctx2.selectionMode === "multiple",
        isTargetFocusable: (_ctx, evt) => evt.focusable,
        isSelectingEndDate: (ctx2) => ctx2.activeIndex === 1,
        isInline: (ctx2) => !!ctx2.inline
      },
      activities: {
        setupLiveRegion(ctx2) {
          const doc = dom.getDoc(ctx2);
          ctx2.announcer = createLiveRegion({ level: "assertive", document: doc });
          return () => ctx2.announcer?.destroy?.();
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          if (ctx2.inline)
            return;
          let focusable = false;
          return trackDismissableElement(dom.getContentEl(ctx2), {
            exclude: [dom.getInputEl(ctx2), dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],
            onInteractOutside(event) {
              focusable = event.detail.focusable;
            },
            onDismiss() {
              send({ type: "DISMISS", src: "dismissable", focusable });
            },
            onEscapeKeyDown(event) {
              event.preventDefault();
              send({ type: "GRID.ESCAPE", src: "dismissable" });
            }
          });
        }
      },
      actions: {
        setViewToDay(ctx2) {
          ctx2.view = "day";
        },
        setViewToMonth(ctx2) {
          ctx2.view = "month";
        },
        setViewToYear(ctx2) {
          ctx2.view = "year";
        },
        setView(ctx2, evt) {
          ctx2.view = evt.cell;
        },
        setValueText(ctx2) {
          if (!ctx2.value.length)
            return;
          ctx2.valueText = ctx2.value.map((date) => formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone)).join(", ");
        },
        announceValueText(ctx2) {
          ctx2.announcer?.announce(ctx2.valueText, 3e3);
        },
        announceVisibleRange(ctx2) {
          const { formatted } = ctx2.visibleRangeText;
          ctx2.announcer?.announce(formatted);
        },
        disableTextSelection(ctx2) {
          disableTextSelection({ target: dom.getContentEl(ctx2), doc: dom.getDoc(ctx2) });
        },
        enableTextSelection(ctx2) {
          restoreTextSelection({ doc: dom.getDoc(ctx2), target: dom.getContentEl(ctx2) });
        },
        focusFirstSelectedDate(ctx2) {
          if (!ctx2.value.length)
            return;
          ctx2.focusedValue = ctx2.value[0];
        },
        setInputValue(ctx2) {
          const input = dom.getInputEl(ctx2);
          if (!input)
            return;
          ctx2.inputValue = ctx2.format?.(ctx2.value) ?? formatValue(ctx2);
        },
        syncInputElement(ctx2) {
          const input = dom.getInputEl(ctx2);
          if (!input || input.value === ctx2.inputValue)
            return;
          raf(() => {
            input.value = ctx2.inputValue;
            input.setSelectionRange(input.value.length, input.value.length);
          });
        },
        setFocusedDate(ctx2, evt) {
          const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;
          ctx2.focusedValue = constrainValue(value, ctx2.min, ctx2.max);
        },
        setFocusedMonth(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: evt.value });
        },
        focusNextMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: 1 });
        },
        focusPreviousMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ months: 1 });
        },
        setFocusedYear(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.set({ year: evt.value });
        },
        setSelectedDate(ctx2, evt) {
          const nextValue = [...ctx2.value];
          nextValue[ctx2.activeIndex] = evt.value ?? ctx2.focusedValue;
          ctx2.value = adjustStartAndEndDate(nextValue);
        },
        toggleSelectedDate(ctx2, evt) {
          const currentValue = evt.value ?? ctx2.focusedValue;
          const index = ctx2.value.findIndex((date) => isDateEqual(date, currentValue));
          if (index === -1) {
            const nextValues = [...ctx2.value, currentValue];
            ctx2.value = sortDates(nextValues);
          } else {
            const nextValues = [...ctx2.value];
            nextValues.splice(index, 1);
            ctx2.value = sortDates(nextValues);
          }
        },
        setHoveredDate(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        clearHoveredDate(ctx2) {
          ctx2.hoveredValue = null;
        },
        selectFocusedDate(ctx2) {
          const nextValue = [...ctx2.value];
          nextValue[ctx2.activeIndex] = ctx2.focusedValue.copy();
          ctx2.value = adjustStartAndEndDate(nextValue);
        },
        adjustStartDate(ctx2) {
          const adjust = getAdjustedDateFn(ctx2.visibleDuration, ctx2.locale, ctx2.min, ctx2.max);
          const { startDate, focusedDate } = adjust({ focusedDate: ctx2.focusedValue, startDate: ctx2.startValue });
          ctx2.startValue = startDate;
          ctx2.focusedValue = focusedDate;
        },
        setPreviousDate(ctx2) {
          ctx2.focusedValue = getPreviousDay(ctx2.focusedValue);
        },
        setNextDate(ctx2) {
          ctx2.focusedValue = getNextDay(ctx2.focusedValue);
        },
        focusPreviousDay(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ days: 1 });
        },
        focusNextDay(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ days: 1 });
        },
        focusPreviousWeek(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ weeks: 1 });
        },
        focusNextWeek(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ weeks: 1 });
        },
        focusNextPage(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: 1 });
        },
        focusPreviousPage(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract(ctx2.visibleDuration);
        },
        focusSectionStart(ctx2) {
          ctx2.focusedValue = ctx2.startValue.copy();
        },
        focusSectionEnd(ctx2) {
          ctx2.focusedValue = ctx2.endValue.copy();
        },
        focusNextSection(ctx2, evt) {
          const section = getNextSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!section)
            return;
          ctx2.focusedValue = section.focusedDate;
        },
        focusPreviousSection(ctx2, evt) {
          const section = getPreviousSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!section)
            return;
          ctx2.focusedValue = section.focusedDate;
        },
        focusNextYear(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: 1 });
        },
        focusPreviousYear(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: 1 });
        },
        focusNextDecade(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: 10 });
        },
        focusPreviousDecade(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: 10 });
        },
        clearSelectedDate(ctx2) {
          ctx2.value = [];
        },
        clearFocusedDate(ctx2) {
          ctx2.focusedValue = getTodayDate(ctx2.timeZone);
        },
        focusPreviousMonthColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ months: evt.columns });
        },
        focusNextMonthColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.add({ months: evt.columns });
        },
        focusPreviousYearColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.subtract({ years: evt.columns });
        },
        focusNextYearColumn(ctx2, evt) {
          ctx2.focusedValue = ctx2.focusedValue.add({ years: evt.columns });
        },
        focusFirstMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: 0 });
        },
        focusLastMonth(ctx2) {
          ctx2.focusedValue = ctx2.focusedValue.set({ month: 12 });
        },
        focusFirstYear(ctx2) {
          const range = getDecadeRange(ctx2.focusedValue.year);
          ctx2.focusedValue = ctx2.focusedValue.set({ year: range.at(0) });
        },
        focusLastYear(ctx2) {
          const range = getDecadeRange(ctx2.focusedValue.year);
          ctx2.focusedValue = ctx2.focusedValue.set({ year: range.at(-1) });
        },
        setEndIndex(ctx2) {
          ctx2.activeIndex = 1;
        },
        setStartIndex(ctx2) {
          ctx2.activeIndex = 0;
        },
        focusActiveCell(ctx2) {
          raf(() => {
            dom.getFocusedCell(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusActiveCellIfNeeded(ctx2, evt) {
          if (!evt.focus)
            return;
          raf(() => {
            dom.getFocusedCell(ctx2)?.focus({ preventScroll: true });
          });
        },
        setHoveredValueIfKeyboard(ctx2, evt) {
          if (!evt.type.startsWith("GRID.ARROW") || ctx2.selectionMode !== "range" || ctx2.activeIndex === 0)
            return;
          ctx2.hoveredValue = ctx2.focusedValue.copy();
        },
        focusTriggerElement(ctx2) {
          raf(() => {
            dom.getTriggerEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        focusInputElement(ctx2) {
          raf(() => {
            dom.getInputEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        syncMonthSelectElement(ctx2) {
          const month = dom.getMonthSelectEl(ctx2);
          if (!month)
            return;
          month.value = ctx2.focusedValue.month.toString();
        },
        syncYearSelectElement(ctx2) {
          const year = dom.getYearSelectEl(ctx2);
          if (!year)
            return;
          year.value = ctx2.focusedValue.year.toString();
        },
        invokeOnFocusChange(ctx2) {
          ctx2.onFocusChange?.({ focusedValue: ctx2.focusedValue, value: ctx2.value, view: ctx2.view });
        },
        invokeOnViewChange(ctx2) {
          ctx2.onViewChange?.({ view: ctx2.view });
        },
        focusParsedDate(ctx2, evt) {
          ctx2.inputValue = evt.value;
          const date = parseDateString(ctx2.inputValue, ctx2.locale, ctx2.timeZone);
          if (!date)
            return;
          ctx2.focusedValue = date;
        },
        resetView(ctx2, _evt, { initialContext }) {
          ctx2.view = initialContext.view;
        },
        setStartValue(ctx2) {
          const startValue = alignDate(ctx2.focusedValue, "start", { months: ctx2.numOfMonths }, ctx2.locale);
          ctx2.startValue = startValue;
        }
      },
      compareFns: {
        startValue: (a, b) => a.toString() === b.toString(),
        focusedValue: (a, b) => a.toString() === b.toString(),
        value: (a, b) => a?.toString() === b?.toString()
      }
    }
  );
}

export { machine };
