'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const popper = require('@zag-js/popper');
const combobox_anatomy = require('./combobox.anatomy.js');
const combobox_dom = require('./combobox.dom.js');

function connect(state, send, normalize) {
  const translations = state.context.translations;
  const isDisabled = state.context.disabled;
  const isInteractive = state.context.isInteractive;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readOnly;
  const isOpen = state.hasTag("open");
  const isFocused = state.hasTag("focused");
  const isIdle = state.hasTag("idle");
  const autofill = isOpen && state.context.navigationData && state.context.autoComplete;
  const showClearButton = (!isIdle || state.context.isHovering) && !state.context.isInputValueEmpty;
  const value = autofill ? state.context.navigationData?.label : state.context.inputValue;
  const popperStyles = popper.getPlacementStyles({
    placement: state.context.currentPlacement
  });
  const api = {
    /**
     * Whether the combobox is focused
     */
    isFocused,
    /**
     * Whether the combobox content or listbox is open
     */
    isOpen,
    /**
     * Whether the combobox input is empty
     */
    isInputValueEmpty: state.context.isInputValueEmpty,
    /**
     * The current value of the combobox input
     */
    inputValue: state.context.inputValue,
    /**
     * The currently focused option (by pointer or keyboard)
     */
    focusedOption: state.context.focusedOptionData,
    /**
     * The currently selected option value
     */
    selectedValue: state.context.selectionData?.value,
    /**
     * Function to set the combobox value
     */
    setValue(value2) {
      let data;
      if (typeof value2 === "string") {
        data = { value: value2, label: combobox_dom.dom.getValueLabel(state.context, value2) };
      } else {
        data = value2;
      }
      send({ type: "SET_VALUE", ...data });
    },
    /**
     * Function to set the combobox input value
     */
    setInputValue(value2) {
      send({ type: "SET_INPUT_VALUE", value: value2 });
    },
    /**
     * Function to clear the combobox input value and selected value
     */
    clearValue() {
      send("CLEAR_VALUE");
    },
    /**
     * Function to focus the combobox input
     */
    focus() {
      combobox_dom.dom.getInputEl(state.context)?.focus();
    },
    rootProps: normalize.element({
      ...combobox_anatomy.parts.root.attrs,
      id: combobox_dom.dom.getRootId(state.context),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-readonly": domQuery.dataAttr(isReadOnly)
    }),
    labelProps: normalize.label({
      ...combobox_anatomy.parts.label.attrs,
      htmlFor: combobox_dom.dom.getInputId(state.context),
      id: combobox_dom.dom.getLabelId(state.context),
      "data-readonly": domQuery.dataAttr(isReadOnly),
      "data-disabled": domQuery.dataAttr(isDisabled),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-focus": domQuery.dataAttr(isFocused)
    }),
    controlProps: normalize.element({
      ...combobox_anatomy.parts.control.attrs,
      id: combobox_dom.dom.getControlId(state.context),
      "data-expanded": domQuery.dataAttr(isOpen),
      "data-focus": domQuery.dataAttr(isFocused),
      "data-disabled": domQuery.dataAttr(isDisabled),
      "data-invalid": domQuery.dataAttr(isInvalid),
      onPointerOver() {
        if (!isInteractive)
          return;
        send("POINTER_OVER");
      },
      onPointerLeave() {
        if (!isInteractive)
          return;
        send("POINTER_LEAVE");
      }
    }),
    positionerProps: normalize.element({
      ...combobox_anatomy.parts.positioner.attrs,
      id: combobox_dom.dom.getPositionerId(state.context),
      "data-expanded": domQuery.dataAttr(isOpen),
      hidden: !isOpen,
      style: popperStyles.floating
    }),
    inputProps: normalize.input({
      ...combobox_anatomy.parts.input.attrs,
      "aria-invalid": domQuery.ariaAttr(isInvalid),
      "data-invalid": domQuery.dataAttr(isInvalid),
      name: state.context.name,
      form: state.context.form,
      disabled: isDisabled,
      autoFocus: state.context.autoFocus,
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "none",
      spellCheck: "false",
      readOnly: isReadOnly,
      placeholder: state.context.placeholder,
      id: combobox_dom.dom.getInputId(state.context),
      type: "text",
      role: "combobox",
      defaultValue: value,
      "data-value": value,
      "aria-autocomplete": state.context.autoComplete ? "both" : "list",
      "aria-controls": isOpen ? combobox_dom.dom.getContentId(state.context) : void 0,
      "aria-expanded": isOpen,
      "aria-activedescendant": state.context.focusedId ?? void 0,
      onClick() {
        if (!isInteractive)
          return;
        send("CLICK_INPUT");
      },
      onFocus() {
        if (isDisabled)
          return;
        send("FOCUS");
      },
      onChange(event) {
        send({ type: "CHANGE", value: event.currentTarget.value });
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const evt = domEvent.getNativeEvent(event);
        if (evt.ctrlKey || evt.shiftKey || evt.isComposing)
          return;
        let prevent = false;
        const keymap = {
          ArrowDown(event2) {
            send(event2.altKey ? "ALT_ARROW_DOWN" : "ARROW_DOWN");
            prevent = true;
          },
          ArrowUp() {
            send(event.altKey ? "ALT_ARROW_UP" : "ARROW_UP");
            prevent = true;
          },
          Home(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "HOME", preventDefault: () => event2.preventDefault() });
          },
          End(event2) {
            const isCtrlKey = event2.ctrlKey || event2.metaKey;
            if (isCtrlKey)
              return;
            send({ type: "END", preventDefault: () => event2.preventDefault() });
          },
          Enter() {
            send("ENTER");
            prevent = true;
          },
          Escape() {
            send("ESCAPE");
            prevent = true;
          },
          Tab() {
            send("TAB");
          }
        };
        const key = domEvent.getEventKey(event, state.context);
        const exec = keymap[key];
        exec?.(event);
        if (prevent) {
          event.preventDefault();
        }
      }
    }),
    triggerProps: normalize.button({
      ...combobox_anatomy.parts.trigger.attrs,
      id: combobox_dom.dom.getTriggerId(state.context),
      "aria-haspopup": "listbox",
      type: "button",
      tabIndex: -1,
      "aria-label": translations.triggerLabel,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? combobox_dom.dom.getContentId(state.context) : void 0,
      disabled: isDisabled,
      "data-readonly": domQuery.dataAttr(isReadOnly),
      "data-disabled": domQuery.dataAttr(isDisabled),
      onPointerDown(event) {
        const evt = domEvent.getNativeEvent(event);
        if (!isInteractive || !domEvent.isLeftClick(evt) || evt.pointerType === "touch")
          return;
        send("CLICK_BUTTON");
        event.preventDefault();
      },
      onPointerUp(event) {
        if (event.pointerType !== "touch")
          return;
        send("CLICK_BUTTON");
      }
    }),
    contentProps: normalize.element({
      ...combobox_anatomy.parts.content.attrs,
      id: combobox_dom.dom.getContentId(state.context),
      role: "listbox",
      hidden: !isOpen,
      "aria-labelledby": combobox_dom.dom.getLabelId(state.context),
      onPointerDown(event) {
        event.preventDefault();
      }
    }),
    clearTriggerProps: normalize.button({
      ...combobox_anatomy.parts.clearTrigger.attrs,
      id: combobox_dom.dom.getClearTriggerId(state.context),
      type: "button",
      tabIndex: -1,
      disabled: isDisabled,
      "aria-label": translations.clearTriggerLabel,
      hidden: !showClearButton,
      onPointerDown(event) {
        const evt = domEvent.getNativeEvent(event);
        if (!isInteractive || !domEvent.isLeftClick(evt))
          return;
        send("CLEAR_VALUE");
        event.preventDefault();
      }
    }),
    getOptionState(props) {
      const { value: value2, index, disabled } = props;
      const id = combobox_dom.dom.getOptionId(state.context, value2, index);
      const focused = state.context.focusedId === id;
      const checked = state.context.selectionData?.value === value2;
      return { disabled, focused, checked };
    },
    getOptionProps(props) {
      const { value: value2, label, index, count } = props;
      const id = combobox_dom.dom.getOptionId(state.context, value2, index);
      const optionState = api.getOptionState(props);
      return normalize.element({
        ...combobox_anatomy.parts.option.attrs,
        id,
        role: "option",
        tabIndex: -1,
        "data-highlighted": domQuery.dataAttr(optionState.focused),
        "data-disabled": domQuery.dataAttr(optionState.disabled),
        "data-checked": domQuery.dataAttr(optionState.checked),
        "aria-selected": optionState.focused,
        "aria-disabled": optionState.disabled,
        "aria-posinset": count && index != null ? index + 1 : void 0,
        "aria-setsize": count,
        "data-value": value2,
        "data-label": label,
        // Prefer `pointermove` to `pointerenter` to avoid interrupting the keyboard navigation
        // NOTE: for perf, we may want to move these handlers to the listbox
        onPointerMove() {
          if (optionState.disabled)
            return;
          send({ type: "POINTEROVER_OPTION", id, value: value2, label });
        },
        onPointerUp() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "pointerup", id, value: value2, label });
        },
        onClick() {
          if (optionState.disabled)
            return;
          send({ type: "CLICK_OPTION", src: "click", id, value: value2, label });
        },
        onAuxClick(event) {
          if (optionState.disabled)
            return;
          event.preventDefault();
          send({ type: "CLICK_OPTION", src: "auxclick", id, value: value2, label });
        }
      });
    },
    getOptionGroupProps(props) {
      const { label } = props;
      return normalize.element({
        ...combobox_anatomy.parts.optionGroup.attrs,
        role: "group",
        "aria-label": label
      });
    }
  };
  return api;
}

exports.connect = connect;
