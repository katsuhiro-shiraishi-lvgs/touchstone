'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const tabbable = require('@zag-js/tabbable');
const utils = require('@zag-js/utils');
const getWindowFrames = require('./get-window-frames.js');

const POINTER_OUTSIDE_EVENT = "pointerdown.outside";
const FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(event) {
  const composedPath = event.composedPath() ?? [event.target];
  for (const node of composedPath) {
    if (domQuery.isHTMLElement(node) && tabbable.isFocusable(node))
      return true;
  }
  return false;
}
function trackInteractOutsideImpl(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside } = options;
  if (!node)
    return;
  const doc = domQuery.getDocument(node);
  const win = domQuery.getWindow(node);
  const frames = getWindowFrames.getWindowFrames(win);
  function isEventOutside(event) {
    const target = domQuery.getEventTarget(event);
    if (!domQuery.isHTMLElement(target)) {
      return false;
    }
    if (domQuery.contains(node, target)) {
      return false;
    }
    return !exclude?.(target);
  }
  let clickHandler;
  function onPointerDown(event) {
    function handler() {
      if (!node || !isEventOutside(event))
        return;
      if (onPointerDownOutside || onInteractOutside) {
        const handler2 = utils.callAll(onPointerDownOutside, onInteractOutside);
        node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
      }
      domEvent.fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: domEvent.isContextMenuEvent(event),
          focusable: isComposedPathFocusable(event)
        }
      });
    }
    if (event.pointerType === "touch") {
      frames.removeEventListener("click", handler);
      doc.removeEventListener("click", handler);
      clickHandler = handler;
      doc.addEventListener("click", handler, { once: true });
      frames.addEventListener("click", handler, { once: true });
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(domEvent.addDomEvent(doc, "pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    if (!node || !isEventOutside(event))
      return;
    if (onFocusOutside || onInteractOutside) {
      const handler = utils.callAll(onFocusOutside, onInteractOutside);
      node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
    }
    domEvent.fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: event,
        contextmenu: false,
        focusable: tabbable.isFocusable(domQuery.getEventTarget(event))
      }
    });
  }
  cleanups.add(domEvent.addDomEvent(doc, "focusin", onFocusin, true));
  cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    if (clickHandler) {
      frames.removeEventListener("click", clickHandler);
      doc.removeEventListener("click", clickHandler);
    }
    cleanups.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? domQuery.raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}

exports.trackInteractOutside = trackInteractOutside;
