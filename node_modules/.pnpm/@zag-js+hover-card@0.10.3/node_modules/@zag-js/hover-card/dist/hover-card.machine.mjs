import { createMachine, guards } from '@zag-js/core';
import { trackDismissableElement } from '@zag-js/dismissable';
import { getPlacement } from '@zag-js/popper';
import { compact } from '@zag-js/utils';
import { dom } from './hover-card.dom.mjs';

const { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          },
          on: {
            POINTER_LEAVE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            TRIGGER_BLUR: {
              guard: not("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            },
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            DISMISS: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            TRIGGER_BLUR: {
              guard: not("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            },
            SET_POSITIONING: {
              actions: "setPositioning"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          },
          on: {
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "DISMISS" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        setPositioning(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false
          });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        }
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}

export { machine };
