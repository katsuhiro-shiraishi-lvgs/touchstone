var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// src/index.ts
import { build } from "esbuild";
import path from "path";
import fs from "fs";
function requireDirect(file) {
  const fileName = fs.realpathSync(file);
  delete __require.cache[file];
  const mod = __require(fileName);
  return {
    mod: mod.default ?? mod,
    dependencies: [fileName],
    code: fs.readFileSync(fileName, "utf-8")
  };
}
async function bundleConfigFile(file, cwd) {
  const result = await build({
    absWorkingDir: cwd,
    entryPoints: [file],
    outfile: "out.js",
    write: false,
    platform: "node",
    bundle: true,
    format: "cjs",
    sourcemap: false,
    metafile: true,
    mainFields: ["module", "main"]
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
  };
}
function loadBundledFile(file, code) {
  const extension = path.extname(file);
  const realFileName = fs.realpathSync(file);
  const loader = __require.extensions[extension];
  __require.extensions[extension] = (mod, filename) => {
    if (filename === realFileName) {
      mod._compile(code, filename);
    } else {
      loader(mod, filename);
    }
  };
  delete __require.cache[__require.resolve(file)];
  const raw = __require(file);
  const result = raw.default ?? raw;
  __require.extensions[extension] = loader;
  return result;
}
async function bundleNRequire(file, opts = {}) {
  const { cwd = process.cwd() } = opts;
  const absPath = __require.resolve(file, { paths: [cwd] });
  try {
    return requireDirect(absPath);
  } catch {
    const bundle = await bundleConfigFile(absPath, cwd);
    try {
      bundle.mod = await loadBundledFile(absPath, bundle.code);
    } catch {
      bundle.mod = __require("node-eval")(bundle.code).default;
    }
    return bundle;
  }
}
export {
  bundleNRequire
};
