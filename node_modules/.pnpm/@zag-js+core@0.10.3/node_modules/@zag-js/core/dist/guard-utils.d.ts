import type { Dict, StateMachine as S } from "./types";
declare function or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(...conditions: Array<S.Guard<TContext, TState, TEvent>>): S.GuardHelper<TContext, TState, TEvent>;
declare function and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(...conditions: Array<S.Guard<TContext, TState, TEvent>>): S.GuardHelper<TContext, TState, TEvent>;
declare function not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(condition: S.Guard<TContext, TState, TEvent>): S.GuardHelper<TContext, TState, TEvent>;
declare function stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(...values: TState["value"][]): S.GuardExpression<TContext, TState, TEvent>;
export declare const guards: {
    or: typeof or;
    and: typeof and;
    not: typeof not;
    stateIn: typeof stateIn;
};
export declare function choose<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(actions: Array<{
    guard?: S.Guard<TContext, TState, TEvent>;
    actions: S.PureActions<TContext, TState, TEvent>;
}>): S.ChooseHelper<TContext, TState, TEvent>;
export declare function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(guard: S.Guard<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>): (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => boolean | undefined;
export declare function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(values: S.Actions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>): (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => S.PureActions<TContext, TState, TEvent> | undefined;
export {};
