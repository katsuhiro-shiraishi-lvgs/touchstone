import { snapshot, subscribe, subscribeKey, ref } from '@zag-js/store';
import { createProxy } from './create-proxy.mjs';
import { deepMerge } from './deep-merge.mjs';
import { determineDelayFn } from './delay-utils.mjs';
import { determineActionsFn, determineGuardFn } from './guard-utils.mjs';
import { determineTransitionFn } from './transition-utils.mjs';
import { MachineStatus, MachineType, ActionTypes } from './types.mjs';
import { structuredClone, toEvent, toArray } from './utils.mjs';
import { noop, uuid, cast, runIfFn } from './packages/utilities/core/src/functions.mjs';
import { clear } from './packages/utilities/core/src/array.mjs';
import { invariant, warn } from './packages/utilities/core/src/warning.mjs';
import { isObject, isArray, isString, isDev } from './packages/utilities/core/src/guard.mjs';
import { compact } from './packages/utilities/core/src/object.mjs';

class Machine {
  status = MachineStatus.NotStarted;
  state;
  initialState;
  initialContext;
  id;
  type = MachineType.Machine;
  // Cleanup function map (per state)
  activityEvents = /* @__PURE__ */ new Map();
  delayedEvents = /* @__PURE__ */ new Map();
  // state update listeners the user can opt-in for
  stateListeners = /* @__PURE__ */ new Set();
  contextListeners = /* @__PURE__ */ new Set();
  eventListeners = /* @__PURE__ */ new Set();
  doneListeners = /* @__PURE__ */ new Set();
  contextWatchers = /* @__PURE__ */ new Set();
  // Cleanup functions (for `subscribe`)
  removeStateListener = noop;
  removeEventListener = noop;
  removeContextListener = noop;
  // For Parent <==> Spawned Actor relationship
  parent;
  children = /* @__PURE__ */ new Map();
  // A map of guard, action, delay implementations
  guardMap;
  actionMap;
  delayMap;
  activityMap;
  sync;
  options;
  config;
  // Let's get started!
  constructor(config, options) {
    this.config = structuredClone(config);
    this.options = structuredClone(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = this.options?.guards ?? {};
    this.actionMap = this.options?.actions ?? {};
    this.delayMap = this.options?.delays ?? {};
    this.activityMap = this.options?.activities ?? {};
    this.sync = this.options?.sync ?? false;
    this.state = createProxy(this.config);
    this.initialContext = snapshot(this.state.context);
    const event = toEvent(ActionTypes.Created);
    this.executeActions(this.config?.created, event);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  // Starts the interpreted machine.
  start = (init) => {
    this.state.value = "";
    if (this.status === MachineStatus.Running) {
      return this;
    }
    this.status = MachineStatus.Running;
    this.removeStateListener = subscribe(
      this.state,
      () => {
        this.stateListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
      },
      this.sync
    );
    this.removeEventListener = subscribeKey(
      this.state,
      "event",
      (event2) => {
        this.executeActions(this.config.onEvent, event2);
        this.eventListeners.forEach((listener) => {
          listener(event2);
        });
      },
      this.sync
    );
    this.removeContextListener = subscribe(
      this.state.context,
      () => {
        this.log("Context:", this.contextSnapshot);
        this.contextListeners.forEach((listener) => {
          listener(this.contextSnapshot);
        });
      },
      this.sync || this.options.debug
    );
    this.setupContextWatchers();
    this.executeActivities(toEvent(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start);
    this.executeActions(this.config.entry, toEvent(ActionTypes.Start));
    const event = toEvent(ActionTypes.Init);
    const target = isObject(init) ? init.value : init;
    const context = isObject(init) ? init.context : void 0;
    if (context) {
      this.setContext(context);
    }
    const transition = {
      target: target ?? this.config.initial
    };
    const next = this.getNextStateInfo(transition, event);
    this.initialState = next;
    this.performStateChangeEffects(this.state.value, next, event);
    return this;
  };
  setupContextWatchers = () => {
    for (const [key, fn] of Object.entries(this.config.watch ?? {})) {
      const compareFn = this.options.compareFns?.[key];
      const cleanup = subscribeKey(
        this.state.context,
        key,
        () => {
          this.executeActions(fn, this.state.event);
        },
        this.sync,
        compareFn
      );
      this.contextWatchers.add(cleanup);
    }
  };
  // Stops the interpreted machine
  stop = () => {
    if (this.status === MachineStatus.Stopped)
      return;
    this.performExitEffects(this.state.value, toEvent(ActionTypes.Stop));
    this.executeActions(this.config.exit, toEvent(ActionTypes.Stop));
    this.setState("");
    this.setEvent(ActionTypes.Stop);
    this.stopStateListeners();
    this.stopChildren();
    this.stopActivities();
    this.stopDelayedEvents();
    this.stopContextWatchers();
    this.stopEventListeners();
    this.stopContextListeners();
    this.status = MachineStatus.Stopped;
    return this;
  };
  stopEventListeners = () => {
    this.eventListeners.clear();
    this.removeEventListener();
  };
  stopContextListeners = () => {
    this.contextListeners.clear();
    this.removeContextListener();
  };
  stopStateListeners = () => {
    this.removeStateListener();
    this.stateListeners.clear();
  };
  stopContextWatchers = () => {
    this.contextWatchers.forEach((fn) => fn());
    this.contextWatchers.clear();
  };
  stopDelayedEvents = () => {
    this.delayedEvents.forEach((state) => {
      state.forEach((stop) => stop());
    });
    this.delayedEvents.clear();
  };
  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)
  stopActivities = (state) => {
    if (state) {
      this.activityEvents.get(state)?.forEach((stop) => stop());
      this.activityEvents.get(state)?.clear();
      this.activityEvents.delete(state);
    } else {
      this.activityEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
        state2.clear();
      });
      this.activityEvents.clear();
    }
  };
  /**
   * Function to send event to spawned child machine or actor
   */
  sendChild = (evt, to) => {
    const event = toEvent(evt);
    const id = runIfFn(to, this.contextSnapshot);
    const child = this.children.get(id);
    if (!child) {
      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
    }
    child.send(event);
  };
  /**
   * Function to stop a running child machine or actor
   */
  stopChild = (id) => {
    if (!this.children.has(id)) {
      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
    }
    this.children.get(id).stop();
    this.children.delete(id);
  };
  removeChild = (id) => {
    this.children.delete(id);
  };
  // Stop and delete spawned actors
  stopChildren = () => {
    this.children.forEach((child) => child.stop());
    this.children.clear();
  };
  setParent = (parent) => {
    this.parent = parent;
  };
  spawn = (src, id) => {
    const actor = runIfFn(src);
    if (id)
      actor.id = id;
    actor.type = MachineType.Actor;
    actor.setParent(this);
    this.children.set(actor.id, cast(actor));
    actor.onDone(() => {
      this.removeChild(actor.id);
    }).start();
    return cast(ref(actor));
  };
  addActivityCleanup = (state, cleanup) => {
    if (!state)
      return;
    if (!this.activityEvents.has(state)) {
      this.activityEvents.set(state, /* @__PURE__ */ new Set([cleanup]));
    } else {
      this.activityEvents.get(state)?.add(cleanup);
    }
  };
  setState = (target) => {
    this.state.previousValue = this.state.value;
    this.state.value = target;
    const stateNode = this.getStateNode(target);
    if (target == null) {
      clear(this.state.tags);
    } else {
      this.state.tags = toArray(stateNode?.tags);
    }
  };
  /**
   * To used within side effects for React or Vue to update context
   */
  setContext = (context) => {
    if (!context)
      return;
    deepMerge(this.state.context, context);
  };
  withContext = (context) => {
    const newContext = { ...this.config.context, ...compact(context) };
    return new Machine({ ...this.config, context: newContext }, this.options);
  };
  setOptions = (options) => {
    const opts = compact(options);
    this.actionMap = { ...this.actionMap, ...opts.actions };
    this.delayMap = { ...this.delayMap, ...opts.delays };
    this.activityMap = { ...this.activityMap, ...opts.activities };
    this.guardMap = { ...this.guardMap, ...opts.guards };
  };
  getStateNode = (state) => {
    if (!state)
      return;
    return this.config.states?.[state];
  };
  getNextStateInfo = (transitions, event) => {
    const transition = this.determineTransition(transitions, event);
    const isTargetless = !transition?.target;
    const target = transition?.target ?? this.state.value;
    const changed = this.state.value !== target;
    const stateNode = this.getStateNode(target);
    const reenter = !isTargetless && !changed && !transition?.internal;
    const info = {
      reenter,
      transition,
      stateNode,
      target,
      changed
    };
    this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
    return info;
  };
  getActionFromDelayedTransition = (transition) => {
    const event = toEvent(ActionTypes.After);
    const determineDelay = determineDelayFn(transition.delay, this.delayMap);
    const delay = determineDelay(this.contextSnapshot, event);
    let id;
    return {
      entry: () => {
        id = globalThis.setTimeout(() => {
          const next = this.getNextStateInfo(transition, event);
          this.performStateChangeEffects(this.state.value, next, event);
        }, delay);
      },
      exit: () => {
        globalThis.clearTimeout(id);
      }
    };
  };
  /**
   * All `after` events leverage `setTimeout` and `clearTimeout`,
   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.
   *
   * To achieve this, we split the `after` defintion into `entry` and `exit`
   *  functions and append them to the state's `entry` and `exit` actions
   */
  getDelayedEventActions = (state) => {
    const stateNode = this.getStateNode(state);
    const event = toEvent(ActionTypes.After);
    if (!stateNode || !stateNode.after)
      return;
    const entries = [];
    const exits = [];
    if (isArray(stateNode.after)) {
      const transition = this.determineTransition(stateNode.after, event);
      if (!transition)
        return;
      const actions = this.getActionFromDelayedTransition(transition);
      entries.push(actions.entry);
      exits.push(actions.exit);
    } else if (isObject(stateNode.after)) {
      for (const delay in stateNode.after) {
        const transition = stateNode.after[delay];
        let resolvedTransition = {};
        if (isArray(transition)) {
          const picked = this.determineTransition(transition, event);
          if (picked)
            resolvedTransition = picked;
        } else if (isString(transition)) {
          resolvedTransition = { target: transition, delay };
        } else {
          resolvedTransition = { ...transition, delay };
        }
        const actions = this.getActionFromDelayedTransition(resolvedTransition);
        entries.push(actions.entry);
        exits.push(actions.exit);
      }
    }
    return { entries, exits };
  };
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      get state() {
        return self.stateSnapshot;
      },
      get initialContext() {
        return self.initialContext;
      },
      get initialState() {
        return self.initialState?.target ?? "";
      }
    };
  }
  get meta() {
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: this.initialState?.target ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  /**
   * Function to executes defined actions. It can accept actions as string
   * (referencing `options.actions`) or actual functions.
   */
  executeActions = (actions, event) => {
    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
    for (const action of toArray(pickedActions)) {
      const fn = isString(action) ? this.actionMap?.[action] : action;
      warn(
        isString(action) && !fn,
        `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
      );
      fn?.(this.state.context, event, this.meta);
    }
  };
  /**
   * Function to execute running activities and registers
   * their cleanup function internally (to be called later on when we exit the state)
   */
  executeActivities = (event, activities, state) => {
    for (const activity of activities) {
      const fn = isString(activity) ? this.activityMap?.[activity] : activity;
      if (!fn) {
        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
        continue;
      }
      const cleanup = fn(this.state.context, event, this.meta);
      if (cleanup) {
        this.addActivityCleanup(state ?? this.state.value, cleanup);
      }
    }
  };
  /**
   * Normalizes the `every` definition to transition. `every` can be:
   * - An array of possible actions to run (we need to pick the first match based on guard)
   * - An object of intervals and actions
   */
  createEveryActivities = (every, callbackfn) => {
    if (!every)
      return;
    const event = toEvent(ActionTypes.Every);
    if (isArray(every)) {
      const picked = toArray(every).find((transition) => {
        const delayOrFn = transition.delay;
        const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
        const delay2 = determineDelay2(this.contextSnapshot, event);
        const determineGuard = determineGuardFn(transition.guard, this.guardMap);
        const guard = determineGuard(this.contextSnapshot, event, this.guardMeta);
        return guard ?? delay2 != null;
      });
      if (!picked)
        return;
      const determineDelay = determineDelayFn(picked.delay, this.delayMap);
      const delay = determineDelay(this.contextSnapshot, event);
      const activity = () => {
        const id = globalThis.setInterval(() => {
          this.executeActions(picked.actions, event);
        }, delay);
        return () => {
          globalThis.clearInterval(id);
        };
      };
      callbackfn(activity);
    } else {
      for (const interval in every) {
        const actions = every?.[interval];
        const determineDelay = determineDelayFn(interval, this.delayMap);
        const delay = determineDelay(this.contextSnapshot, event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(actions, event);
          }, delay);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      }
    }
  };
  setEvent = (event) => {
    this.state.previousEvent = this.state.event;
    this.state.event = ref(toEvent(event));
  };
  performExitEffects = (current, event) => {
    const currentState = this.state.value;
    if (currentState === "")
      return;
    const stateNode = current ? this.getStateNode(current) : void 0;
    this.stopActivities(currentState);
    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
    const exitActions = toArray(_exit);
    const afterExitActions = this.delayedEvents.get(currentState);
    if (afterExitActions) {
      exitActions.push(...afterExitActions);
    }
    this.executeActions(exitActions, event);
    this.eventListeners.clear();
  };
  performEntryEffects = (next, event) => {
    const stateNode = this.getStateNode(next);
    const activities = toArray(stateNode?.activities);
    this.createEveryActivities(stateNode?.every, (activity) => {
      activities.unshift(activity);
    });
    if (activities.length > 0) {
      this.executeActivities(event, activities);
    }
    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(
      this.contextSnapshot,
      event,
      this.guardMeta
    );
    const entryActions = toArray(pickedActions);
    const afterActions = this.getDelayedEventActions(next);
    if (stateNode?.after && afterActions) {
      this.delayedEvents.set(next, afterActions?.exits);
      entryActions.push(...afterActions.entries);
    }
    this.executeActions(entryActions, event);
    if (stateNode?.type === "final") {
      this.state.done = true;
      this.doneListeners.forEach((listener) => {
        listener(this.stateSnapshot);
      });
      this.stop();
    }
  };
  performTransitionEffects = (transitions, event) => {
    const transition = this.determineTransition(transitions, event);
    this.executeActions(transition?.actions, event);
  };
  /**
   * Performs all the requires side-effects or reactions when
   * we move from state A => state B.
   *
   * The Effect order:
   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)
   */
  performStateChangeEffects = (current, next, event) => {
    this.setEvent(event);
    const changed = next.changed || next.reenter;
    if (changed) {
      this.performExitEffects(current, event);
    }
    this.performTransitionEffects(next.transition, event);
    this.setState(next.target);
    if (changed) {
      this.performEntryEffects(next.target, event);
    }
  };
  determineTransition = (transition, event) => {
    const fn = determineTransitionFn(transition, this.guardMap);
    return fn?.(this.contextSnapshot, event, this.guardMeta);
  };
  /**
   * Function to send event to parent machine from spawned child
   */
  sendParent = (evt) => {
    if (!this.parent) {
      invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
    }
    const event = toEvent(evt);
    this.parent?.send(event);
  };
  log = (...args) => {
    if (isDev() && this.options.debug) {
      console.log(...args);
    }
  };
  /**
   * Function to send an event to current machine
   */
  send = (evt) => {
    const event = toEvent(evt);
    this.transition(this.state.value, event);
  };
  transition = (state, evt) => {
    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode;
    const event = toEvent(evt);
    if (!stateNode && !this.config.on) {
      const msg = this.status === MachineStatus.Stopped ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state}, \`event\`: ${event.type}`;
      warn(msg);
      return;
    }
    const transitions = stateNode?.on?.[event.type] ?? this.config.on?.[event.type];
    const next = this.getNextStateInfo(transitions, event);
    this.performStateChangeEffects(this.state.value, next, event);
    return next.stateNode;
  };
  subscribe = (listener) => {
    this.stateListeners.add(listener);
    if (this.status === MachineStatus.Running) {
      listener(this.stateSnapshot);
    }
    return () => {
      this.stateListeners.delete(listener);
    };
  };
  onDone = (listener) => {
    this.doneListeners.add(listener);
    return this;
  };
  onTransition = (listener) => {
    this.stateListeners.add(listener);
    if (this.status === MachineStatus.Running) {
      listener(this.stateSnapshot);
    }
    return this;
  };
  onChange = (listener) => {
    this.contextListeners.add(listener);
    return this;
  };
  onEvent = (listener) => {
    this.eventListeners.add(listener);
    return this;
  };
  get [Symbol.toStringTag]() {
    return "Machine";
  }
}
const createMachine = (config, options) => new Machine(config, options);

export { Machine, createMachine };
