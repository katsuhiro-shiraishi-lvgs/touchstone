import { Dict, MachineStatus, MachineType, StateMachine as S, Writable } from "./types";
export declare class Machine<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject> {
    status: MachineStatus;
    readonly state: S.State<TContext, TState, TEvent>;
    initialState: S.StateInfo<TContext, TState, TEvent> | undefined;
    initialContext: TContext;
    id: string;
    type: MachineType;
    private activityEvents;
    private delayedEvents;
    private stateListeners;
    private contextListeners;
    private eventListeners;
    private doneListeners;
    private contextWatchers;
    private removeStateListener;
    private removeEventListener;
    private removeContextListener;
    private parent?;
    private children;
    private guardMap;
    private actionMap;
    private delayMap;
    private activityMap;
    private sync;
    options: S.MachineOptions<TContext, TState, TEvent>;
    config: S.MachineConfig<TContext, TState, TEvent>;
    constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>);
    private get stateSnapshot();
    getState(): S.State<TContext, TState, TEvent>;
    private get contextSnapshot();
    start: (init?: S.StateInit<TContext, TState>) => this;
    private setupContextWatchers;
    stop: () => this | undefined;
    private stopEventListeners;
    private stopContextListeners;
    private stopStateListeners;
    private stopContextWatchers;
    private stopDelayedEvents;
    private stopActivities;
    /**
     * Function to send event to spawned child machine or actor
     */
    sendChild: (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => void;
    /**
     * Function to stop a running child machine or actor
     */
    stopChild: (id: string) => void;
    removeChild: (id: string) => void;
    private stopChildren;
    private setParent;
    spawn: <TContext_1 extends Dict, TState_1 extends S.StateSchema, TEvent_1 extends S.EventObject = S.AnyEventObject>(src: MachineSrc<TContext_1, TState_1, TEvent_1>, id?: string) => Machine<TContext_1, TState_1, TEvent_1>;
    private addActivityCleanup;
    private setState;
    /**
     * To used within side effects for React or Vue to update context
     */
    setContext: (context: Partial<Writable<TContext>> | undefined) => void;
    withContext: (context: Partial<Writable<TContext>>) => Machine<TContext, TState, TEvent>;
    setOptions: (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => void;
    private getStateNode;
    private getNextStateInfo;
    private getActionFromDelayedTransition;
    /**
     * All `after` events leverage `setTimeout` and `clearTimeout`,
     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.
     *
     * To achieve this, we split the `after` defintion into `entry` and `exit`
     *  functions and append them to the state's `entry` and `exit` actions
     */
    private getDelayedEventActions;
    /**
     * A reference to the instance methods of the machine.
     * Useful when spawning child machines and managing the communication between them.
     */
    private get self();
    private get meta();
    private get guardMeta();
    /**
     * Function to executes defined actions. It can accept actions as string
     * (referencing `options.actions`) or actual functions.
     */
    private executeActions;
    /**
     * Function to execute running activities and registers
     * their cleanup function internally (to be called later on when we exit the state)
     */
    private executeActivities;
    /**
     * Normalizes the `every` definition to transition. `every` can be:
     * - An array of possible actions to run (we need to pick the first match based on guard)
     * - An object of intervals and actions
     */
    private createEveryActivities;
    private setEvent;
    private performExitEffects;
    private performEntryEffects;
    private performTransitionEffects;
    /**
     * Performs all the requires side-effects or reactions when
     * we move from state A => state B.
     *
     * The Effect order:
     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)
     */
    private performStateChangeEffects;
    private determineTransition;
    /**
     * Function to send event to parent machine from spawned child
     */
    sendParent: (evt: S.Event<S.AnyEventObject>) => void;
    private log;
    /**
     * Function to send an event to current machine
     */
    send: (evt: S.Event<TEvent>) => void;
    transition: (state: TState["value"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => S.StateNode<TContext, TState, TEvent> | undefined;
    subscribe: (listener: S.StateListener<TContext, TState, TEvent>) => () => void;
    onDone: (listener: S.StateListener<TContext, TState, TEvent>) => this;
    onTransition: (listener: S.StateListener<TContext, TState, TEvent>) => this;
    onChange: (listener: S.ContextListener<TContext>) => this;
    onEvent: (listener: S.EventListener<TEvent>) => this;
    get [Symbol.toStringTag](): string;
}
export type MachineSrc<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>);
export type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>;
export declare const createMachine: <TContext extends Dict, TState extends S.StateSchema = S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent> | undefined) => Machine<TContext, TState, TEvent>;
