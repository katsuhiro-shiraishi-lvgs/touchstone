'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const ariaHidden = require('@zag-js/aria-hidden');
const core = require('@zag-js/core');
const dismissable = require('@zag-js/dismissable');
const domQuery = require('@zag-js/dom-query');
const popper = require('@zag-js/popper');
const removeScroll = require('@zag-js/remove-scroll');
const tabbable = require('@zag-js/tabbable');
const utils = require('@zag-js/utils');
const focusTrap = require('focus-trap');
const popover_dom = require('./popover.dom.js');

function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEsc: true,
        autoFocus: true,
        modal: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            TOGGLE: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          entry: ["setInitialFocus"],
          on: {
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: ["restoreFocusIfNeeded", "invokeOnClose"]
            },
            TOGGLE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            SET_POSITIONING: {
              actions: "setPositioning"
            }
          }
        }
      }
    },
    {
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = popover_dom.dom.getAnchorEl(ctx2) ?? popover_dom.dom.getTriggerEl(ctx2);
          const getPositionerEl = () => popover_dom.dom.getPositionerEl(ctx2);
          return popper.getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => popover_dom.dom.getContentEl(ctx2);
          let restoreFocus = true;
          return dismissable.trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: popover_dom.dom.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              ctx2.onEscapeKeyDown?.(event);
              if (ctx2.closeOnEsc)
                return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (event.defaultPrevented)
                return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside(event) {
              ctx2.onPointerDownOutside?.(event);
            },
            onFocusOutside(event) {
              ctx2.onFocusOutside?.(event);
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled)
            return;
          const getContentEl = () => popover_dom.dom.getContentEl(ctx2);
          return tabbable.proxyTabFocus(getContentEl, {
            triggerElement: popover_dom.dom.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal)
            return;
          const getElements = () => [popover_dom.dom.getContentEl(ctx2), popover_dom.dom.getTriggerEl(ctx2)];
          return ariaHidden.ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal)
            return;
          return removeScroll.preventBodyScroll(popover_dom.dom.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal)
            return;
          let trap;
          domQuery.nextTick(() => {
            const el = popover_dom.dom.getContentEl(ctx2);
            if (!el)
              return;
            trap = focusTrap.createFocusTrap(el, {
              escapeDeactivates: false,
              allowOutsideClick: true,
              preventScroll: true,
              returnFocusOnDeactivate: true,
              document: popover_dom.dom.getDoc(ctx2),
              fallbackFocus: el,
              initialFocus: utils.runIfFn(ctx2.initialFocusEl)
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap?.deactivate();
        }
      },
      actions: {
        setPositioning(ctx2, evt) {
          const anchorEl = popover_dom.dom.getAnchorEl(ctx2) ?? popover_dom.dom.getTriggerEl(ctx2);
          const getPositionerEl = () => popover_dom.dom.getPositionerEl(ctx2);
          popper.getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false
          });
        },
        checkRenderedElements(ctx2) {
          domQuery.raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!popover_dom.dom.getTitleEl(ctx2),
              description: !!popover_dom.dom.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          domQuery.raf(() => {
            popover_dom.dom.getInitialFocusEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        restoreFocusIfNeeded(ctx2, evt) {
          if (!evt.restoreFocus)
            return;
          domQuery.raf(() => {
            popover_dom.dom.getTriggerEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        }
      }
    }
  );
}

exports.machine = machine;
