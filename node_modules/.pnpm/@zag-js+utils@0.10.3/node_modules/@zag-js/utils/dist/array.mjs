function toArray(v) {
  if (!v)
    return [];
  return Array.isArray(v) ? v : [v];
}
const fromLength = (length) => Array.from(Array(length).keys());
const first = (v) => v[0];
const last = (v) => v[v.length - 1];
const isEmpty = (v) => v.length === 0;
const has = (v, t) => v.indexOf(t) !== -1;
const add = (v, ...items) => v.concat(items);
const remove = (v, item) => removeAt(v, v.indexOf(item));
const removeAt = (v, i) => {
  if (i > -1)
    v.splice(i, 1);
  return v;
};
function clear(v) {
  while (v.length > 0)
    v.pop();
  return v;
}
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1)
    return step > 0 ? 0 : last2;
  if (next2 < 0)
    return loop ? last2 : 0;
  if (next2 >= len)
    return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
const chunk = (v, size) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    if (index % size === 0)
      rows.push([value]);
    else
      last(rows)?.push(value);
    return rows;
  }, res);
};

export { add, chunk, clear, first, fromLength, has, isEmpty, last, next, nextIndex, prev, prevIndex, remove, removeAt, toArray };
