'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domQuery = require('@zag-js/dom-query');
const visuallyHidden = require('@zag-js/visually-hidden');
const radioGroup_anatomy = require('./radio-group.anatomy.js');
const radioGroup_dom = require('./radio-group.dom.js');

function connect(state, send, normalize) {
  const isGroupDisabled = state.context.disabled;
  const isGroupReadOnly = state.context.readOnly;
  function getRadioState(props) {
    const radioState = {
      isReadOnly: props.readOnly || isGroupReadOnly,
      isInvalid: props.invalid,
      isDisabled: props.disabled || isGroupDisabled,
      isChecked: state.context.value === props.value,
      isFocused: state.context.focusedId === props.value,
      isHovered: state.context.hoveredId === props.value,
      isActive: state.context.activeId === props.value
    };
    return {
      ...radioState,
      isInteractive: !(radioState.isReadOnly || radioState.isDisabled)
    };
  }
  function getRadioDataAttrs(props) {
    const radioState = getRadioState(props);
    return {
      "data-focus": domQuery.dataAttr(radioState.isFocused),
      "data-disabled": domQuery.dataAttr(radioState.isDisabled),
      "data-checked": domQuery.dataAttr(radioState.isChecked),
      "data-hover": domQuery.dataAttr(radioState.isHovered),
      "data-invalid": domQuery.dataAttr(radioState.isInvalid),
      "data-readonly": domQuery.dataAttr(radioState.isReadOnly)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = radioGroup_dom.dom.getFirstEnabledAndCheckedInputEl(state.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = radioGroup_dom.dom.getFirstEnabledInputEl(state.context);
    firstEnabledInput?.focus();
  };
  return {
    /**
     * The current value of the radio group
     */
    value: state.context.value,
    /**
     * Function to set the value of the radio group
     */
    setValue(value) {
      send({ type: "SET_VALUE", value, manual: true });
    },
    /**
     * Function to clear the value of the radio group
     */
    clearValue() {
      send({ type: "SET_VALUE", value: null, manual: true });
    },
    /**
     * Function to focus the radio group
     */
    focus,
    /**
     * Function to blur the currently focused radio input in the radio group
     */
    blur() {
      const focusedElement = radioGroup_dom.dom.getActiveElement(state.context);
      const inputEls = radioGroup_dom.dom.getInputEls(state.context);
      const radioInputIsFocused = inputEls.some((el) => el === focusedElement);
      if (radioInputIsFocused)
        focusedElement?.blur();
    },
    /**
     * Returns the state details of a radio input
     */
    getRadioState,
    rootProps: normalize.element({
      ...radioGroup_anatomy.parts.root.attrs,
      role: "radiogroup",
      id: radioGroup_dom.dom.getRootId(state.context),
      "aria-labelledby": radioGroup_dom.dom.getLabelId(state.context),
      "data-orientation": state.context.orientation,
      "aria-orientation": state.context.orientation,
      dir: state.context.dir
    }),
    labelProps: normalize.element({
      ...radioGroup_anatomy.parts.label.attrs,
      id: radioGroup_dom.dom.getLabelId(state.context),
      onClick: focus
    }),
    getRadioProps(props) {
      const rootState = getRadioState(props);
      return normalize.label({
        ...radioGroup_anatomy.parts.radio.attrs,
        id: radioGroup_dom.dom.getRadioId(state.context, props.value),
        htmlFor: radioGroup_dom.dom.getRadioInputId(state.context, props.value),
        ...getRadioDataAttrs(props),
        onPointerMove() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: props.value, hovered: true });
        },
        onPointerLeave() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (!rootState.isInteractive)
            return;
          if (rootState.isFocused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props.value, active: true });
        },
        onPointerUp() {
          if (!rootState.isInteractive)
            return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getRadioLabelProps(props) {
      return normalize.element({
        ...radioGroup_anatomy.parts.radioLabel.attrs,
        id: radioGroup_dom.dom.getRadioLabelId(state.context, props.value),
        ...getRadioDataAttrs(props)
      });
    },
    getRadioControlProps(props) {
      const controlState = getRadioState(props);
      return normalize.element({
        ...radioGroup_anatomy.parts.radioControl.attrs,
        id: radioGroup_dom.dom.getRadioControlId(state.context, props.value),
        "data-active": domQuery.dataAttr(controlState.isActive),
        "aria-hidden": true,
        ...getRadioDataAttrs(props)
      });
    },
    getRadioInputProps(props) {
      const inputState = getRadioState(props);
      const isRequired = props.required;
      const trulyDisabled = inputState.isDisabled && !props.focusable;
      return normalize.input({
        ...radioGroup_anatomy.parts.radioInput.attrs,
        "data-ownedby": radioGroup_dom.dom.getRootId(state.context),
        id: radioGroup_dom.dom.getRadioInputId(state.context, props.value),
        type: "radio",
        name: state.context.name || state.context.id,
        form: state.context.form,
        value: props.value,
        onChange(event) {
          if (inputState.isReadOnly || inputState.isDisabled) {
            return;
          }
          if (event.target.checked) {
            send({ type: "SET_VALUE", value: props.value });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props.value, focused: true });
        },
        onKeyDown(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: trulyDisabled,
        required: isRequired,
        defaultChecked: inputState.isChecked,
        "data-disabled": domQuery.dataAttr(inputState.isDisabled),
        "aria-required": domQuery.ariaAttr(isRequired),
        "aria-invalid": domQuery.ariaAttr(inputState.isInvalid),
        readOnly: inputState.isReadOnly,
        "data-readonly": domQuery.dataAttr(inputState.isReadOnly),
        "aria-disabled": domQuery.ariaAttr(trulyDisabled),
        "aria-checked": domQuery.ariaAttr(inputState.isChecked),
        style: visuallyHidden.visuallyHiddenStyle
      });
    },
    indicatorProps: normalize.element({
      id: radioGroup_dom.dom.getIndicatorId(state.context),
      ...radioGroup_anatomy.parts.indicator.attrs,
      "data-orientation": state.context.orientation,
      style: {
        "--transition-duration": "150ms",
        "--transition-property": "left, top, width, height",
        position: "absolute",
        willChange: "var(--transition-property)",
        transitionProperty: "var(--transition-property)",
        transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration)" : "0ms",
        transitionTimingFunction: "var(--transition-timing-function)",
        ...state.context.indicatorRect
      }
    })
  };
}

exports.connect = connect;
