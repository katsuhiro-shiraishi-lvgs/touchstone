import { createMachine } from '@zag-js/core';
import { nextTick } from '@zag-js/dom-query';
import { trackElementRect } from '@zag-js/element-rect';
import { trackFormControl } from '@zag-js/form-utils';
import { compact, isString } from '@zag-js/utils';
import { dom } from './radio-group.dom.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        previousValue: null,
        value: null,
        activeId: null,
        focusedId: null,
        hoveredId: null,
        indicatorRect: {},
        canIndicatorTransition: false,
        ...ctx
      },
      entry: ["syncIndicatorRect"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState"],
      watch: {
        value: [
          "setIndicatorTransition",
          // important to set this after `setIndicatorTransition`
          "setPreviousValue",
          "invokeOnChange",
          "syncIndicatorRect",
          "syncInputElements"
        ]
      },
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom.getRootEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredId = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeId = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedId = evt.value;
        },
        invokeOnChange(ctx2, evt) {
          ctx2.onChange?.({ value: evt.value });
        },
        syncInputElements(ctx2) {
          const inputs = dom.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString(ctx2.previousValue) && isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          if (!dom.getIndicatorEl(ctx2))
            return;
          const value = ctx2.value;
          if (value == null) {
            ctx2.indicatorRect = {};
            return;
          }
          const radioEl = dom.getActiveRadioEl(ctx2);
          if (!radioEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        }
      }
    }
  );
}

export { machine };
