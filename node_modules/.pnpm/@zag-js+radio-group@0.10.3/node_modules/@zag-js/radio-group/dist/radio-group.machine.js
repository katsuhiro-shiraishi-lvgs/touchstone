'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@zag-js/core');
const domQuery = require('@zag-js/dom-query');
const elementRect = require('@zag-js/element-rect');
const formUtils = require('@zag-js/form-utils');
const utils = require('@zag-js/utils');
const radioGroup_dom = require('./radio-group.dom.js');

function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        previousValue: null,
        value: null,
        activeId: null,
        focusedId: null,
        hoveredId: null,
        indicatorRect: {},
        canIndicatorTransition: false,
        ...ctx
      },
      entry: ["syncIndicatorRect"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState"],
      watch: {
        value: [
          "setIndicatorTransition",
          // important to set this after `setIndicatorTransition`
          "setPreviousValue",
          "invokeOnChange",
          "syncIndicatorRect",
          "syncInputElements"
        ]
      },
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return formUtils.trackFormControl(radioGroup_dom.dom.getRootEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredId = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeId = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedId = evt.value;
        },
        invokeOnChange(ctx2, evt) {
          ctx2.onChange?.({ value: evt.value });
        },
        syncInputElements(ctx2) {
          const inputs = radioGroup_dom.dom.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = utils.isString(ctx2.previousValue) && utils.isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          if (!radioGroup_dom.dom.getIndicatorEl(ctx2))
            return;
          const value = ctx2.value;
          if (value == null) {
            ctx2.indicatorRect = {};
            return;
          }
          const radioEl = radioGroup_dom.dom.getActiveRadioEl(ctx2);
          if (!radioEl)
            return;
          ctx2.indicatorCleanup = elementRect.trackElementRect(radioEl, {
            getRect(el) {
              return radioGroup_dom.dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = radioGroup_dom.dom.resolveRect(rect);
              domQuery.nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        }
      }
    }
  );
}

exports.machine = machine;
