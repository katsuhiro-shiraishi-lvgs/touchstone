import { ariaHidden } from '@zag-js/aria-hidden';
import { createMachine } from '@zag-js/core';
import { trackDismissableElement } from '@zag-js/dismissable';
import { nextTick, raf } from '@zag-js/dom-query';
import { preventBodyScroll } from '@zag-js/remove-scroll';
import { compact, runIfFn } from '@zag-js/utils';
import { createFocusTrap } from 'focus-trap';
import { dom } from './dialog.dom.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnOutsideClick: true,
        closeOnEsc: true,
        restoreFocus: true,
        ...ctx
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose", "restoreFocus"]
            },
            TOGGLE: {
              target: "closed",
              actions: ["invokeOnClose", "restoreFocus"]
            }
          }
        },
        closed: {
          on: {
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            TOGGLE: {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onEscapeKeyDown(event) {
              if (!ctx2.closeOnEsc) {
                event.preventDefault();
              } else {
                send({ type: "CLOSE", src: "escape-key" });
              }
              ctx2.onEsc?.();
            },
            onPointerDownOutside(event) {
              if (!ctx2.closeOnOutsideClick) {
                event.preventDefault();
              }
              ctx2.onOutsideClick?.();
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll)
            return;
          return preventBodyScroll(dom.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus)
            return;
          let trap;
          nextTick(() => {
            const contentEl = dom.getContentEl(ctx2);
            if (!contentEl)
              return;
            trap = createFocusTrap(contentEl, {
              document: dom.getDoc(ctx2),
              escapeDeactivates: false,
              preventScroll: true,
              returnFocusOnDeactivate: false,
              fallbackFocus: contentEl,
              allowOutsideClick: true,
              initialFocus: runIfFn(ctx2.initialFocusEl)
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap?.deactivate();
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal)
            return;
          const getElements = () => [dom.getContainerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom.getDescriptionEl(ctx2);
          });
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        },
        restoreFocus(ctx2) {
          if (!ctx2.restoreFocus)
            return;
          raf(() => {
            const el = runIfFn(ctx2.finalFocusEl) ?? dom.getTriggerEl(ctx2);
            el?.focus({ preventScroll: true });
          });
        }
      }
    }
  );
}

export { machine };
