import { createMachine, guards } from '@zag-js/core';
import { addDomEvent } from '@zag-js/dom-event';
import { compact } from '@zag-js/utils';
import { dom } from './toast.dom.mjs';
import { getToastDuration } from './toast.utils.mjs';

const { not, and, or } = guards;
function createToastMachine(options = {}) {
  const { type = "info", duration, id = "toast", placement = "bottom", removeDelay = 0, ...restProps } = options;
  const ctx = compact(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id,
      entry: "invokeOnOpen",
      initial: type === "loading" ? "persist" : "active",
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx
      },
      on: {
        UPDATE: [
          {
            guard: and("hasTypeChanged", "isChangingToLoading"),
            target: "persist",
            actions: ["setContext", "invokeOnUpdate"]
          },
          {
            guard: or("hasDurationChanged", "hasTypeChanged"),
            target: "active:temp",
            actions: ["setContext", "invokeOnUpdate"]
          },
          {
            actions: ["setContext", "invokeOnUpdate"]
          }
        ]
      },
      states: {
        "active:temp": {
          tags: ["visible", "updating"],
          after: {
            0: "active"
          }
        },
        persist: {
          tags: ["visible", "paused"],
          activities: "trackDocumentVisibility",
          on: {
            RESUME: {
              guard: not("isLoadingType"),
              target: "active",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        active: {
          tags: ["visible"],
          activities: "trackDocumentVisibility",
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnClosing",
          after: {
            REMOVE_DELAY: {
              target: "inactive",
              actions: "notifyParentToRemove"
            }
          }
        },
        inactive: {
          entry: "invokeOnClose",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle)
            return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE" : "RESUME");
          });
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => evt.toast?.type === "loading",
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => evt.toast?.type !== ctx2.type,
        hasDurationChanged: (ctx2, evt) => evt.toast?.duration !== ctx2.duration
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self }) {
          self.sendParent({ type: "REMOVE_TOAST", id: self.id });
        },
        invokeOnClosing(ctx2) {
          ctx2.onClosing?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnUpdate(ctx2) {
          ctx2.onUpdate?.();
        },
        setContext(ctx2, evt) {
          const { duration: duration2, type: type2 } = evt.toast;
          const time = getToastDuration(duration2, type2);
          Object.assign(ctx2, { ...evt.toast, duration: time, remaining: time });
        }
      }
    }
  );
}

export { createToastMachine };
