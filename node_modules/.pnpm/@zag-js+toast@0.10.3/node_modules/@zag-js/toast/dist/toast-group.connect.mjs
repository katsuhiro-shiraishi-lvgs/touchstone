import { subscribe } from '@zag-js/core';
import { uuid, runIfFn } from '@zag-js/utils';
import { parts } from './toast.anatomy.mjs';
import { dom } from './toast.dom.mjs';
import { getToastsByPlacement, getGroupPlacementStyle } from './toast.utils.mjs';

let toaster = {};
function groupConnect(state, send, normalize) {
  const group = {
    /**
     * The total number of toasts
     */
    count: state.context.count,
    /**
     * The active toasts
     */
    toasts: state.context.toasts,
    /**
     * The active toasts by placement
     */
    toastsByPlacement: getToastsByPlacement(state.context.toasts),
    /**
     * Returns whether the toast id is visible
     */
    isVisible(id) {
      if (!state.context.toasts.length)
        return false;
      return !!state.context.toasts.find((toast) => toast.id == id);
    },
    /**
     * Function to create a toast.
     */
    create(options) {
      const uid = `toast:${uuid()}`;
      const id = options.id ? options.id : uid;
      if (group.isVisible(id))
        return;
      send({ type: "ADD_TOAST", toast: { ...options, id } });
      return id;
    },
    /**
     * Function to create or update a toast.
     */
    upsert(options) {
      const { id } = options;
      const isVisible = id ? group.isVisible(id) : false;
      if (isVisible && id != null) {
        return group.update(id, options);
      } else {
        return group.create(options);
      }
    },
    /**
     * Function to dismiss a toast by id.
     * If no id is provided, all toasts will be dismissed.
     */
    dismiss(id) {
      if (id == null) {
        send("DISMISS_ALL");
      } else if (group.isVisible(id)) {
        send({ type: "DISMISS_TOAST", id });
      }
    },
    /**
     * Function to remove a toast by id.
     * If no id is provided, all toasts will be removed.
     */
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (group.isVisible(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    /**
     * Function to dismiss all toasts by placement.
     */
    dismissByPlacement(placement) {
      const toasts = group.toastsByPlacement[placement];
      if (toasts) {
        toasts.forEach((toast) => group.dismiss(toast.id));
      }
    },
    /**
     * Function to update a toast's options by id.
     */
    update(id, options) {
      if (!group.isVisible(id))
        return;
      send({ type: "UPDATE_TOAST", id, toast: options });
      return id;
    },
    /**
     * Function to create a loading toast.
     */
    loading(options) {
      options.type = "loading";
      return group.upsert(options);
    },
    /**
     * Function to create a success toast.
     */
    success(options) {
      options.type = "success";
      return group.upsert(options);
    },
    /**
     * Function to create an error toast.
     */
    error(options) {
      options.type = "error";
      return group.upsert(options);
    },
    /**
     * Function to create a toast from a promise.
     * - When the promise resolves, the toast will be updated with the success options.
     * - When the promise rejects, the toast will be updated with the error options.
     */
    promise(promise, options, shared = {}) {
      const id = group.loading({ ...shared, ...options.loading });
      promise.then((response) => {
        const successOptions = runIfFn(options.success, response);
        group.success({ ...shared, ...successOptions, id });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        group.error({ ...shared, ...errorOptions, id });
      });
      return promise;
    },
    /**
     * Function to pause a toast by id.
     */
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (group.isVisible(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    /**
     * Function to resume a toast by id.
     */
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (group.isVisible(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      return normalize.element({
        ...parts.group.attrs,
        tabIndex: -1,
        "aria-label": label,
        id: dom.getGroupId(placement),
        "data-placement": placement,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state.context, placement)
      });
    },
    subscribe(fn) {
      return subscribe(state.context.toasts, () => fn(state.context.toasts));
    }
  };
  Object.assign(toaster, group);
  return group;
}

export { groupConnect, toaster };
