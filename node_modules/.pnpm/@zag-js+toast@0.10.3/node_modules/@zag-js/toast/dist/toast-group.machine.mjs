import { createMachine } from '@zag-js/core';
import { MAX_Z_INDEX } from '@zag-js/dom-query';
import { compact } from '@zag-js/utils';
import { createToastMachine } from './toast.machine.mjs';

function groupMachine(userContext) {
  const ctx = compact(userContext);
  return createMachine({
    id: "toaster",
    initial: "active",
    context: {
      dir: "ltr",
      max: Number.MAX_SAFE_INTEGER,
      toasts: [],
      gutter: "1rem",
      zIndex: MAX_Z_INDEX,
      pauseOnPageIdle: false,
      pauseOnInteraction: true,
      offsets: { left: "0px", right: "0px", top: "0px", bottom: "0px" },
      ...ctx
    },
    computed: {
      count: (ctx2) => ctx2.toasts.length
    },
    on: {
      SETUP: {},
      PAUSE_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("PAUSE", evt.id);
        }
      },
      PAUSE_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        }
      },
      RESUME_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("RESUME", evt.id);
        }
      },
      RESUME_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        }
      },
      ADD_TOAST: {
        guard: (ctx2) => ctx2.toasts.length < ctx2.max,
        actions: (ctx2, evt, { self }) => {
          const options = {
            ...evt.toast,
            pauseOnPageIdle: ctx2.pauseOnPageIdle,
            pauseOnInteraction: ctx2.pauseOnInteraction,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode
          };
          const toast = createToastMachine(options);
          const actor = self.spawn(toast);
          ctx2.toasts.push(actor);
        }
      },
      UPDATE_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        }
      },
      DISMISS_TOAST: {
        actions: (_ctx, evt, { self }) => {
          self.sendChild("DISMISS", evt.id);
        }
      },
      DISMISS_ALL: {
        actions: (ctx2) => {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        }
      },
      REMOVE_TOAST: {
        actions: (ctx2, evt, { self }) => {
          self.stopChild(evt.id);
          const index = ctx2.toasts.findIndex((toast) => toast.id === evt.id);
          ctx2.toasts.splice(index, 1);
        }
      },
      REMOVE_ALL: {
        actions: (ctx2, _evt, { self }) => {
          ctx2.toasts.forEach((toast) => self.stopChild(toast.id));
          while (ctx2.toasts.length)
            ctx2.toasts.pop();
        }
      }
    }
  });
}

export { groupMachine };
