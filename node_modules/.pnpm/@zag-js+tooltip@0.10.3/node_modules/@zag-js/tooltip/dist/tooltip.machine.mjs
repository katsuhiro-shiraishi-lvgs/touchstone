import { createMachine, subscribe } from '@zag-js/core';
import { addDomEvent } from '@zag-js/dom-event';
import { getScrollParents, isSafari, isHTMLElement } from '@zag-js/dom-query';
import { getPlacement } from '@zag-js/popper';
import { compact } from '@zag-js/utils';
import { dom } from './tooltip.dom.mjs';
import { store } from './tooltip.store.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: "closed",
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEsc: true,
        interactive: true,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      on: {
        OPEN: "open",
        CLOSE: "closed"
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId", "invokeOnClose"],
          on: {
            FOCUS: "open",
            POINTER_ENTER: [
              {
                guard: "noVisibleTooltip",
                target: "opening"
              },
              { target: "open" }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: "open"
          },
          on: {
            POINTER_LEAVE: "closed",
            BLUR: "closed",
            SCROLL: "closed",
            POINTER_LOCK_CHANGE: "closed",
            POINTER_DOWN: {
              guard: "closeOnPointerDown",
              target: "closed"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: [
            "trackEscapeKey",
            "trackDisabledTriggerOnSafari",
            "trackScroll",
            "trackPointerlockChange",
            "trackPositioning"
          ],
          entry: ["setGlobalId", "invokeOnOpen"],
          on: {
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing"
              },
              { target: "closed" }
            ],
            BLUR: "closed",
            ESCAPE: "closed",
            SCROLL: "closed",
            POINTER_LOCK_CHANGE: "closed",
            TOOLTIP_POINTER_LEAVE: {
              guard: "isInteractive",
              target: "closing"
            },
            POINTER_DOWN: {
              guard: "closeOnPointerDown",
              target: "closed"
            },
            CLICK: "closed",
            SET_POSITIONING: {
              actions: "setPositioning"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: "closed"
          },
          on: {
            FORCE_CLOSE: "closed",
            POINTER_ENTER: "open",
            TOOLTIP_POINTER_ENTER: {
              guard: "isInteractive",
              target: "open"
            }
          }
        }
      }
    },
    {
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            },
            onCleanup() {
              ctx2.currentPlacement = void 0;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send("POINTER_LOCK_CHANGE");
          return addDomEvent(dom.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          const trigger = dom.getTriggerEl(ctx2);
          if (!trigger)
            return;
          const cleanups = getScrollParents(trigger).map((el) => {
            const opts = { passive: true, capture: true };
            return addDomEvent(el, "scroll", () => send("SCROLL"), opts);
          });
          return () => {
            cleanups.forEach((fn) => fn?.());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe(store, () => {
            if (store.id !== ctx2.id) {
              send("FORCE_CLOSE");
            }
          });
        },
        trackDisabledTriggerOnSafari(ctx2, _evt, { send }) {
          if (!isSafari())
            return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (event) => {
            const selector = "[data-part=trigger][data-expanded]";
            if (isHTMLElement(event.target) && event.target.closest(selector))
              return;
            send("POINTER_LEAVE");
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEsc)
            return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "keydown", (event) => {
            if (event.key === "Escape") {
              send("ESCAPE");
            }
          });
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2, evt) {
          const omit = ["TOOLTIP_POINTER_ENTER", "POINTER_ENTER"];
          if (!omit.includes(evt.type)) {
            ctx2.onOpen?.();
          }
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (ctx2.disabled) {
            send("CLOSE");
          }
        },
        setPositioning(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false
          });
        },
        toggleVisibility(ctx2, _evt, { send }) {
          send({ type: ctx2.open ? "OPEN" : "CLOSE", src: "controlled" });
        }
      },
      guards: {
        closeOnPointerDown: (ctx2) => ctx2.closeOnPointerDown,
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}

export { machine };
