import * as _pandacss_types_dist_shared from '@pandacss/types/dist/shared';
import * as _pandacss_core from '@pandacss/core';
import * as _pandacss_token_dictionary from '@pandacss/token-dictionary';
import * as _pandacss_types from '@pandacss/types';
import { ConfigResultWithHooks, TSConfig } from '@pandacss/types';

declare const getEngine: (conf: ConfigResultWithHooks) => {
    patterns: {
        patterns: Record<string, _pandacss_types.PatternConfig>;
        transform: (name: string, data: _pandacss_types.Dict) => _pandacss_types.SystemStyleObject;
        getConfig: (name: string) => _pandacss_types.PatternConfig;
        getNames: (name: string) => {
            name: string;
            upperName: string;
            dashName: string;
            styleFnName: string;
            jsxName: string;
        };
        details: {
            props: string[];
            blocklistType: string;
            config: _pandacss_types.PatternConfig;
            name: string;
            upperName: string;
            dashName: string;
            styleFnName: string;
            jsxName: string;
        }[];
        nodes: {
            type: "pattern";
            name: string;
            props: string[];
            baseName: string;
        }[];
        getFnName: (jsx: string) => string;
        isEmpty: () => boolean;
    };
    jsx: {
        factoryName: string;
        upperName: string;
        typeName: string;
        componentName: string;
        framework: ("react" | "solid" | "preact" | "vue" | "qwik") | undefined;
    };
    paths: {
        get: (file?: string | undefined) => string[];
        root: string[];
        css: string[];
        token: string[];
        types: string[];
        recipe: string[];
        pattern: string[];
        chunk: string[];
        outCss: string[];
        jsx: string[];
    };
    file: {
        ext(file: string): string;
        import(mod: string, file: string): string;
        export(file: string): string;
    };
    isTemplateLiteralSyntax: boolean;
    studio: {
        outdir: string;
        logo?: string | undefined;
        inject?: {
            head?: string | undefined;
            body?: string | undefined;
        } | undefined;
    };
    hash: {
        tokens: boolean | undefined;
        className: boolean | undefined;
    };
    prefix: {
        tokens: string | undefined;
        className: string | undefined;
    };
    tokens: _pandacss_token_dictionary.TokenDictionary;
    utility: _pandacss_core.Utility;
    properties: string[];
    isValidProperty: (key: string) => boolean;
    recipes: _pandacss_core.Recipes;
    conditions: _pandacss_core.Conditions;
    createSheetContext: () => _pandacss_core.StylesheetContext;
    createSheet: (options?: Pick<_pandacss_core.StylesheetOptions, "content"> | undefined) => _pandacss_core.Stylesheet;
    hooks: _pandacss_types.PandaHookable;
    path: string;
    config: _pandacss_types_dist_shared.UnwrapExtend<_pandacss_types.RequiredBy<_pandacss_types.Config, "outdir" | "cwd" | "include">>;
    tsconfig?: TSConfig | undefined;
    tsOptions?: _pandacss_types.ConfigTsOptions | undefined;
    tsconfigFile?: string | undefined;
    dependencies: string[];
};
type Context = ReturnType<typeof getEngine>;

declare const artifactsGenerated: (ctx: Context) => () => string;
declare const configExists: (cmd: string) => string;
declare const thankYou: () => string;
declare const codegenComplete: () => string;
declare const noExtract: () => string;
declare const watch: () => string;
declare const configWatch: () => string;
declare const buildComplete: (count: number) => string;
declare const getMessages: (ctx: Context) => {
    artifactsGenerated: () => string;
    configExists: (cmd: string) => string;
    thankYou: () => string;
    codegenComplete: () => string;
    noExtract: () => string;
    watch: () => string;
    buildComplete: (count: number) => string;
    configWatch: () => string;
};

declare const messages_artifactsGenerated: typeof artifactsGenerated;
declare const messages_buildComplete: typeof buildComplete;
declare const messages_codegenComplete: typeof codegenComplete;
declare const messages_configExists: typeof configExists;
declare const messages_configWatch: typeof configWatch;
declare const messages_getMessages: typeof getMessages;
declare const messages_noExtract: typeof noExtract;
declare const messages_thankYou: typeof thankYou;
declare const messages_watch: typeof watch;
declare namespace messages {
  export {
    messages_artifactsGenerated as artifactsGenerated,
    messages_buildComplete as buildComplete,
    messages_codegenComplete as codegenComplete,
    messages_configExists as configExists,
    messages_configWatch as configWatch,
    messages_getMessages as getMessages,
    messages_noExtract as noExtract,
    messages_thankYou as thankYou,
    messages_watch as watch,
  };
}

declare const createGenerator: (conf: ConfigResultWithHooks) => {
    getArtifacts: () => _pandacss_types.Artifact[];
    getCss: (options: {
        files: string[];
        resolve?: boolean | undefined;
    }) => string;
    getParserCss: (result: _pandacss_types.ParserResultType) => string | undefined;
    messages: {
        artifactsGenerated: () => string;
        configExists: (cmd: string) => string;
        thankYou: () => string;
        codegenComplete: () => string;
        noExtract: () => string;
        watch: () => string;
        buildComplete: (count: number) => string;
        configWatch: () => string;
    };
    parserOptions: {
        importMap: {
            css: string[];
            recipe: string[];
            pattern: string[];
            jsx: string[];
        };
        jsx: {
            factory: string;
            isStyleProp: (key: string) => boolean;
            nodes: ({
                type: "pattern";
                name: string;
                props: string[];
                baseName: string;
            } | {
                type: "recipe";
                name: string;
                props: string[];
                baseName: string;
                jsx: (string | RegExp)[];
                match: RegExp;
            })[];
        };
        getRecipesByJsxName: (jsxName: string) => {
            name: string;
            variantKeys: string[];
            variantKeyMap: Record<string, string[]>;
            jsx: (string | RegExp)[];
            upperName: string;
            dashName: string;
            jsxName: string;
            match: RegExp;
            config: _pandacss_types.RecipeConfig;
            splitProps: (props: _pandacss_types.Dict) => [_pandacss_types.Dict, _pandacss_types.Dict];
        }[];
        compilerOptions: any;
        tsOptions: _pandacss_types.ConfigTsOptions | undefined;
    };
    patterns: {
        patterns: Record<string, _pandacss_types.PatternConfig>;
        transform: (name: string, data: _pandacss_types.Dict) => _pandacss_types.SystemStyleObject;
        getConfig: (name: string) => _pandacss_types.PatternConfig;
        getNames: (name: string) => {
            name: string;
            upperName: string;
            dashName: string;
            styleFnName: string;
            jsxName: string;
        };
        details: {
            props: string[];
            blocklistType: string;
            config: _pandacss_types.PatternConfig;
            name: string;
            upperName: string;
            dashName: string;
            styleFnName: string;
            jsxName: string;
        }[];
        nodes: {
            type: "pattern";
            name: string;
            props: string[];
            baseName: string;
        }[];
        getFnName: (jsx: string) => string;
        isEmpty: () => boolean;
    };
    jsx: {
        factoryName: string;
        upperName: string;
        typeName: string;
        componentName: string;
        framework: ("react" | "solid" | "preact" | "vue" | "qwik") | undefined;
    };
    paths: {
        get: (file?: string | undefined) => string[];
        root: string[];
        css: string[];
        token: string[];
        types: string[];
        recipe: string[];
        pattern: string[];
        chunk: string[];
        outCss: string[];
        jsx: string[];
    };
    file: {
        ext(file: string): string;
        import(mod: string, file: string): string;
        export(file: string): string;
    };
    isTemplateLiteralSyntax: boolean;
    studio: {
        outdir: string;
        logo?: string | undefined;
        inject?: {
            head?: string | undefined;
            body?: string | undefined;
        } | undefined;
    };
    hash: {
        tokens: boolean | undefined;
        className: boolean | undefined;
    };
    prefix: {
        tokens: string | undefined;
        className: string | undefined;
    };
    tokens: _pandacss_token_dictionary.TokenDictionary;
    utility: _pandacss_core.Utility;
    properties: string[];
    isValidProperty: (key: string) => boolean;
    recipes: _pandacss_core.Recipes;
    conditions: _pandacss_core.Conditions;
    createSheetContext: () => _pandacss_core.StylesheetContext;
    createSheet: (options?: Pick<_pandacss_core.StylesheetOptions, "content"> | undefined) => _pandacss_core.Stylesheet;
    hooks: _pandacss_types.PandaHookable;
    path: string;
    config: _pandacss_types_dist_shared.UnwrapExtend<_pandacss_types.RequiredBy<_pandacss_types.Config, "outdir" | "cwd" | "include">>;
    tsconfig?: TSConfig | undefined;
    tsOptions?: _pandacss_types.ConfigTsOptions | undefined;
    tsconfigFile?: string | undefined;
    dependencies: string[];
};
type Generator = ReturnType<typeof createGenerator>;

export { Generator, createGenerator, messages };
