'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@zag-js/core');
const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const popper = require('@zag-js/popper');
const menu_anatomy = require('./menu.anatomy.js');
const menu_dom = require('./menu.dom.js');

function connect(state, send, normalize) {
  const isSubmenu = state.context.isSubmenu;
  const values = state.context.value;
  const isTypingAhead = state.context.isTypingAhead;
  const isOpen = state.hasTag("visible");
  const popperStyles = popper.getPlacementStyles({
    placement: state.context.currentPlacement
  });
  const api = {
    /**
     * Whether the menu is open
     */
    isOpen,
    /**
     * Function to open the menu
     */
    open() {
      send("OPEN");
    },
    /**
     * Function to close the menu
     */
    close() {
      send("CLOSE");
    },
    /**
     * The id of the currently highlighted menuitem
     */
    highlightedId: state.context.highlightedId,
    /**
     * Function to set the highlighted menuitem
     */
    setHighlightedId(id) {
      send({ type: "SET_HIGHLIGHTED_ID", id });
    },
    /**
     * Function to register a parent menu. This is used for submenus
     */
    setParent(parent) {
      send({ type: "SET_PARENT", value: parent, id: parent.state.context.id });
    },
    /**
     * Function to register a child menu. This is used for submenus
     */
    setChild(child) {
      send({ type: "SET_CHILD", value: child, id: child.state.context.id });
    },
    /**
     * The value of the menu options item
     */
    value: values,
    /**
     * Function to set the value of the menu options item
     */
    setValue(name, value) {
      send({ type: "SET_VALUE", name, value });
    },
    /**
     * Function to check if an option is checked
     */
    isOptionChecked(opts) {
      return opts.type === "radio" ? values?.[opts.name] === opts.value : values?.[opts.name].includes(opts.value);
    },
    /**
     * Function to reposition the popover
     */
    setPositioning(options = {}) {
      send({ type: "SET_POSITIONING", options });
    },
    contextTriggerProps: normalize.element({
      ...menu_anatomy.parts.trigger.attrs,
      id: menu_dom.dom.getContextTriggerId(state.context),
      onPointerDown(event) {
        if (event.pointerType === "mouse")
          return;
        const evt = domEvent.getNativeEvent(event);
        const point = domEvent.getEventPoint(evt);
        send({ type: "CONTEXT_MENU_START", point });
      },
      onPointerCancel(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerMove(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerUp(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onContextMenu(event) {
        const evt = domEvent.getNativeEvent(event);
        const point = domEvent.getEventPoint(evt);
        send({ type: "CONTEXT_MENU", point });
        event.preventDefault();
      },
      style: {
        WebkitTouchCallout: "none",
        userSelect: "none"
      }
    }),
    getTriggerItemProps(childApi) {
      return core.mergeProps(api.getItemProps({ id: childApi.triggerProps.id }), childApi.triggerProps);
    },
    triggerProps: normalize.button({
      ...isSubmenu ? menu_anatomy.parts.triggerItem.attrs : menu_anatomy.parts.trigger.attrs,
      "data-placement": state.context.currentPlacement,
      type: "button",
      dir: state.context.dir,
      id: menu_dom.dom.getTriggerId(state.context),
      "data-uid": state.context.id,
      "aria-haspopup": "menu",
      "aria-controls": menu_dom.dom.getContentId(state.context),
      "aria-expanded": isOpen || void 0,
      "data-expanded": domQuery.dataAttr(isOpen),
      onPointerMove(event) {
        if (event.pointerType !== "mouse")
          return;
        const disabled = menu_dom.dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
      },
      onPointerLeave(event) {
        if (event.pointerType !== "mouse")
          return;
        const evt = domEvent.getNativeEvent(event);
        const disabled = menu_dom.dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        const point = domEvent.getEventPoint(evt);
        send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
      },
      onClick(event) {
        if (menu_dom.dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onPointerDown(event) {
        const disabled = menu_dom.dom.isTargetDisabled(event.currentTarget);
        const evt = domEvent.getNativeEvent(event);
        if (!domEvent.isLeftClick(evt) || disabled || domEvent.isContextMenuEvent(event))
          return;
        event.preventDefault();
        if (!menu_dom.dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onKeyDown(event) {
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          Enter() {
            send({ type: "ARROW_DOWN" });
          },
          Space() {
            send({ type: "ARROW_DOWN" });
          }
        };
        const key = domEvent.getEventKey(event, state.context);
        const exec = keyMap[key];
        if (exec) {
          event.preventDefault();
          exec(event);
        }
      }
    }),
    positionerProps: normalize.element({
      ...menu_anatomy.parts.positioner.attrs,
      id: menu_dom.dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    arrowProps: normalize.element({
      id: menu_dom.dom.getArrowId(state.context),
      ...menu_anatomy.parts.arrow.attrs,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...menu_anatomy.parts.arrowTip.attrs,
      style: popperStyles.arrowTip
    }),
    contentProps: normalize.element({
      ...menu_anatomy.parts.content.attrs,
      id: menu_dom.dom.getContentId(state.context),
      "aria-label": state.context["aria-label"],
      hidden: !isOpen,
      role: "menu",
      tabIndex: 0,
      dir: state.context.dir,
      "aria-activedescendant": state.context.highlightedId ?? void 0,
      "aria-labelledby": menu_dom.dom.getTriggerId(state.context),
      "data-placement": state.context.currentPlacement,
      onPointerEnter(event) {
        if (event.pointerType !== "mouse")
          return;
        send("MENU_POINTERENTER");
      },
      onKeyDown(event) {
        if (!domQuery.isSelfEvent(event))
          return;
        const item = menu_dom.dom.getFocusedItem(state.context);
        const isLink = !!item?.matches("a[href]");
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          ArrowLeft() {
            send("ARROW_LEFT");
          },
          ArrowRight() {
            send("ARROW_RIGHT");
          },
          Enter() {
            if (isLink)
              item?.click();
            send("ENTER");
          },
          Space(event2) {
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              keyMap.Enter?.(event2);
            }
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          },
          Tab(event2) {
            send({ type: "TAB", shiftKey: event2.shiftKey, loop: false });
          }
        };
        const key = domEvent.getEventKey(event, { dir: state.context.dir });
        const exec = keyMap[key];
        if (exec) {
          const allow = isLink && key === "Enter";
          exec(event);
          if (!allow) {
            event.preventDefault();
          }
        } else {
          const isSingleKey = event.key.length === 1;
          const isValidTypeahead = isSingleKey && !domEvent.isModifiedEvent(event) && !domQuery.isEditableElement(item);
          if (!isValidTypeahead)
            return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    separatorProps: normalize.element({
      ...menu_anatomy.parts.separator.attrs,
      role: "separator",
      "aria-orientation": "horizontal"
    }),
    getItemProps(options) {
      const { id, disabled, valueText } = options;
      return normalize.element({
        ...menu_anatomy.parts.item.attrs,
        id,
        role: "menuitem",
        "aria-disabled": disabled,
        "data-disabled": domQuery.dataAttr(disabled),
        "data-ownedby": menu_dom.dom.getContentId(state.context),
        "data-focus": domQuery.dataAttr(state.context.highlightedId === id),
        "data-valuetext": valueText,
        onClick(event) {
          if (disabled)
            return;
          send({ type: "ITEM_CLICK", src: "click", target: event.currentTarget, id });
        },
        onPointerDown(event) {
          if (disabled)
            return;
          send({ type: "ITEM_POINTERDOWN", target: event.currentTarget, id });
        },
        onPointerUp(event) {
          const evt = domEvent.getNativeEvent(event);
          if (!domEvent.isLeftClick(evt) || disabled)
            return;
          send({ type: "ITEM_CLICK", src: "pointerup", target: event.currentTarget, id });
        },
        onPointerLeave(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERLEAVE", target: event.currentTarget });
        },
        onPointerMove(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERMOVE", id, target: event.currentTarget });
        },
        onDragStart(event) {
          const isLink = event.currentTarget.matches("a[href]");
          if (isLink)
            event.preventDefault();
        },
        onAuxClick(event) {
          if (disabled)
            return;
          event.preventDefault();
          send({ type: "ITEM_CLICK", src: "auxclick", target: event.currentTarget, id });
        }
      });
    },
    getOptionItemProps(option) {
      const { name, type, disabled, onCheckedChange } = option;
      option.id ??= option.value;
      option.valueText ??= option.value;
      const checked = api.isOptionChecked(option);
      return Object.assign(
        api.getItemProps(option),
        normalize.element({
          "data-type": type,
          "data-name": name,
          ...menu_anatomy.parts.optionItem.attrs,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!checked,
          "data-checked": domQuery.dataAttr(checked),
          onClick(event) {
            if (disabled)
              return;
            send({ type: "ITEM_CLICK", src: "click", target: event.currentTarget, option });
            onCheckedChange?.(!checked);
          },
          onPointerUp(event) {
            const evt = domEvent.getNativeEvent(event);
            if (!domEvent.isLeftClick(evt) || disabled)
              return;
            send({ type: "ITEM_CLICK", src: "pointerup", target: event.currentTarget, option });
            onCheckedChange?.(!checked);
          },
          onAuxClick(event) {
            if (disabled)
              return;
            event.preventDefault();
            send({ type: "ITEM_CLICK", src: "auxclick", target: event.currentTarget, option });
            onCheckedChange?.(!checked);
          }
        })
      );
    },
    getItemGroupLabelProps(options) {
      return normalize.element({
        id: menu_dom.dom.getGroupLabelId(state.context, options.htmlFor),
        ...menu_anatomy.parts.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(options) {
      return normalize.element({
        id: menu_dom.dom.getGroupId(state.context, options.id),
        ...menu_anatomy.parts.itemGroup.attrs,
        "aria-labelledby": options.id,
        role: "group"
      });
    }
  };
  return api;
}

exports.connect = connect;
