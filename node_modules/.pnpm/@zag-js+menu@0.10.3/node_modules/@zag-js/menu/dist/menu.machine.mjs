import { createMachine, ref, guards } from '@zag-js/core';
import { trackDismissableElement } from '@zag-js/dismissable';
import { getByTypeahead, contains, isEditableElement, raf } from '@zag-js/dom-query';
import { addDomEvent } from '@zag-js/dom-event';
import { getPlacement, getBasePlacement } from '@zag-js/popper';
import { isPointInPolygon, getElementPolygon } from '@zag-js/rect-utils';
import { compact, cast, isArray, remove, add } from '@zag-js/utils';
import { dom } from './menu.dom.mjs';

const { not, and } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "menu",
      initial: "idle",
      context: {
        highlightedId: null,
        hoverId: null,
        parent: null,
        children: cast(ref({})),
        intentPolygon: null,
        loop: false,
        suspendPointer: false,
        anchorPoint: null,
        closeOnSelect: true,
        focusTriggerOnClose: true,
        ...ctx,
        typeahead: getByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "applyAnchorPoint"
      },
      on: {
        SET_PARENT: {
          actions: "setParentMenu"
        },
        SET_CHILD: {
          actions: "setChildMenu"
        },
        OPEN: {
          target: "open",
          actions: "invokeOnOpen"
        },
        OPEN_AUTOFOCUS: {
          internal: true,
          target: "open",
          actions: ["focusFirstItem", "invokeOnOpen"]
        },
        CLOSE: {
          target: "closed",
          actions: "invokeOnClose"
        },
        RESTORE_FOCUS: {
          actions: "restoreFocus"
        },
        SET_VALUE: {
          actions: ["setOptionValue", "invokeOnValueChange"]
        },
        SET_HIGHLIGHTED_ID: {
          actions: "setFocusedItem"
        }
      },
      states: {
        idle: {
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_FOCUS: {
              guard: not("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          after: {
            LONG_PRESS_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            CONTEXT_MENU_CANCEL: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        opening: {
          after: {
            SUBMENU_OPEN_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            BLUR: {
              target: "closed",
              actions: "invokeOnClose"
            },
            TRIGGER_POINTERLEAVE: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        closing: {
          tags: ["visible"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus", "invokeOnClose"]
            }
          },
          on: {
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus"]
            }
          }
        },
        closed: {
          entry: ["clearFocusedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: {
              target: "open",
              actions: ["focusFirstItem", "invokeOnOpen"]
            },
            ARROW_UP: {
              target: "open",
              actions: ["focusLastItem", "invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["visible"],
          activities: ["trackInteractOutside", "trackPositioning"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            TRIGGER_CLICK: {
              guard: not("isTriggerItem"),
              target: "closed",
              actions: "invokeOnClose"
            },
            TAB: [
              {
                guard: "isForwardTabNavigation",
                actions: ["focusNextItem"]
              },
              { actions: ["focusPrevItem"] }
            ],
            ARROW_UP: {
              actions: ["focusPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["focusNextItem", "focusMenu"]
            },
            ARROW_LEFT: {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            },
            HOME: {
              actions: ["focusFirstItem", "focusMenu"]
            },
            END: {
              actions: ["focusLastItem", "focusMenu"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: "invokeOnClose"
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemFocused",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemFocused",
                actions: "openSubmenu"
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickFocusedItem"
              },
              {
                actions: "clickFocusedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: and(not("suspendPointer"), not("isTargetFocused")),
                actions: ["focusItem", "focusMenu"]
              },
              {
                guard: not("isTargetFocused"),
                actions: "setHoveredItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and(not("suspendPointer"), not("isTriggerItem")),
              actions: "clearFocusedItem"
            },
            ITEM_CLICK: [
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: [
                  "invokeOnSelect",
                  "changeOptionValue",
                  "invokeOnValueChange",
                  "closeRootMenu",
                  "invokeOnClose"
                ]
              },
              {
                guard: and(not("isTriggerItemFocused"), not("isFocusedItemEditable")),
                actions: ["invokeOnSelect", "changeOptionValue", "invokeOnValueChange"]
              },
              { actions: "focusItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "focusItem"
            },
            TYPEAHEAD: {
              actions: "focusMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            SET_POSITIONING: {
              actions: "setPositioning"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!(evt.option?.closeOnSelect ?? ctx2.closeOnSelect),
        isMenuFocused: (ctx2) => {
          const menu = dom.getContentEl(ctx2);
          const activeElement = dom.getActiveElement(ctx2);
          return contains(menu, activeElement);
        },
        isTargetFocused: (ctx2, evt) => ctx2.highlightedId === evt.target.id,
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemFocused: (ctx2, evt) => {
          const target = evt.target ?? dom.getFocusedItem(ctx2);
          return !!target?.hasAttribute("aria-controls");
        },
        isForwardTabNavigation: (_ctx, evt) => !evt.shiftKey,
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isFocusedItemEditable: (ctx2) => isEditableElement(dom.getFocusedItem(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              ctx2.focusTriggerOnClose = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        applyAnchorPoint(ctx2) {
          const point = ctx2.anchorPoint;
          if (!point)
            return;
          const el = dom.getPositionerEl(ctx2);
          if (!el)
            return;
          raf(() => {
            Object.assign(el.style, {
              position: "absolute",
              top: "0",
              left: "0",
              transform: `translate3d(${point.x}px, ${point.y}px, 0)`
            });
          });
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        setPositioning(ctx2, evt) {
          const getPositionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false
          });
        },
        invokeOnValueChange(ctx2, evt) {
          if (!ctx2.value)
            return;
          const name = evt.name ?? evt.option?.name;
          if (!name)
            return;
          const values = ctx2.value[name];
          const valueAsArray = isArray(values) ? Array.from(values) : values;
          ctx2.onValueChange?.({ name, value: valueAsArray });
        },
        setOptionValue(ctx2, evt) {
          if (!ctx2.value)
            return;
          ctx2.value[evt.name] = evt.value;
        },
        changeOptionValue(ctx2, evt) {
          if (!evt.option || !ctx2.value)
            return;
          const { value, type, name } = evt.option;
          const values = ctx2.value[name];
          if (type === "checkbox" && isArray(values)) {
            ctx2.value[name] = values.includes(value) ? remove(values, value) : add(values, value);
          } else {
            ctx2.value[name] = value;
          }
        },
        clickFocusedItem(ctx2) {
          dom.getFocusedItem(ctx2)?.click();
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon)
            return;
          const rightSide = getBasePlacement(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setFocusedItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        clearFocusedItem(ctx2) {
          ctx2.highlightedId = null;
        },
        focusMenu(ctx2) {
          raf(() => {
            const activeEl = dom.getActiveElement(ctx2);
            const contentEl = dom.getContentEl(ctx2);
            if (contains(contentEl, activeEl))
              return;
            contentEl?.focus({ preventScroll: true });
          });
        },
        focusFirstItem(ctx2) {
          const first = dom.getFirstEl(ctx2);
          if (!first)
            return;
          ctx2.highlightedId = first.id;
        },
        focusLastItem(ctx2) {
          const last = dom.getLastEl(ctx2);
          if (!last)
            return;
          ctx2.highlightedId = last.id;
        },
        focusNextItem(ctx2, evt) {
          const next = dom.getNextEl(ctx2, evt.loop);
          ctx2.highlightedId = next?.id ?? null;
        },
        focusPrevItem(ctx2, evt) {
          const prev = dom.getPrevEl(ctx2, evt.loop);
          ctx2.highlightedId = prev?.id ?? null;
        },
        invokeOnSelect(ctx2) {
          if (!ctx2.highlightedId)
            return;
          ctx2.onSelect?.({ value: ctx2.highlightedId });
        },
        focusItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.focusTriggerOnClose)
            return;
          raf(() => dom.getTriggerEl(ctx2)?.focus({ preventScroll: true }));
        },
        focusMatchedItem(ctx2, evt) {
          const node = dom.getElemByKey(ctx2, evt.key);
          if (node)
            ctx2.highlightedId = node.id;
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom.getFocusedItem(ctx2);
          const id = item?.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child?.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          ctx2.parent?.send("FOCUS_MENU");
        },
        setHoveredItem(ctx2, evt) {
          ctx2.hoverId = evt.id;
        },
        restoreFocus(ctx2) {
          if (!ctx2.hoverId)
            return;
          ctx2.highlightedId = ctx2.hoverId;
          ctx2.hoverId = null;
        },
        restoreParentFocus(ctx2) {
          ctx2.parent?.send("RESTORE_FOCUS");
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpen?.();
        },
        invokeOnClose(ctx2) {
          ctx2.onClose?.();
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent?.send("CLOSE");
}

export { machine };
