// src/get-typeof-literal.ts
var getTypeOfLiteral = (value) => {
  if (Array.isArray(value))
    return "array";
  if (typeof value === "string")
    return "string";
  if (typeof value === "number")
    return "number";
  if (typeof value === "boolean")
    return "boolean";
  if (value === null)
    return "null";
  if (value === void 0)
    return "undefined";
  throw new Error(`Unexpected literal type: ${value}`);
};

// src/utils.ts
import { Node } from "ts-morph";
var isNotNullish = (element) => element != null;
var isNullish = (element) => element == null;
var isObject = (value) => value != null && typeof value === "object";
var isArray = (value) => Array.isArray(value);
var isPrimitiveType = (value) => {
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean" || value === null || value === void 0;
};
var unwrapExpression = (node) => {
  if (Node.isAsExpression(node)) {
    return unwrapExpression(node.getExpression());
  }
  if (Node.isParenthesizedExpression(node)) {
    return unwrapExpression(node.getExpression());
  }
  if (Node.isNonNullExpression(node)) {
    return unwrapExpression(node.getExpression());
  }
  if (Node.isTypeAssertion(node)) {
    return unwrapExpression(node.getExpression());
  }
  return node;
};
var getComponentName = (node) => {
  return node.getTagNameNode().getText();
};
var whitespaceRegex = /\s+/g;
var trimWhitespace = (str) => {
  return str.replaceAll(whitespaceRegex, " ");
};

// src/get-node-range.ts
var getNodeRange = (node) => {
  const src = node.getSourceFile();
  const [startPosition, endPosition] = [node.getStart(), node.getEnd()];
  const startInfo = src.getLineAndColumnAtPos(startPosition);
  const endInfo = src.getLineAndColumnAtPos(endPosition);
  return {
    startPosition,
    startLineNumber: startInfo.line,
    startColumn: startInfo.column,
    endPosition,
    endLineNumber: endInfo.line,
    endColumn: endInfo.column
  };
};

// src/box-factory.ts
var BoxNodeType = class {
  type;
  stack = [];
  node;
  constructor(definition) {
    this.type = definition.type;
    this.node = definition.node;
    this.stack = [...definition.stack ?? []];
  }
  getNode() {
    return this.node;
  }
  getStack() {
    return this.stack;
  }
  getRange = () => getNodeRange(this.node);
  toJSON() {
    const range = this.getRange();
    return {
      type: this.type,
      // @ts-expect-error
      value: this.value,
      node: this.node.getKindName(),
      line: range.startLineNumber,
      column: range.startColumn
    };
  }
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
};
var BoxNodeObject = class extends BoxNodeType {
  value;
  isEmpty;
  constructor(definition) {
    super(definition);
    this.value = definition.value;
    this.isEmpty = definition.isEmpty;
  }
};
var BoxNodeLiteral = class extends BoxNodeType {
  value;
  kind;
  constructor(definition) {
    super(definition);
    this.value = definition.value;
    this.kind = definition.kind;
  }
};
var BoxNodeMap = class extends BoxNodeType {
  value;
  spreadConditions;
  constructor(definition) {
    super(definition);
    this.value = definition.value;
  }
};
var BoxNodeArray = class extends BoxNodeType {
  value;
  constructor(definition) {
    super(definition);
    this.value = definition.value;
  }
};
var BoxNodeUnresolvable = class extends BoxNodeType {
};
var BoxNodeConditional = class extends BoxNodeType {
  whenTrue;
  whenFalse;
  constructor(definition) {
    super(definition);
    this.whenTrue = definition.whenTrue;
    this.whenFalse = definition.whenFalse;
  }
};
var BoxNodeEmptyInitializer = class extends BoxNodeType {
};
var isBoxNode = (value) => value instanceof BoxNodeType;

// src/to-box-node.ts
import { match } from "ts-pattern";
function toBoxNode(value, node, stack) {
  return match(value).when(isNullish, () => void 0).when(isBoxNode, (value2) => value2).when(isObject, (value2) => {
    return box.object(value2, node, stack);
  }).when(isArray, (value2) => {
    if (value2.length === 1)
      return toBoxNode(value2[0], node, stack);
    return value2.map((item) => toBoxNode(item, node, stack));
  }).when(isPrimitiveType, (value2) => box.literal(value2, node, stack)).otherwise(() => void 0);
}

// src/box.ts
var box = {
  object(value, node, stack) {
    return new BoxNodeObject({ type: "object", value, node, stack });
  },
  literal(value, node, stack) {
    return new BoxNodeLiteral({ type: "literal", value, kind: getTypeOfLiteral(value), node, stack });
  },
  map(value, node, stack) {
    return new BoxNodeMap({ type: "map", value, node, stack });
  },
  array(value, node, stack) {
    return new BoxNodeArray({ type: "array", value, node, stack });
  },
  conditional(whenTrue, whenFalse, node, stack) {
    return new BoxNodeConditional({ type: "conditional", whenTrue, whenFalse, node, stack });
  },
  from: toBoxNode,
  //
  emptyObject: (node, stack) => {
    return new BoxNodeObject({ type: "object", value: {}, isEmpty: true, node, stack });
  },
  emptyInitializer: (node, stack) => {
    return new BoxNodeEmptyInitializer({ type: "empty-initializer", node, stack });
  },
  unresolvable: (node, stack) => {
    return new BoxNodeUnresolvable({ type: "unresolvable", node, stack });
  },
  /**
   * box.type === “object” -> object that was resolved using ts-evaluator, most likely from a
   * complex condition OR a simple CallExpression eval result, we don’t have access to individual
   * AST nodes here so we need the distinction
   */
  isObject(value) {
    return value?.type === "object";
  },
  isLiteral(value) {
    return value?.type === "literal";
  },
  /**
   * box.type === “map” -> basically any object that was statically analyzable, we store each
   * prop + value in a Map
   */
  isMap(value) {
    return value?.type === "map";
  },
  isArray(value) {
    return value?.type === "array";
  },
  isUnresolvable(value) {
    return value?.type === "unresolvable";
  },
  isConditional(value) {
    return value?.type === "conditional";
  },
  isEmptyInitializer(value) {
    return value?.type === "empty-initializer";
  },
  isNumberLiteral(node) {
    return box.isLiteral(node) && node.kind === "number";
  },
  hasValue: (node) => {
    return box.isObject(node) || box.isLiteral(node) || box.isMap(node) || box.isArray(node);
  }
};

// src/call-expression.ts
import { match as match4 } from "ts-pattern";

// src/maybe-box-node.ts
import { Bool as Bool2 } from "lil-fp";
import { Node as Node6, ts as ts2 } from "ts-morph";
import { match as match3 } from "ts-pattern";

// src/evaluate-node.ts
import { evaluate } from "ts-evaluator";
import { ts } from "ts-morph";
var TsEvalError = Symbol("EvalError");
var cacheMap = /* @__PURE__ */ new WeakMap();
var evaluateNode = (node, stack, ctx) => {
  if (ctx.flags?.skipEvaluate)
    return;
  if (ctx.canEval && !ctx.canEval?.(node, stack))
    return;
  if (cacheMap.has(node)) {
    return cacheMap.get(node);
  }
  const result = evaluate({
    policy: {
      deterministic: true,
      network: false,
      console: false,
      maxOps: Number.POSITIVE_INFINITY,
      maxOpDuration: 1e3,
      io: { read: true, write: false },
      process: { exit: false, spawnChild: false }
    },
    ...ctx.getEvaluateOptions?.(node, stack),
    node: node.compilerNode,
    typescript: ts
  });
  const expr = result.success ? result.value : TsEvalError;
  cacheMap.set(node, expr);
  return expr;
};
var safeEvaluateNode = (node, stack, ctx) => {
  const result = evaluateNode(node, stack, ctx);
  if (result === TsEvalError)
    return;
  return result;
};

// src/find-identifier-value-declaration.ts
import { Node as Node3 } from "ts-morph";
function isScope(node) {
  return Node3.isFunctionDeclaration(node) || Node3.isFunctionExpression(node) || Node3.isArrowFunction(node) || Node3.isSourceFile(node);
}
function getDeclarationFor(node, stack, ctx) {
  const parent = node.getParent();
  if (!parent)
    return;
  const declarationStack = [];
  let declaration;
  if ((Node3.isVariableDeclaration(parent) || Node3.isParameterDeclaration(parent) || Node3.isFunctionDeclaration(parent) || Node3.isBindingElement(parent)) && parent.getNameNode() == node) {
    declarationStack.push(parent);
    declaration = parent;
  } else if (Node3.isImportSpecifier(parent) && parent.getNameNode() == node) {
    if (ctx.flags?.skipTraverseFiles)
      return;
    const sourceFile = getModuleSpecifierSourceFile(parent.getImportDeclaration());
    if (sourceFile) {
      const exportStack = [parent, sourceFile];
      const maybeVar = getExportedVarDeclarationWithName(node.getText(), sourceFile, exportStack, ctx);
      if (maybeVar) {
        declarationStack.push(...exportStack.concat(maybeVar));
        declaration = maybeVar;
      }
    }
  }
  if (declaration) {
    stack.push(...declarationStack);
  }
  return declaration;
}
var getInnermostScope = (from) => {
  let scope = from.getParent();
  while (scope && !isScope(scope)) {
    scope = scope.getParent();
  }
  return scope;
};
function findIdentifierValueDeclaration(identifier, stack, ctx, visitedsWithStack = /* @__PURE__ */ new Map()) {
  let scope = identifier;
  let foundNode;
  let isUnresolvable = false;
  let count = 0;
  const innerStack = [];
  do {
    scope = getInnermostScope(scope);
    count++;
    if (!scope)
      return;
    const refName = identifier.getText();
    scope.forEachDescendant((node, traversal) => {
      if (visitedsWithStack.has(node)) {
        traversal.skip();
        innerStack.push(...visitedsWithStack.get(node));
        return;
      }
      if (node == identifier)
        return;
      visitedsWithStack.set(node, innerStack);
      if (Node3.isIdentifier(node) && node.getText() == refName) {
        const declarationStack = [node];
        const maybeDeclaration = getDeclarationFor(node, declarationStack, ctx);
        if (maybeDeclaration) {
          if (Node3.isParameterDeclaration(maybeDeclaration)) {
            const initializer = maybeDeclaration.getInitializer();
            const typeNode = maybeDeclaration.getTypeNode();
            if (initializer) {
              innerStack.push(...declarationStack.concat(initializer));
              foundNode = maybeDeclaration;
            } else if (typeNode && Node3.isTypeLiteral(typeNode)) {
              innerStack.push(...declarationStack.concat(typeNode));
              foundNode = maybeDeclaration;
            } else {
              isUnresolvable = true;
            }
            traversal.stop();
            return;
          }
          innerStack.push(...declarationStack);
          foundNode = maybeDeclaration;
          traversal.stop();
        }
      }
    });
    if (foundNode || isUnresolvable) {
      if (foundNode) {
        stack.push(...innerStack);
      }
      return foundNode;
    }
  } while (scope && !Node3.isSourceFile(scope) && !foundNode && !isUnresolvable && count < 100);
}

// src/get-object-literal-expression-prop-pairs.ts
import { Node as Node5 } from "ts-morph";

// src/get-property-name.ts
import { Bool } from "lil-fp";
import { Node as Node4 } from "ts-morph";
import { match as match2 } from "ts-pattern";
var getPropertyName = (property, stack, ctx) => {
  return match2(property).when(Node4.isPropertyAssignment, (property2) => {
    const node = unwrapExpression(property2.getNameNode());
    return match2(node).when(Node4.isIdentifier, (node2) => box.from(node2.getText(), node2, stack)).when(Node4.isComputedPropertyName, (node2) => {
      const expression = node2.getExpression();
      stack.push(expression);
      return maybePropName(expression, stack, ctx);
    }).when(
      Bool.or(Node4.isStringLiteral, Node4.isNumericLiteral),
      (node2) => box.from(node2.getLiteralText(), node2, stack)
    ).otherwise(() => void 0);
  }).when(Node4.isShorthandPropertyAssignment, (property2) => {
    const name = property2.getName();
    if (name != null)
      return box.from(name, property2, stack);
  }).otherwise(() => void 0);
};

// src/get-object-literal-expression-prop-pairs.ts
var getObjectLiteralExpressionPropPairs = (expression, expressionStack, ctx, matchProp) => {
  const properties = expression.getProperties();
  if (properties.length === 0) {
    return box.emptyObject(expression, expressionStack);
  }
  const extractedPropValues = [];
  const spreadConditions = [];
  properties.forEach((property) => {
    const stack = [...expressionStack];
    stack.push(property);
    if (Node5.isPropertyAssignment(property) || Node5.isShorthandPropertyAssignment(property)) {
      const propNameBox = getPropertyName(property, stack, ctx);
      if (!propNameBox)
        return;
      const propName = propNameBox.value;
      if (isNullish(propName))
        return;
      if (matchProp && !matchProp?.({ propName, propNode: property })) {
        return;
      }
      if (Node5.isShorthandPropertyAssignment(property)) {
        const initializer2 = property.getNameNode();
        stack.push(initializer2);
        const maybeValue2 = maybeBoxNode(initializer2, stack, ctx);
        if (maybeValue2) {
          extractedPropValues.push([propName.toString(), maybeValue2]);
          return;
        }
      }
      const init = property.getInitializer();
      if (!init)
        return;
      const initializer = unwrapExpression(init);
      stack.push(initializer);
      const maybeValue = maybeBoxNode(initializer, stack, ctx);
      if (maybeValue) {
        extractedPropValues.push([propName.toString(), maybeValue]);
        return;
      }
    }
    if (Node5.isSpreadAssignment(property)) {
      const initializer = unwrapExpression(property.getExpression());
      stack.push(initializer);
      const maybeObject = maybeBoxNode(initializer, stack, ctx, matchProp);
      if (!maybeObject)
        return;
      if (box.isObject(maybeObject)) {
        Object.entries(maybeObject.value).forEach(([propName, value]) => {
          const boxNode = box.from(value, initializer, stack);
          if (!boxNode)
            return;
          extractedPropValues.push([propName, boxNode]);
        });
        return;
      }
      if (box.isMap(maybeObject)) {
        maybeObject.value.forEach((nested, propName) => {
          extractedPropValues.push([propName, nested]);
        });
        return;
      }
      if (box.isConditional(maybeObject)) {
        spreadConditions.push(maybeObject);
      }
    }
  });
  const orderedMapValue = /* @__PURE__ */ new Map();
  extractedPropValues.forEach(([propName, value]) => {
    if (orderedMapValue.has(propName)) {
      orderedMapValue.delete(propName);
    }
    orderedMapValue.set(propName, value);
  });
  const map = box.map(orderedMapValue, expression, expressionStack);
  if (spreadConditions.length > 0) {
    map.spreadConditions = spreadConditions;
  }
  return map;
};

// src/maybe-box-node.ts
var cacheMap2 = /* @__PURE__ */ new WeakMap();
var isCached = (node) => cacheMap2.has(node);
var getCached = (node) => cacheMap2.get(node);
var isPlusSyntax = (op) => op === ts2.SyntaxKind.PlusToken;
var isLogicalSyntax = (op) => op === ts2.SyntaxKind.BarBarToken || op === ts2.SyntaxKind.QuestionQuestionToken || op === ts2.SyntaxKind.AmpersandAmpersandToken || op === ts2.SyntaxKind.EqualsEqualsEqualsToken || op === ts2.SyntaxKind.EqualsEqualsToken || op === ts2.SyntaxKind.ExclamationEqualsEqualsToken || op === ts2.SyntaxKind.ExclamationEqualsToken || op === ts2.SyntaxKind.GreaterThanEqualsToken || op === ts2.SyntaxKind.GreaterThanToken || op === ts2.SyntaxKind.LessThanEqualsToken || op === ts2.SyntaxKind.LessThanToken || op === ts2.SyntaxKind.InstanceOfKeyword || op === ts2.SyntaxKind.InKeyword;
var isOperationSyntax = (op) => op === ts2.SyntaxKind.AsteriskToken || op === ts2.SyntaxKind.SlashToken || op === ts2.SyntaxKind.PercentToken || op === ts2.SyntaxKind.AsteriskAsteriskToken || op === ts2.SyntaxKind.MinusToken;
var canReturnWhenTrueInLogicalExpression = (op) => {
  return op === ts2.SyntaxKind.BarBarToken || op === ts2.SyntaxKind.QuestionQuestionToken;
};
function maybeBoxNode(node, stack, ctx, matchProp) {
  const cache = (value) => {
    cacheMap2.set(node, value);
    return value;
  };
  return match3(node).when(isCached, getCached).when(Bool2.or(Node6.isStringLiteral, Node6.isNoSubstitutionTemplateLiteral), (node2) => {
    const value = trimWhitespace(node2.getLiteralValue());
    return cache(box.literal(value, node2, stack));
  }).when(Node6.isObjectLiteralExpression, (node2) => {
    return cache(getObjectLiteralExpressionPropPairs(node2, stack, ctx, matchProp));
  }).when(Bool2.or(Node6.isTrueLiteral, Node6.isFalseLiteral), (node2) => {
    const value = node2.getLiteralValue();
    return cache(box.literal(value, node2, stack));
  }).when(Node6.isNumericLiteral, (node2) => {
    const value = node2.getLiteralValue();
    return cache(box.literal(value, node2, stack));
  }).when(Node6.isNullLiteral, (node2) => {
    return cache(box.literal(null, node2, stack));
  }).when(Node6.isPrefixUnaryExpression, (node2) => {
    const operand = node2.getOperand();
    const operator = node2.getOperatorToken();
    const boxNode = maybeBoxNode(operand, stack, ctx);
    if (!box.isNumberLiteral(boxNode))
      return;
    return cache(operator === ts2.SyntaxKind.MinusToken ? box.literal(-Number(boxNode.value), node2, stack) : boxNode);
  }).when(Node6.isArrayLiteralExpression, (node2) => {
    const boxNodes = node2.getElements().map((element) => {
      return maybeBoxNode(element, stack, ctx) ?? cache(box.unresolvable(element, stack));
    });
    return cache(box.array(boxNodes, node2, stack));
  }).when(Node6.isIdentifier, (node2) => {
    return match3(node2.getText()).with("undefined", () => cache(box.literal(void 0, node2, stack))).otherwise(() => cache(maybeIdentifierValue(node2, stack, ctx)));
  }).when(Node6.isTemplateHead, (node2) => {
    return cache(box.literal(node2.getLiteralText(), node2, stack));
  }).when(Node6.isTemplateExpression, (node2) => {
    const value = maybeTemplateStringValue(node2, stack, ctx);
    return cache(box.literal(value, node2, stack));
  }).when(Node6.isTaggedTemplateExpression, (node2) => {
    return cache(maybeBoxNode(node2.getTemplate(), stack, ctx));
  }).when(Node6.isElementAccessExpression, (node2) => {
    return cache(getElementAccessedExpressionValue(node2, stack, ctx));
  }).when(Node6.isPropertyAccessExpression, (node2) => {
    return cache(getPropertyAccessedExpressionValue(node2, [], stack, ctx));
  }).when(Node6.isConditionalExpression, (node2) => {
    if (ctx.flags?.skipConditions) {
      return cache(box.unresolvable(node2, stack));
    }
    const condExpr = unwrapExpression(node2.getCondition());
    const condBoxNode = (Node6.isIdentifier(condExpr) ? maybeBoxNode(condExpr, [], ctx) : safeEvaluateNode(condExpr, stack, ctx)) ?? box.unresolvable(condExpr, stack);
    const condValue = isBoxNode(condBoxNode) ? condBoxNode : box.from(condBoxNode, node2, stack);
    if (box.isEmptyInitializer(condValue))
      return;
    if (box.isUnresolvable(condValue) || box.isConditional(condValue)) {
      const whenTrueExpr = unwrapExpression(node2.getWhenTrue());
      const whenFalseExpr2 = unwrapExpression(node2.getWhenFalse());
      return cache(maybeResolveConditionalExpression({ whenTrueExpr, whenFalseExpr: whenFalseExpr2, node: node2, stack }, ctx));
    }
    if (condValue.value) {
      const whenTrueExpr = unwrapExpression(node2.getWhenTrue());
      const innerStack2 = [...stack];
      const maybeValue2 = maybeBoxNode(whenTrueExpr, innerStack2, ctx);
      return cache(maybeValue2 ?? box.unresolvable(whenTrueExpr, stack));
    }
    const whenFalseExpr = unwrapExpression(node2.getWhenFalse());
    const innerStack = [...stack];
    const maybeValue = maybeBoxNode(whenFalseExpr, innerStack, ctx);
    return cache(maybeValue ?? box.unresolvable(node2, stack));
  }).when(Node6.isCallExpression, (node2) => {
    const value = safeEvaluateNode(node2, stack, ctx);
    if (!value)
      return;
    return cache(box.from(value, node2, stack));
  }).when(Node6.isBinaryExpression, (node2) => {
    const operatorKind = node2.getOperatorToken().getKind();
    return match3(operatorKind).when(isPlusSyntax, () => {
      const value = tryComputingPlusTokenBinaryExpressionToString(node2, stack, ctx) ?? safeEvaluateNode(node2, stack, ctx);
      if (!value)
        return;
      return cache(box.from(value, node2, stack));
    }).when(isLogicalSyntax, (op) => {
      const whenTrueExpr = unwrapExpression(node2.getLeft());
      const whenFalseExpr = unwrapExpression(node2.getRight());
      const exprObject = {
        whenTrueExpr,
        whenFalseExpr,
        node: node2,
        stack,
        canReturnWhenTrue: canReturnWhenTrueInLogicalExpression(op)
      };
      return cache(maybeResolveConditionalExpression(exprObject, ctx));
    }).when(isOperationSyntax, () => {
      return cache(box.literal(safeEvaluateNode(node2, stack, ctx), node2, stack));
    }).otherwise(() => void 0);
  }).otherwise(() => void 0);
}
var onlyStringLiteral = (boxNode) => {
  if (!boxNode)
    return;
  if (isBoxNode(boxNode) && box.isLiteral(boxNode) && typeof boxNode.value === "string") {
    return boxNode;
  }
};
var onlyNumberLiteral = (boxNode) => {
  if (!boxNode)
    return;
  if (isBoxNode(boxNode) && box.isLiteral(boxNode) && typeof boxNode.value === "number") {
    return boxNode;
  }
};
var maybeStringLiteral = (node, stack, ctx) => onlyStringLiteral(maybeBoxNode(node, stack, ctx));
var maybePropName = (node, stack, ctx) => {
  const boxed = maybeBoxNode(node, stack, ctx);
  const strBox = onlyStringLiteral(boxed);
  if (strBox)
    return strBox;
  const numberBox = onlyNumberLiteral(boxed);
  if (numberBox)
    return numberBox;
};
var maybeResolveConditionalExpression = ({
  whenTrueExpr,
  whenFalseExpr,
  node,
  stack,
  canReturnWhenTrue
}, ctx) => {
  const whenTrueValue = maybeBoxNode(whenTrueExpr, stack, ctx);
  const whenFalseValue = maybeBoxNode(whenFalseExpr, stack, ctx);
  if (canReturnWhenTrue && whenTrueValue && !box.isUnresolvable(whenTrueValue)) {
    return whenTrueValue;
  }
  if (Node6.isBinaryExpression(node) && node.getOperatorToken().getKind() === ts2.SyntaxKind.AmpersandAmpersandToken && whenTrueValue && whenFalseValue && box.isLiteral(whenTrueValue) && whenTrueValue.value === true) {
    return whenFalseValue;
  }
  if (!whenTrueValue && !whenFalseValue) {
    return;
  }
  if (whenTrueValue && !whenFalseValue) {
    return whenTrueValue;
  }
  if (!whenTrueValue && whenFalseValue) {
    return whenFalseValue;
  }
  const whenTrue = whenTrueValue;
  const whenFalse = whenFalseValue;
  if (box.isLiteral(whenTrue) && box.isLiteral(whenFalse) && whenTrue.value === whenFalse.value) {
    return whenTrue;
  }
  return box.conditional(whenTrue, whenFalse, node, stack);
};
var findProperty = (node, propName, _stack, ctx) => {
  const stack = [..._stack];
  if (Node6.isPropertyAssignment(node)) {
    const name = node.getNameNode();
    if (Node6.isIdentifier(name) && name.getText() === propName) {
      stack.push(name);
      return node;
    }
    if (Node6.isStringLiteral(name) && name.getLiteralText() === propName) {
      stack.push(name);
      return name.getLiteralText();
    }
    if (Node6.isComputedPropertyName(name)) {
      const expression = unwrapExpression(name.getExpression());
      const computedPropNameBox = maybePropName(expression, stack, ctx);
      if (!computedPropNameBox)
        return;
      if (String(computedPropNameBox.value) === propName) {
        stack.push(name, expression);
        return node;
      }
    }
  }
  if (Node6.isShorthandPropertyAssignment(node)) {
    const name = node.getNameNode();
    if (Node6.isIdentifier(name) && name.getText() === propName) {
      stack.push(name);
      return node;
    }
  }
};
var getObjectLiteralPropValue = (initializer, accessList, _stack, ctx) => {
  const stack = [..._stack];
  const propName = accessList.pop();
  const property = initializer.getProperty(propName) ?? initializer.getProperties().find((p) => findProperty(p, propName, stack, ctx));
  if (!property)
    return;
  stack.push(property);
  if (Node6.isPropertyAssignment(property)) {
    const propInit = property.getInitializer();
    if (!propInit)
      return;
    if (Node6.isObjectLiteralExpression(propInit)) {
      if (accessList.length > 0) {
        return getObjectLiteralPropValue(propInit, accessList, stack, ctx);
      }
      return maybeBoxNode(propInit, stack, ctx);
    }
    const maybePropValue = maybeBoxNode(propInit, stack, ctx);
    if (maybePropValue) {
      return maybePropValue;
    }
  }
  if (Node6.isShorthandPropertyAssignment(property)) {
    const identifier = property.getNameNode();
    if (accessList.length > 0) {
      return maybePropIdentifierValue(identifier, accessList, stack, ctx);
    }
    const maybePropValue = maybeBoxNode(identifier, stack, ctx);
    if (maybePropValue) {
      return maybePropValue;
    }
  }
};
var maybeTemplateStringValue = (template, stack, ctx) => {
  const head = template.getHead();
  const tail = template.getTemplateSpans();
  const headValue = maybeStringLiteral(head, stack, ctx);
  if (!headValue)
    return;
  const tailValues = tail.map((t) => {
    const expression = t.getExpression();
    const propBox = maybePropName(expression, stack, ctx);
    if (!propBox)
      return;
    const literal = t.getLiteral();
    return propBox.value + literal.getLiteralText();
  });
  if (tailValues.every(isNotNullish)) {
    return headValue.value + tailValues.join("");
  }
};
var maybeBindingElementValue = (def, stack, propName, ctx) => {
  const parent = def.getParent();
  if (!parent)
    return;
  const grandParent = parent.getParent();
  if (!grandParent)
    return;
  if (Node6.isArrayBindingPattern(parent)) {
    const index = parent.getChildIndex();
    if (Number.isNaN(index))
      return;
    if (Node6.isVariableDeclaration(grandParent)) {
      const init = grandParent.getInitializer();
      if (!init)
        return;
      const initializer = unwrapExpression(init);
      if (!Node6.isArrayLiteralExpression(initializer))
        return;
      const element = initializer.getElements()[index + 1];
      if (!element)
        return;
      const innerStack = [...stack, initializer, element];
      const maybeObject = maybeBoxNode(element, innerStack, ctx);
      if (!maybeObject)
        return;
      if (box.isObject(maybeObject)) {
        const propValue2 = maybeObject.value[propName];
        return box.from(propValue2, element, innerStack);
      }
      if (!box.isMap(maybeObject)) {
        return maybeObject;
      }
      const propValue = maybeObject.value.get(propName);
      if (!propValue)
        return;
      return propValue;
    }
  }
  if (Node6.isObjectBindingPattern(parent)) {
  }
};
function maybePropDefinitionValue(def, accessList, _stack, ctx) {
  const propName = accessList.at(-1);
  if (Node6.isVariableDeclaration(def)) {
    const init = def.getInitializer();
    if (!init) {
      const type = def.getTypeNode();
      if (!type)
        return;
      if (Node6.isTypeLiteral(type)) {
        if (accessList.length > 0) {
          const stack = [..._stack];
          stack.push(type);
          let propName2 = accessList.pop();
          let typeProp = type.getProperty(propName2);
          let typeLiteral = typeProp?.getTypeNode();
          while (typeProp && accessList.length > 0 && typeLiteral && Node6.isTypeLiteral(typeLiteral)) {
            stack.push(typeProp, typeLiteral);
            propName2 = accessList.pop();
            typeProp = typeLiteral.getProperty(propName2);
            typeLiteral = typeProp?.getTypeNode();
          }
          if (!typeLiteral)
            return;
          const typeValue = getTypeNodeValue(typeLiteral, stack, ctx);
          return box.from(typeValue, typeLiteral, stack);
        }
        const propValue = getTypeLiteralNodePropValue(type, propName, _stack, ctx);
        _stack.push(type);
        return box.from(propValue, type, _stack);
      }
      return;
    }
    const initializer = unwrapExpression(init);
    if (Node6.isObjectLiteralExpression(initializer)) {
      const propValue = getObjectLiteralPropValue(initializer, accessList, _stack, ctx);
      if (!propValue)
        return;
      _stack.push(initializer);
      return propValue;
    }
    if (Node6.isArrayLiteralExpression(initializer)) {
      const index = Number(propName);
      if (Number.isNaN(index))
        return;
      const element = initializer.getElements()[index];
      if (!element)
        return;
      _stack.push(initializer);
      const boxed = maybeBoxNode(element, _stack, ctx);
      if (boxed && isBoxNode(boxed) && box.isLiteral(boxed)) {
        return boxed;
      }
    }
    const innerStack = [..._stack, initializer];
    const maybeValue = maybeBoxNode(initializer, innerStack, ctx);
    if (maybeValue)
      return maybeValue;
  }
  if (Node6.isBindingElement(def)) {
    const value = maybeBindingElementValue(def, _stack, propName, ctx);
    if (value)
      return value;
  }
}
var maybePropIdentifierValue = (identifier, accessList, _stack, ctx) => {
  const maybeValueDeclaration = findIdentifierValueDeclaration(identifier, _stack, ctx);
  if (!maybeValueDeclaration) {
    return box.unresolvable(identifier, _stack);
  }
  const maybeValue = maybePropDefinitionValue(maybeValueDeclaration, accessList, _stack, ctx);
  if (maybeValue)
    return maybeValue;
  return box.unresolvable(identifier, _stack);
};
var typeLiteralCache = /* @__PURE__ */ new WeakMap();
var getTypeLiteralNodePropValue = (type, propName, stack, ctx) => {
  if (typeLiteralCache.has(type)) {
    const map = typeLiteralCache.get(type);
    if (map === null)
      return;
    if (map?.has(propName)) {
      return map.get(propName);
    }
  }
  const members = type.getMembers();
  const prop = members.find((member) => Node6.isPropertySignature(member) && member.getName() === propName);
  if (Node6.isPropertySignature(prop) && prop.isReadonly()) {
    const propType = prop.getTypeNode();
    if (!propType) {
      typeLiteralCache.set(type, null);
      return;
    }
    const propValue = getTypeNodeValue(propType, stack, ctx);
    if (isNotNullish(propValue)) {
      if (!typeLiteralCache.has(type)) {
        typeLiteralCache.set(type, /* @__PURE__ */ new Map());
      }
      const map = typeLiteralCache.get(type);
      map.set(propName, propValue);
      return propValue;
    }
  }
  typeLiteralCache.set(type, null);
};
function getNameLiteral(wrapper) {
  if (Node6.isStringLiteral(wrapper))
    return wrapper.getLiteralText();
  return wrapper.getText();
}
var typeNodeCache = /* @__PURE__ */ new WeakMap();
var getTypeNodeValue = (type, stack, ctx) => {
  if (typeNodeCache.has(type)) {
    return typeNodeCache.get(type);
  }
  if (Node6.isLiteralTypeNode(type)) {
    const literal = type.getLiteral();
    if (Node6.isStringLiteral(literal)) {
      const result = literal.getLiteralText();
      typeNodeCache.set(type, result);
      return result;
    }
  }
  if (Node6.isTypeLiteral(type)) {
    const members = type.getMembers();
    if (!members.some((member) => !Node6.isPropertySignature(member) || !member.isReadonly())) {
      const props = members;
      const entries = props.map((member) => {
        const nameNode = member.getNameNode();
        const nameText = nameNode.getText();
        const name = getNameLiteral(nameNode);
        if (!name)
          return;
        const value = getTypeLiteralNodePropValue(type, nameText, stack, ctx);
        return [name, value];
      }).filter(isNotNullish);
      const result = Object.fromEntries(entries);
      typeNodeCache.set(type, result);
      return result;
    }
  }
  typeNodeCache.set(type, void 0);
};
var maybeDefinitionValue = (def, stack, ctx) => {
  if (Node6.isShorthandPropertyAssignment(def)) {
    const propNameNode = def.getNameNode();
    return maybePropIdentifierValue(propNameNode, [propNameNode.getText()], stack, ctx);
  }
  if (Node6.isVariableDeclaration(def)) {
    const init = def.getInitializer();
    if (!init) {
      const type = def.getTypeNode();
      if (!type)
        return;
      if (Node6.isTypeLiteral(type)) {
        stack.push(type);
        const maybeTypeValue = getTypeNodeValue(type, stack, ctx);
        if (isNotNullish(maybeTypeValue))
          return box.from(maybeTypeValue, def, stack);
      }
      return box.unresolvable(def, stack);
    }
    const initializer = unwrapExpression(init);
    const innerStack = [...stack, initializer];
    const maybeValue = maybeBoxNode(initializer, innerStack, ctx);
    if (maybeValue)
      return maybeValue;
  }
  if (Node6.isBindingElement(def)) {
    const init = def.getInitializer();
    if (!init) {
      const nameNode = def.getPropertyNameNode() ?? def.getNameNode();
      const propName = nameNode.getText();
      const innerStack2 = [...stack, nameNode];
      const value = maybeBindingElementValue(def, innerStack2, propName, ctx);
      if (value)
        return value;
      return box.unresolvable(def, stack);
    }
    const initializer = unwrapExpression(init);
    const innerStack = [...stack, initializer];
    const maybeValue = maybeBoxNode(initializer, innerStack, ctx);
    if (maybeValue)
      return maybeValue;
  }
};
var getExportedVarDeclarationWithName = (varName, sourceFile, stack, ctx) => {
  const maybeVar = sourceFile.getVariableDeclaration(varName);
  if (maybeVar)
    return maybeVar;
  const exportDeclaration = resolveVarDeclarationFromExportWithName(varName, sourceFile, stack, ctx);
  if (!exportDeclaration)
    return;
  return exportDeclaration;
};
var hasNamedExportWithName = (name, exportDeclaration) => {
  const namedExports = exportDeclaration.getNamedExports();
  if (namedExports.length === 0)
    return true;
  for (const namedExport of namedExports) {
    const exportedName = namedExport.getNameNode().getText();
    if (exportedName === name) {
      return true;
    }
  }
};
var getModuleSpecifierSourceFile = (declaration) => {
  const project = declaration.getProject();
  const moduleName = declaration.getModuleSpecifierValue();
  if (!moduleName)
    return;
  const containingFile = declaration.getSourceFile().getFilePath();
  const resolved = ts2.resolveModuleName(
    moduleName,
    containingFile,
    project.getCompilerOptions(),
    project.getModuleResolutionHost()
  );
  if (!resolved.resolvedModule)
    return;
  const sourceFile = project.addSourceFileAtPath(resolved.resolvedModule.resolvedFileName);
  return sourceFile;
};
function resolveVarDeclarationFromExportWithName(symbolName, sourceFile, stack, ctx) {
  for (const exportDeclaration of sourceFile.getExportDeclarations()) {
    const exportStack = [exportDeclaration];
    if (!hasNamedExportWithName(symbolName, exportDeclaration))
      continue;
    const maybeFile = getModuleSpecifierSourceFile(exportDeclaration);
    if (!maybeFile)
      continue;
    exportStack.push(maybeFile);
    const maybeVar = getExportedVarDeclarationWithName(symbolName, maybeFile, stack, ctx);
    if (maybeVar) {
      stack.push(...exportStack.concat(maybeVar));
      return maybeVar;
    }
  }
}
var maybeIdentifierValue = (identifier, _stack, ctx) => {
  const valueDeclaration = findIdentifierValueDeclaration(identifier, _stack, ctx);
  if (!valueDeclaration) {
    return box.unresolvable(identifier, _stack);
  }
  const declaration = unwrapExpression(valueDeclaration);
  const stack = [..._stack];
  const maybeValue = maybeDefinitionValue(declaration, stack, ctx);
  if (maybeValue)
    return maybeValue;
  return box.unresolvable(identifier, stack);
};
var tryComputingPlusTokenBinaryExpressionToString = (node, stack, ctx) => {
  const left = unwrapExpression(node.getLeft());
  const right = unwrapExpression(node.getRight());
  const leftValue = maybePropName(left, stack, ctx);
  const rightValue = maybePropName(right, stack, ctx);
  if (!leftValue || !rightValue)
    return;
  if (isNotNullish(leftValue.value) && isNotNullish(rightValue.value)) {
    return box.literal(String(leftValue.value) + String(rightValue.value), node, stack);
  }
};
var getElementAccessedExpressionValue = (expression, _stack, ctx) => {
  const elementAccessed = unwrapExpression(expression.getExpression());
  const argExpr = expression.getArgumentExpression();
  if (!argExpr)
    return;
  const arg = unwrapExpression(argExpr);
  const stack = [..._stack, elementAccessed, arg];
  const argLiteral = maybePropName(arg, stack, ctx);
  if (Node6.isIdentifier(elementAccessed) && argLiteral) {
    if (!isNotNullish(argLiteral.value))
      return;
    return maybePropIdentifierValue(elementAccessed, [argLiteral.value.toString()], stack, ctx);
  }
  if (Node6.isBinaryExpression(arg)) {
    if (arg.getOperatorToken().getKind() !== ts2.SyntaxKind.PlusToken)
      return;
    const propName = tryComputingPlusTokenBinaryExpressionToString(arg, stack, ctx) ?? maybePropName(arg, stack, ctx);
    if (propName && Node6.isIdentifier(elementAccessed)) {
      if (!isNotNullish(propName.value))
        return;
      return maybePropIdentifierValue(elementAccessed, [propName.value.toString()], stack, ctx);
    }
  }
  if (Node6.isTemplateExpression(arg)) {
    const propName = maybeTemplateStringValue(arg, stack, ctx);
    if (propName && Node6.isIdentifier(elementAccessed)) {
      return maybePropIdentifierValue(elementAccessed, [propName], stack, ctx);
    }
  }
  if (Node6.isObjectLiteralExpression(elementAccessed) && argLiteral) {
    if (!isNotNullish(argLiteral.value))
      return;
    return getObjectLiteralPropValue(elementAccessed, [argLiteral.value.toString()], stack, ctx);
  }
  if (Node6.isPropertyAccessExpression(arg)) {
    return getPropertyAccessedExpressionValue(arg, [], stack, ctx);
  }
  if (Node6.isPropertyAccessExpression(elementAccessed) && argLiteral && isNotNullish(argLiteral.value)) {
    const propRefValue = getPropertyAccessedExpressionValue(elementAccessed, [], stack, ctx);
    if (!propRefValue)
      return box.unresolvable(elementAccessed, stack);
    const propName = argLiteral.value.toString();
    if (box.isObject(propRefValue)) {
      const propValue = propRefValue.value[propName];
      return box.from(propValue, arg, stack);
    }
    if (box.isMap(propRefValue)) {
      const propValue = propRefValue.value.get(propName);
      return box.from(propValue, arg, stack);
    }
    if (box.isArray(propRefValue)) {
      const propValue = propRefValue.value[Number(propName)];
      return box.from(propValue, arg, stack);
    }
    return box.unresolvable(elementAccessed, stack);
  }
  if (Node6.isIdentifier(elementAccessed) && Node6.isElementAccessExpression(arg)) {
    const propName = getElementAccessedExpressionValue(arg, stack, ctx);
    if (typeof propName === "string" && isNotNullish(propName)) {
      return maybePropIdentifierValue(elementAccessed, [propName], stack, ctx);
    }
  }
  if (Node6.isElementAccessExpression(elementAccessed) && argLiteral && isNotNullish(argLiteral.value)) {
    const identifier = getElementAccessedExpressionValue(elementAccessed, stack, ctx);
    if (isObject(identifier)) {
      const argValue = argLiteral.value.toString();
      if (box.isMap(identifier)) {
        const maybeValue = identifier.value.get(argValue);
        return maybeValue;
      }
      if (box.isObject(identifier)) {
        const maybeLiteralValue = identifier.value[argValue];
        if (!maybeLiteralValue)
          return;
        return box.from(maybeLiteralValue, expression, stack);
      }
    }
  }
  if (Node6.isArrayLiteralExpression(elementAccessed) && argLiteral) {
    return getArrayElementValueAtIndex(elementAccessed, Number(argLiteral.value), stack, ctx);
  }
  if (Node6.isConditionalExpression(arg)) {
    if (ctx.flags?.skipConditions)
      return box.unresolvable(arg, stack);
    const propName = maybePropName(arg, stack, ctx);
    if (isNotNullish(propName) && isNotNullish(propName.value)) {
      if (Node6.isIdentifier(elementAccessed)) {
        return maybePropIdentifierValue(elementAccessed, [propName.value.toString()], stack, ctx);
      }
    }
    const whenTrueExpr = unwrapExpression(arg.getWhenTrue());
    const whenFalseExpr = unwrapExpression(arg.getWhenFalse());
    const whenTrueValue = maybePropName(whenTrueExpr, stack, ctx);
    const whenFalseValue = maybePropName(whenFalseExpr, stack, ctx);
    if (Node6.isIdentifier(elementAccessed)) {
      const whenTrueResolved = whenTrueValue && isNotNullish(whenTrueValue.value) ? maybePropIdentifierValue(elementAccessed, [whenTrueValue.value.toString()], stack, ctx) : void 0;
      const whenFalseResolved = whenFalseValue && isNotNullish(whenFalseValue.value) ? maybePropIdentifierValue(elementAccessed, [whenFalseValue.value.toString()], stack, ctx) : void 0;
      if (!whenTrueResolved && !whenFalseResolved) {
        return;
      }
      if (whenTrueResolved && !whenFalseResolved) {
        return whenTrueResolved;
      }
      if (!whenTrueResolved && whenFalseResolved) {
        return whenFalseResolved;
      }
      return box.conditional(whenTrueResolved, whenFalseResolved, arg, stack);
    }
  }
};
var getArrayElementValueAtIndex = (array, index, stack, ctx) => {
  const element = array.getElements()[index];
  if (!element)
    return;
  const value = maybeBoxNode(element, stack, ctx);
  if (isNotNullish(value)) {
    return value;
  }
};
var getPropertyAccessedExpressionValue = (expression, _accessList, stack, ctx) => {
  const propName = expression.getName();
  const elementAccessed = unwrapExpression(expression.getExpression());
  const accessList = _accessList.concat(propName);
  stack.push(elementAccessed);
  if (Node6.isIdentifier(elementAccessed)) {
    return maybePropIdentifierValue(elementAccessed, accessList, stack, ctx);
  }
  if (Node6.isPropertyAccessExpression(elementAccessed)) {
    const propValue = getPropertyAccessedExpressionValue(elementAccessed, accessList, stack, ctx);
    return propValue;
  }
  if (Node6.isElementAccessExpression(elementAccessed)) {
    const leftElementAccessed = getElementAccessedExpressionValue(elementAccessed, stack, ctx);
    if (!leftElementAccessed)
      return;
    if (box.isObject(leftElementAccessed)) {
      const propValue = leftElementAccessed.value[propName];
      return box.from(propValue, expression, stack);
    }
    if (box.isMap(leftElementAccessed)) {
      const propValue = leftElementAccessed.value.get(propName);
      return box.from(propValue, expression, stack);
    }
  }
};

// src/call-expression.ts
var trueFn = () => true;
var extractCallExpressionArguments = (node, ctx, matchProp = trueFn, matchArg = trueFn) => {
  const fnArguments = node.getArguments();
  const fnName = node.getExpression().getText();
  if (fnArguments.length === 0) {
    return box.array([], node, []);
  }
  return box.array(
    fnArguments.map((argument, index) => {
      const argNode = unwrapExpression(argument);
      const stack = [node, argNode];
      return match4(argNode).when(
        (argNode2) => matchArg({ fnNode: node, fnName, argNode: argNode2, index }),
        (argNode2) => maybeBoxNode(argNode2, stack, ctx, matchProp) ?? box.unresolvable(argNode2, stack)
      ).otherwise(() => box.unresolvable(argNode, stack));
    }),
    node,
    []
  );
};

// src/extract.ts
import { Arr, Bool as Bool3, Opt, cast, noop, pipe } from "lil-fp";
import { Node as Node8 } from "ts-morph";
import { match as match6 } from "ts-pattern";

// src/jsx-attribute.ts
import { Node as Node7 } from "ts-morph";
import { P, match as match5 } from "ts-pattern";
var extractJsxAttribute = (jsxAttribute, ctx) => {
  const initializer = jsxAttribute.getInitializer();
  const stack = [jsxAttribute, initializer];
  return match5(initializer).with(P.nullish, () => {
    const nameNode = jsxAttribute.getNameNode();
    return box.emptyInitializer(nameNode, stack);
  }).when(Node7.isStringLiteral, (initializer2) => {
    const literalText = initializer2.getLiteralText();
    return box.literal(trimWhitespace(literalText), initializer2, stack);
  }).when(Node7.isJsxExpression, (initializer2) => {
    const expr = initializer2.getExpression();
    if (!expr)
      return;
    const expression = unwrapExpression(expr);
    if (!expression)
      return;
    stack.push(expression);
    const maybeValue = maybeBoxNode(expression, stack, ctx);
    if (maybeValue)
      return maybeValue;
  }).otherwise(() => void 0);
};

// src/jsx-spread-attribute.ts
var extractJsxSpreadAttributeValues = (node, ctx, matchProp) => {
  const expr = unwrapExpression(node.getExpression());
  const stack = [];
  return maybeBoxNode(expr, stack, ctx, matchProp);
};

// src/object-like-to-map.ts
var objectLikeToMap = (maybeObject, node) => {
  if (!maybeObject) {
    return /* @__PURE__ */ new Map();
  }
  if (!isBoxNode(maybeObject)) {
    return new Map(Object.entries(maybeObject));
  }
  if (box.isUnresolvable(maybeObject) || box.isConditional(maybeObject)) {
    return /* @__PURE__ */ new Map();
  }
  if (box.isMap(maybeObject)) {
    return maybeObject.value;
  }
  return new Map(
    Object.entries(maybeObject.value).map(([key, value]) => {
      const boxed = box.from(value, maybeObject.getNode() ?? node, maybeObject.getStack() ?? []);
      return [key, boxed || null];
    }).filter(([, value]) => value !== null)
  );
};

// src/extract.ts
var isImportOrExport = Bool3.or(Node8.isImportDeclaration, Node8.isExportDeclaration);
var extract = ({ ast, ...ctx }) => {
  const { components, functions, taggedTemplates } = ctx;
  const byName = /* @__PURE__ */ new Map();
  const componentByNode = /* @__PURE__ */ new Map();
  let componentNode;
  let componentName;
  let isFactory;
  let boxByProp;
  let component;
  ast.forEachDescendant((node, traversal) => {
    if (isImportOrExport(node)) {
      traversal.skip();
      return;
    }
    if (components) {
      if (Node8.isJsxOpeningElement(node) || Node8.isJsxSelfClosingElement(node)) {
        componentNode = node;
        componentName = getComponentName(componentNode);
        isFactory = componentName.includes(".");
        if (!components.matchTag({ tagNode: componentNode, tagName: componentName, isFactory })) {
          componentNode = void 0;
          return;
        }
        if (!byName.has(componentName)) {
          byName.set(componentName, { kind: "component", nodesByProp: /* @__PURE__ */ new Map(), queryList: [] });
        }
        boxByProp = byName.get(componentName).nodesByProp;
        if (!componentByNode.has(componentNode)) {
          componentByNode.set(componentNode, { name: componentName, props: /* @__PURE__ */ new Map(), conditionals: [] });
        }
        component = componentByNode.get(componentNode);
      }
      if (Node8.isJsxSpreadAttribute(node)) {
        if (!componentNode || !component)
          return;
        const matchProp = ({ propName, propNode }) => components.matchProp({ tagNode: componentNode, tagName: componentName, propName, propNode });
        const spreadNode = extractJsxSpreadAttributeValues(node, ctx, cast(matchProp));
        if (!spreadNode)
          return;
        const processObjectLike = (objLike) => {
          const mapValue = objectLikeToMap(objLike, node);
          const isMap = box.isMap(objLike);
          const boxNode = box.map(mapValue, node, [componentNode]);
          if (isMap && objLike.spreadConditions?.length) {
            boxNode.spreadConditions = objLike.spreadConditions;
          }
          mapValue.forEach((propValue, propName) => {
            if (matchProp({ propName, propNode: node })) {
              component.props.set(propName, propValue);
              boxByProp.set(propName, (boxByProp.get(propName) ?? []).concat(propValue));
            }
          });
        };
        const processBoxNode = (boxNode) => {
          return match6(boxNode).when(box.isConditional, (boxNode2) => {
            component.conditionals.push(boxNode2);
          }).when(Bool3.or(box.isObject, box.isMap), (boxNode2) => {
            return processObjectLike(boxNode2);
          }).otherwise(noop);
        };
        processBoxNode(spreadNode);
        return;
      }
      if (Node8.isJsxAttribute(node)) {
        if (!componentNode || !component)
          return;
        const propName = node.getNameNode().getText();
        if (!components.matchProp({ tagNode: componentNode, tagName: componentName, propName, propNode: node })) {
          return;
        }
        pipe(
          extractJsxAttribute(node, ctx),
          Opt.fromNullable,
          Opt.tap((maybeBox) => {
            component.props.set(propName, maybeBox);
            boxByProp.set(propName, (boxByProp.get(propName) ?? []).concat(maybeBox));
          })
        );
      }
    }
    if (functions && Node8.isCallExpression(node)) {
      const expr = node.getExpression();
      const fnName = Node8.isCallExpression(expr) ? expr.getExpression().getText() : expr.getText();
      if (!functions.matchFn({ fnNode: node, fnName }))
        return;
      const matchProp = ({ propName, propNode }) => functions.matchProp({ fnNode: node, fnName, propName, propNode });
      if (!byName.has(fnName)) {
        byName.set(fnName, { kind: "function", nodesByProp: /* @__PURE__ */ new Map(), queryList: [] });
      }
      const fnResultMap = byName.get(fnName);
      const boxByProp2 = fnResultMap.nodesByProp;
      const boxNodeArray = extractCallExpressionArguments(node, ctx, matchProp, functions.matchArg);
      const nodeList = pipe(
        boxNodeArray.value,
        Arr.map(
          (boxNode) => match6(boxNode).when(Bool3.or(box.isObject, box.isMap), (boxNode2) => {
            const mapValue = objectLikeToMap(boxNode2, node);
            const isMap = box.isMap(boxNode2);
            mapValue.forEach((propValue, propName) => {
              if (isMap ? true : matchProp({ propName, propNode: node })) {
                boxByProp2.set(propName, (boxByProp2.get(propName) ?? []).concat(propValue));
              }
            });
            const boxMap = box.map(mapValue, node, boxNode2.getStack());
            if (box.isMap(boxNode2) && boxNode2.spreadConditions?.length) {
              boxMap.spreadConditions = boxNode2.spreadConditions;
            }
            return boxMap;
          }).otherwise((boxNode2) => boxNode2)
        )
      );
      const query = {
        kind: "call-expression",
        name: fnName,
        box: box.array(nodeList, node, [])
      };
      fnResultMap.queryList.push(query);
    }
    if (taggedTemplates && Node8.isTaggedTemplateExpression(node)) {
      const tag = node.getTag();
      const fnName = Node8.isCallExpression(tag) ? tag.getExpression().getText() : tag.getText();
      if (!taggedTemplates.matchTaggedTemplate({ taggedTemplateNode: node, fnName }))
        return;
      if (!byName.has(fnName)) {
        byName.set(fnName, { kind: "function", nodesByProp: /* @__PURE__ */ new Map(), queryList: [] });
      }
      const fnResultMap = byName.get(fnName);
      const query = {
        kind: "tagged-template",
        name: fnName,
        box: maybeBoxNode(node, [], ctx)
      };
      fnResultMap.queryList.push(query);
    }
  });
  componentByNode.forEach((parentRef, componentNode2) => {
    const component2 = componentByNode.get(componentNode2);
    if (!component2)
      return;
    const query = cast({
      name: parentRef.name,
      box: box.map(component2.props, componentNode2, [])
    });
    if (component2.conditionals?.length) {
      query.box.spreadConditions = component2.conditionals;
    }
    const componentName2 = parentRef.name;
    const queryList = byName.get(componentName2).queryList;
    queryList.push(query);
  });
  return byName;
};

// src/jsx-element-props.ts
import { Node as Node9 } from "ts-morph";
import { Bool as Bool4 } from "lil-fp";
var isObjectLike = Bool4.or(box.isObject, box.isMap);
var extractJsxElementProps = (node, ctx) => {
  const tagName = node.getTagNameNode().getText();
  const jsxAttributes = node.getAttributes();
  const props = /* @__PURE__ */ new Map();
  jsxAttributes.forEach((attrNode) => {
    if (Node9.isJsxAttribute(attrNode)) {
      const nameNode = attrNode.getNameNode();
      const maybeValue = extractJsxAttribute(attrNode, ctx);
      if (!maybeValue)
        return;
      props.set(nameNode.getText(), maybeValue);
      return;
    }
    if (Node9.isJsxSpreadAttribute(attrNode)) {
      const maybeValue = extractJsxSpreadAttributeValues(attrNode, ctx, () => true);
      if (!isObjectLike(maybeValue))
        return;
      if (box.isMap(maybeValue)) {
        maybeValue.value.forEach((value, propName) => {
          props.set(propName, value);
        });
      }
      if (box.isObject(maybeValue)) {
        Object.entries(maybeValue.value).forEach(([propName, value]) => {
          props.set(propName, box.literal(value, node, []));
        });
      }
    }
  });
  return { name: tagName, props };
};

// src/unbox.ts
import { Arr as Arr2, Bool as Bool5, pipe as pipe2 } from "lil-fp";
import { P as P2, match as match7 } from "ts-pattern";
var makeObjAt = (path, value) => {
  if (!path.length)
    return value;
  const obj = {};
  path.reduce((acc, key, i) => {
    const isLast = i === path.length - 1;
    acc[key] = isLast ? value : {};
    return isLast ? obj : acc[key];
  }, obj);
  return obj;
};
var getLiteralValue = (node, ctx) => {
  return match7(node).with(P2.nullish, () => void 0).when(box.isConditional, (node2) => {
    const path = ctx.path;
    const whenTrue = getLiteralValue(node2.whenTrue, Object.assign({}, ctx, { path, parent: node2 }));
    const whenFalse = getLiteralValue(node2.whenFalse, Object.assign({}, ctx, { path, parent: node2 }));
    if (whenTrue) {
      ctx.conditions.push(makeObjAt(path, whenTrue));
    }
    if (whenFalse) {
      ctx.conditions.push(makeObjAt(path, whenFalse));
    }
    return void 0;
  }).when(Bool5.or(box.isLiteral, box.isObject), (node2) => {
    return node2.value;
  }).when(box.isEmptyInitializer, () => {
    return true;
  }).when(box.isMap, (node2) => {
    if (node2.spreadConditions) {
      const path = ctx.path;
      node2.spreadConditions.forEach((spread) => {
        const whenTrue = getLiteralValue(spread.whenTrue, Object.assign({}, ctx, { path, parent: node2 }));
        const whenFalse = getLiteralValue(spread.whenFalse, Object.assign({}, ctx, { path, parent: node2 }));
        if (whenTrue) {
          ctx.spreadConditions.push(makeObjAt(path, whenTrue));
        }
        if (whenFalse) {
          ctx.spreadConditions.push(makeObjAt(path, whenFalse));
        }
      });
    }
    return pipe2(
      Arr2.from(node2.value.entries()),
      Arr2.map(([key, propNode]) => [
        key,
        getLiteralValue(propNode, Object.assign({}, ctx, { path: ctx.path.concat(key), parent: node2 }))
      ]),
      Arr2.filter(([, value]) => isNotNullish(value)),
      Object.fromEntries
    );
  }).when(box.isArray, (node2) => {
    let index = 0;
    return pipe2(
      node2.value,
      Arr2.map(
        (elementNode) => getLiteralValue(
          elementNode,
          Object.assign({}, ctx, { path: ctx.path.concat(String(index++)), parent: node2 })
        )
      ),
      Arr2.filter(isNotNullish),
      (v) => v.flat()
    );
  }).otherwise(() => void 0);
};
var cacheMap3 = /* @__PURE__ */ new WeakMap();
var createCache = (map) => ({
  value: map,
  has: (node) => map.has(node),
  get: (node) => map.get(node),
  set: (node, value) => map.set(node, value)
});
var unbox = (node, ctx) => {
  const _ctx = {
    cache: ctx?.cache ?? cacheMap3,
    ...ctx,
    path: [],
    parent: void 0,
    conditions: [],
    spreadConditions: []
  };
  const cache = createCache(_ctx.cache);
  const raw = match7(node).with(P2.nullish, () => void 0).when(cache.has, cache.get).when(Array.isArray, (node2) => {
    const value = pipe2(
      node2,
      Arr2.map((boxNode) => getLiteralValue(boxNode, _ctx)),
      Arr2.filter(isNotNullish),
      Arr2.head
    );
    cache.set(node2, value);
    return value;
  }).otherwise((node2) => {
    const value = getLiteralValue(node2, _ctx);
    cache.set(node2, value);
    return value;
  }) ?? {};
  return { raw, conditions: _ctx.conditions, spreadConditions: _ctx.spreadConditions };
};
export {
  BoxNodeArray,
  BoxNodeConditional,
  BoxNodeEmptyInitializer,
  BoxNodeLiteral,
  BoxNodeMap,
  BoxNodeObject,
  BoxNodeUnresolvable,
  box,
  extract,
  extractCallExpressionArguments,
  extractJsxAttribute,
  extractJsxElementProps,
  extractJsxSpreadAttributeValues,
  findIdentifierValueDeclaration,
  isBoxNode,
  maybeBoxNode,
  maybeIdentifierValue,
  unbox
};
