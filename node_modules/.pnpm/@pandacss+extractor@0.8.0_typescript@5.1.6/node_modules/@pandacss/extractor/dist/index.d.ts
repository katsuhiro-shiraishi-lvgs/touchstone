import * as ts_morph from 'ts-morph';
import { Node, CallExpression, JsxOpeningElement, JsxSelfClosingElement, Expression, SourceFile, TaggedTemplateExpression, PropertyAssignment, ShorthandPropertyAssignment, JsxAttribute, Identifier, JsxSpreadAttribute } from 'ts-morph';
import { EvaluateOptions } from 'ts-evaluator';

type WithNode = {
    node: Node;
    stack: Node[];
};
type ObjectType = WithNode & {
    type: 'object';
    value: EvaluatedObjectResult;
    isEmpty?: boolean;
};
type LiteralKind = 'array' | 'string' | 'number' | 'boolean' | 'null' | 'undefined';
type LiteralType = WithNode & {
    type: 'literal';
    value: PrimitiveType;
    kind: LiteralKind;
};
type MapType = WithNode & {
    type: 'map';
    value: MapTypeValue;
};
type ArrayType = WithNode & {
    type: 'array';
    value: BoxNode[];
};
type UnresolvableType = WithNode & {
    type: 'unresolvable';
};
type ConditionalType = WithNode & {
    type: 'conditional';
    whenTrue: BoxNode;
    whenFalse: BoxNode;
};
/** -> Jsx boolean attribute <Box flex /> */
type EmptyInitializerType = WithNode & {
    type: 'empty-initializer';
};
type BoxNodeDefinition = ObjectType | LiteralType | MapType | ArrayType | UnresolvableType | ConditionalType | EmptyInitializerType;
type BoxNode = BoxNodeObject | BoxNodeLiteral | BoxNodeMap | BoxNodeArray | BoxNodeUnresolvable | BoxNodeConditional | BoxNodeEmptyInitializer;
type MapTypeValue = Map<string, BoxNode>;
declare abstract class BoxNodeType$1<Definition extends BoxNodeDefinition = BoxNodeDefinition> {
    readonly type: Definition['type'];
    private readonly stack;
    private readonly node;
    constructor(definition: Definition);
    getNode(): Node;
    getStack(): Node[];
    getRange: () => {
        startPosition: number;
        startLineNumber: number;
        startColumn: number;
        endPosition: number;
        endLineNumber: number;
        endColumn: number;
    };
    toJSON(): {
        type: Definition["type"];
        value: any;
        node: string;
        line: number;
        column: number;
    };
    toString(): string;
}
declare class BoxNodeObject extends BoxNodeType$1<ObjectType> {
    value: ObjectType['value'];
    isEmpty: ObjectType['isEmpty'];
    constructor(definition: ObjectType);
}
declare class BoxNodeLiteral extends BoxNodeType$1<LiteralType> {
    value: LiteralType['value'];
    kind: LiteralType['kind'];
    constructor(definition: LiteralType);
}
declare class BoxNodeMap extends BoxNodeType$1<MapType> {
    value: MapType['value'];
    spreadConditions?: BoxNodeConditional[];
    constructor(definition: MapType);
}
declare class BoxNodeArray extends BoxNodeType$1<ArrayType> {
    value: ArrayType['value'];
    constructor(definition: ArrayType);
}
declare class BoxNodeUnresolvable extends BoxNodeType$1<UnresolvableType> {
}
declare class BoxNodeConditional extends BoxNodeType$1<ConditionalType> {
    whenTrue: ConditionalType['whenTrue'];
    whenFalse: ConditionalType['whenFalse'];
    constructor(definition: ConditionalType);
}
declare class BoxNodeEmptyInitializer extends BoxNodeType$1<EmptyInitializerType> {
}
declare const isBoxNode: (value: unknown) => value is BoxNode;

type PrimitiveType = string | number | boolean | null | undefined;
type LiteralObject = Record<string, any>;
type SingleLiteralValue = PrimitiveType | LiteralObject;
type LiteralValue = SingleLiteralValue | SingleLiteralValue[];
type EvaluatedObjectResult = Record<string, LiteralValue>;
type ExtractedFunctionInstance = {
    name: string;
    kind: 'call-expression';
    fromNode: () => CallExpression;
    box: BoxNodeArray;
};
type ExtractedTaggedTemplateInstance = {
    name: string;
    kind: 'tagged-template';
    fromNode: () => TaggedTemplateExpression;
    box: BoxNodeLiteral;
};
type ExtractedFunctionResult = {
    kind: 'function';
    nodesByProp: Map<string, BoxNode[]>;
    queryList: Array<ExtractedFunctionInstance | ExtractedTaggedTemplateInstance>;
};
type ExtractedComponentInstance = {
    name: string;
    fromNode: () => JsxOpeningElement | JsxSelfClosingElement;
    box: BoxNodeMap;
};
type ExtractedComponentResult = {
    kind: 'component';
    nodesByProp: Map<string, BoxNode[]>;
    queryList: ExtractedComponentInstance[];
};
type ExtractResultItem = ExtractedComponentResult | ExtractedFunctionResult;
type ExtractResultByName = Map<string, ExtractResultItem>;
type MatchTagArgs = {
    tagName: string;
    tagNode: JsxOpeningElement | JsxSelfClosingElement;
    isFactory: boolean;
};
type MatchPropArgs = {
    propName: string;
    propNode: JsxAttribute | undefined;
};
type MatchFnArgs = {
    fnName: string;
    fnNode: CallExpression;
};
type MatchFnArguments = {
    argNode: Node;
    index: number;
};
type MatchFnPropArgs = {
    propName: string;
    propNode: PropertyAssignment | ShorthandPropertyAssignment;
};
type FunctionMatchers = {
    matchFn: (element: MatchFnArgs) => boolean;
    matchArg: (arg: Pick<MatchFnArgs, 'fnName' | 'fnNode'> & MatchFnArguments) => boolean;
    matchProp: (prop: Pick<MatchFnArgs, 'fnName' | 'fnNode'> & MatchFnPropArgs) => boolean;
};
type ComponentMatchers = {
    matchTag: (element: MatchTagArgs) => boolean;
    matchProp: (prop: Pick<MatchTagArgs, 'tagName' | 'tagNode'> & MatchPropArgs) => boolean;
};
type MatchTaggedTemplateArgs = {
    fnName: string;
    taggedTemplateNode: TaggedTemplateExpression;
};
type MatchTaggedTemplate = (tag: MatchTaggedTemplateArgs) => boolean;
type BoxContext = {
    getEvaluateOptions?: (node: Expression, stack: Node[]) => EvaluateOptions;
    canEval?: (node: Expression, stack: Node[]) => boolean;
    flags?: {
        skipEvaluate?: boolean;
        skipTraverseFiles?: boolean;
        skipConditions?: boolean;
    };
};
type ExtractOptions = BoxContext & {
    ast: SourceFile;
    components?: ComponentMatchers;
    functions?: FunctionMatchers;
    taggedTemplates?: {
        matchTaggedTemplate: MatchTaggedTemplate;
    };
};

declare function toBoxNode<Value extends PrimitiveType>(value: Value, node: Node, stack: Node[]): BoxNodeLiteral;
declare function toBoxNode<Value extends EvaluatedObjectResult>(value: Value, node: Node, stack: Node[]): BoxNodeObject;
declare function toBoxNode<Value extends PrimitiveType[]>(value: Value, node: Node, stack: Node[]): BoxNodeLiteral[];
declare function toBoxNode<Value extends BoxNode | BoxNode[]>(value: Value, node: Node, stack: Node[]): Value;
declare function toBoxNode<Value extends LiteralValue>(value: Value, node: Node, stack: Node[]): Value extends unknown[] ? BoxNodeLiteral : Value extends PrimitiveType ? BoxNodeLiteral : BoxNodeObject;
declare function toBoxNode<Value extends PrimitiveType | BoxNode>(value: Value, node: Node, stack: Node[]): BoxNodeLiteral;

declare const box: {
    object(value: EvaluatedObjectResult, node: Node, stack: Node[]): BoxNodeObject;
    literal(value: PrimitiveType, node: Node, stack: Node[]): BoxNodeLiteral;
    map(value: MapTypeValue, node: Node, stack: Node[]): BoxNodeMap;
    array(value: BoxNode[], node: Node, stack: Node[]): BoxNodeArray;
    conditional(whenTrue: BoxNode, whenFalse: BoxNode, node: Node, stack: Node[]): BoxNodeConditional;
    from: typeof toBoxNode;
    emptyObject: (node: Node, stack: Node[]) => BoxNodeObject;
    emptyInitializer: (node: Node, stack: Node[]) => BoxNodeEmptyInitializer;
    unresolvable: (node: Node, stack: Node[]) => BoxNodeUnresolvable;
    /**
     * box.type === “object” -> object that was resolved using ts-evaluator, most likely from a
     * complex condition OR a simple CallExpression eval result, we don’t have access to individual
     * AST nodes here so we need the distinction
     */
    isObject(value: BoxNode | undefined): value is BoxNodeObject;
    isLiteral(value: BoxNode | undefined): value is BoxNodeLiteral;
    /**
     * box.type === “map” -> basically any object that was statically analyzable, we store each
     * prop + value in a Map
     */
    isMap(value: BoxNode | undefined): value is BoxNodeMap;
    isArray(value: BoxNode | undefined): value is BoxNodeArray;
    isUnresolvable(value: BoxNode | undefined): value is BoxNodeUnresolvable;
    isConditional(value: BoxNode | undefined): value is BoxNodeConditional;
    isEmptyInitializer(value: BoxNode | undefined): value is BoxNodeEmptyInitializer;
    isNumberLiteral(node: BoxNode | undefined): node is BoxNodeLiteral;
    hasValue: (node: BoxNode | undefined) => node is BoxNodeArray | BoxNodeLiteral | BoxNodeObject | BoxNodeMap;
};

type MatchProp$1 = (prop: MatchFnPropArgs) => boolean;
type MatchArg = (prop: MatchFnArgs & MatchFnArguments) => boolean;
declare const extractCallExpressionArguments: (node: CallExpression, ctx: BoxContext, matchProp?: MatchProp$1, matchArg?: MatchArg) => BoxNodeArray;

declare const extract: ({ ast, ...ctx }: ExtractOptions) => ExtractResultByName;

declare function getDeclarationFor(node: Identifier, stack: Node[], ctx: BoxContext): ts_morph.FunctionDeclaration | ts_morph.VariableDeclaration | ts_morph.ParameterDeclaration | ts_morph.BindingElement | undefined;
declare function findIdentifierValueDeclaration(identifier: Identifier, stack: Node[], ctx: BoxContext, visitedsWithStack?: WeakMap<Node, Node[]>): ReturnType<typeof getDeclarationFor> | undefined;

declare const getNodeRange: (node: Node) => {
    startPosition: number;
    startLineNumber: number;
    startColumn: number;
    endPosition: number;
    endLineNumber: number;
    endColumn: number;
};
type NodeRange = ReturnType<typeof getNodeRange>;

declare const extractJsxAttribute: (jsxAttribute: JsxAttribute, ctx: BoxContext) => BoxNode | undefined;

declare const extractJsxElementProps: (node: JsxOpeningElement | JsxSelfClosingElement, ctx: BoxContext) => {
    name: string;
    props: Map<string, BoxNode>;
};

type MaybeBoxNodeReturn = BoxNode | undefined;
declare function maybeBoxNode(node: Node, stack: Node[], ctx: BoxContext, matchProp?: (prop: MatchFnPropArgs) => boolean): MaybeBoxNodeReturn;
declare const maybeIdentifierValue: (identifier: Identifier, _stack: Node[], ctx: BoxContext) => BoxNode;

type MatchProp = (prop: MatchFnPropArgs | MatchPropArgs) => boolean;
declare const extractJsxSpreadAttributeValues: (node: JsxSpreadAttribute, ctx: BoxContext, matchProp: MatchProp) => MaybeBoxNodeReturn;

type BoxNodeType = BoxNode | BoxNode[] | undefined;
type CacheMap = WeakMap<BoxNode, unknown>;
type UnboxContext = {
    path: string[];
    parent: BoxNode | undefined;
    cache: CacheMap;
    /** @example <ColorBox color={unresolvableIdentifier ? "light.100" : "dark.200" } /> */
    conditions: LiteralObject[];
    /** @example <ColorBox {...(someCondition && { color: "blue.100" })} /> */
    spreadConditions: LiteralObject[];
};
type Unboxed = {
    raw: LiteralObject;
    conditions: LiteralObject[];
    spreadConditions: LiteralObject[];
};
declare const unbox: (node: BoxNodeType, ctx?: Pick<UnboxContext, 'cache'>) => Unboxed;

export { BoxContext, BoxNode, BoxNodeArray, BoxNodeConditional, BoxNodeEmptyInitializer, BoxNodeLiteral, BoxNodeMap, BoxNodeObject, BoxNodeUnresolvable, ExtractOptions, ExtractResultByName, ExtractResultItem, ExtractedComponentInstance, ExtractedComponentResult, ExtractedFunctionInstance, ExtractedFunctionResult, NodeRange, PrimitiveType, Unboxed, box, extract, extractCallExpressionArguments, extractJsxAttribute, extractJsxElementProps, extractJsxSpreadAttributeValues, findIdentifierValueDeclaration, isBoxNode, maybeBoxNode, maybeIdentifierValue, unbox };
