'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const date = require('@internationalized/date');

function parseDateString(date$1, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  const { year, month, day } = extract(regex, date$1) ?? {};
  if (year != null && year.length === 4 && month != null && +month <= 12 && day != null && +day <= 31) {
    return new date.CalendarDateTime(+year, +month, +day);
  }
  const time = Date.parse(date$1);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new date.CalendarDateTime(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new date.DateFormatter(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts.map(({ type, value }) => type === "literal" ? value : `((?!=<${type}>)\\d+)`).join("");
}
function extract(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g)?.map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)?.[1];
  }).reduce((acc, curr, index) => {
    if (!curr)
      return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}

exports.parseDateString = parseDateString;
