// src/atomic-rule.ts
import {
  esc,
  filterBaseConditions,
  isImportant,
  normalizeStyleObject,
  toHash,
  walkObject,
  withoutImportant
} from "@pandacss/shared";
import postcss4 from "postcss";

// src/to-css.ts
import postcss3 from "postcss";
import postcssNested from "postcss-nested";

// src/post-css-js/objectify.ts
import { camelCaseProperty } from "@pandacss/shared";

// src/unitless.ts
import { hypenateProperty } from "@pandacss/shared";
var keys = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  msGridRow: true,
  msGridRowSpan: true,
  msGridColumn: true,
  msGridColumnSpan: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  WebkitLineClamp: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var unitlessProperties = /* @__PURE__ */ new Set();
Object.keys(keys).forEach((key) => {
  unitlessProperties.add(key);
  unitlessProperties.add(hypenateProperty(key));
});

// src/post-css-js/objectify.ts
function atRule(node) {
  if (typeof node.nodes === "undefined")
    return true;
  return objectify(node);
}
function objectify(node) {
  let name;
  const result = {};
  node.each((child) => {
    if (child.type === "atrule") {
      name = "@" + child.name;
      if (child.params)
        name += " " + child.params;
      if (typeof result[name] === "undefined") {
        result[name] = atRule(child);
      } else if (Array.isArray(result[name])) {
        result[name].push(atRule(child));
      } else {
        result[name] = [result[name], atRule(child)];
      }
    } else if (child.type === "rule") {
      const body = objectify(child);
      if (result[child.selector]) {
        for (const i in body) {
          result[child.selector][i] = body[i];
        }
      } else {
        result[child.selector] = body;
      }
    } else if (child.type === "decl") {
      if (child.prop[0] === "-" && child.prop[1] === "-") {
        name = child.prop;
      } else {
        name = camelCaseProperty(child.prop);
      }
      let value = child.value;
      if (!isNaN(Number(value)) && unitlessProperties.has(name)) {
        value = parseFloat(child.value);
      }
      if (child.important)
        value += " !important";
      if (typeof result[name] === "undefined") {
        result[name] = value;
      } else if (Array.isArray(result[name])) {
        result[name].push(value);
      } else {
        result[name] = [result[name], value];
      }
    }
  });
  return result;
}

// src/post-css-js/parse.ts
import { hypenateProperty as hypenateProperty2 } from "@pandacss/shared";
import postcss from "postcss";
var IMPORTANT = /\s*!important\s*$/i;
function decl(parent, name, value) {
  if (value === false || value == null)
    return;
  const isCssVar = name.startsWith("--");
  if (!isCssVar) {
    name = hypenateProperty2(name);
  }
  if (typeof value === "number") {
    if (value === 0 || unitlessProperties.has(name) || isCssVar) {
      value = value.toString();
    } else {
      value = `${value}px`;
    }
  }
  if (name === "css-float")
    name = "float";
  if (IMPORTANT.test(value)) {
    value = value.replace(IMPORTANT, "");
    parent.push(postcss.decl({ prop: name, value, important: true }));
  } else {
    parent.push(postcss.decl({ prop: name, value }));
  }
}
function atRule2(parent, parts, value) {
  if (!parts)
    return;
  const node = postcss.atRule({ name: parts[1], params: parts[3] || "" });
  if (typeof value === "object") {
    node.nodes = [];
    parse(value, node);
  }
  parent.push(node);
}
var AT_RULE = /@(\S+)(\s+([\W\w]*)\s*)?/;
function parse(obj, parent) {
  let name, value, node;
  for (name in obj) {
    value = obj[name];
    if (value === null || typeof value === "undefined") {
      continue;
    } else if (name[0] === "@") {
      const parts = name.match(AT_RULE);
      if (Array.isArray(value)) {
        for (const i of value) {
          atRule2(parent, parts, i);
        }
      } else {
        atRule2(parent, parts, value);
      }
    } else if (Array.isArray(value)) {
      for (const i of value) {
        decl(parent, name, i);
      }
    } else if (typeof value === "object") {
      node = postcss.rule({ selector: name });
      parse(value, node);
      parent.push(node);
    } else {
      decl(parent, name, value);
    }
  }
}
var postCssPlugin = (obj) => {
  const root = postcss.root();
  parse(obj, root);
  return root;
};
var parser = postCssPlugin;

// src/post-css-js/index.ts
var postCssJs = {
  parser,
  objectify
};

// src/safe-parse.ts
import postcss2 from "postcss";
function safeParse(str) {
  try {
    return postcss2.parse(str);
  } catch (error) {
    return postcss2.root();
  }
}

// src/to-css.ts
function toCss(styles, { important } = {}) {
  const result = postcss3([
    postcssNested({
      bubble: ["breakpoint"]
    })
  ]).process(styles, {
    parser: postCssJs.parser
  });
  if (important) {
    result.root.walkDecls((decl2) => {
      decl2.important = true;
    });
  }
  return result;
}
function cssToJs(css) {
  return postCssJs.objectify(safeParse(css));
}

// src/atomic-rule.ts
var AtomicRule = class {
  constructor(context) {
    this.context = context;
    this.root = postcss4.root();
  }
  root;
  layer = "utilities";
  hashFn = (conditions, className) => {
    const { conditions: cond, hash, utility } = this.context;
    let result;
    if (hash) {
      const baseArray = [...cond.finalize(conditions), className];
      result = utility.formatClassName(toHash(baseArray.join(":")));
    } else {
      const baseArray = [...cond.finalize(conditions), utility.formatClassName(className)];
      result = baseArray.join(":");
    }
    return esc(result);
  };
  get rule() {
    return this.context.conditions.rule();
  }
  get transform() {
    return this.context?.transform ?? this.context.utility.transform;
  }
  process = (options) => {
    const { styles } = options;
    const { conditions: cond } = this.context;
    const styleObject = normalizeStyleObject(styles, this.context);
    if (typeof styleObject !== "object")
      return;
    const rule = this.rule;
    walkObject(styleObject, (value, paths) => {
      if (value == null)
        return;
      const important = isImportant(value);
      const [prop, ...allConditions] = cond.shift(paths);
      const conditions = filterBaseConditions(allConditions);
      const transformed = this.transform(prop, withoutImportant(value));
      const cssRoot = toCss(transformed.styles, { important });
      rule.nodes = cssRoot.root.nodes;
      if (rule.isEmpty)
        return;
      const selector = this.hashFn(conditions, transformed.className);
      rule.selector = important ? `.${selector}\\!` : `.${selector}`;
      rule.update();
      rule.applyConditions(conditions);
      if (transformed.layer) {
        const atRule4 = postcss4.atRule({
          name: "layer",
          params: transformed.layer,
          nodes: [rule.rule]
        });
        this.root.append(atRule4);
      } else {
        this.root.append(rule.rule);
      }
    });
    if (this.root.nodes.length === 0)
      return;
    const atRule3 = postcss4.atRule({
      name: "layer",
      params: this.layer,
      nodes: [this.root]
    });
    this.context.root.append(atRule3);
  };
  toCss = () => {
    return this.context.root.toString();
  };
};

// src/breakpoints.ts
import { capitalize, toEm, toPx } from "@pandacss/shared";
var Breakpoints = class {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
  }
  get sorted() {
    return sortBreakpoints(this.breakpoints);
  }
  get values() {
    return Object.fromEntries(this.sorted);
  }
  get keys() {
    return ["base", ...Object.keys(this.values)];
  }
  get = (name) => {
    return this.values[name];
  };
  build = ({ min, max }) => {
    if (min == null && max == null)
      return "";
    return ["screen", min && `(min-width: ${min})`, max && `(max-width: ${max})`].filter(Boolean).join(" and ");
  };
  up = (name) => {
    const { min } = this.get(name);
    return this.build({ min });
  };
  down = (name) => {
    const { max } = this.get(name);
    return this.build({ max });
  };
  between = (minName, maxName) => {
    const { min } = this.get(minName);
    const { max } = this.get(maxName);
    return this.build({ min, max });
  };
  only = (name) => {
    const { min, max } = this.get(name);
    return this.build({ min, max });
  };
  get ranges() {
    const breakpoints = Object.keys(this.values);
    const permuations = getPermutations(breakpoints);
    const values = breakpoints.flatMap((_name, index) => {
      const min = breakpoints[index];
      const down = [`${min}Down`, this.down(min)];
      const up = [min, this.up(min)];
      const only = [`${min}Only`, this.only(min)];
      return [up, only, down];
    }).filter(([_, value]) => value !== "").concat(permuations.map(([min, max]) => [`${min}To${capitalize(max)}`, this.between(min, max)]));
    return Object.fromEntries(values);
  }
  get conditions() {
    const values = Object.entries(this.ranges).map(([key, value]) => {
      return [key, toCondition(key, value)];
    });
    return Object.fromEntries(values);
  }
  getCondition = (key) => {
    return this.conditions[key];
  };
  expandScreenAtRule = (root) => {
    root.walkAtRules("breakpoint", (rule) => {
      const value = this.getCondition(rule.params);
      if (!value) {
        throw rule.error(`No \`${rule.params}\` screen found.`);
      }
      rule.name = "media";
      rule.params = value.params;
    });
  };
};
function sortBreakpoints(breakpoints) {
  return Object.entries(breakpoints).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  }).map(([name, min], index, entries) => {
    let max = null;
    if (index <= entries.length - 1) {
      max = entries[index + 1]?.[1];
    }
    if (max != null) {
      const computedMax = parseFloat(toPx(max) ?? "") - 0.05;
      max = toEm(`${computedMax}px`);
    }
    return [name, { name, min, max }];
  });
}
var toCondition = (key, value) => ({
  type: "at-rule",
  name: "breakpoint",
  value: key,
  raw: key,
  rawValue: `@media ${value}`,
  params: value
});
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next = values[idx];
    while (next) {
      result.push([current, next]);
      idx++;
      next = values[idx];
    }
  });
  return result;
}

// src/compositions.ts
import { flatten } from "@pandacss/shared";

// src/serialize.ts
import { filterBaseConditions as filterBaseConditions2, isImportant as isImportant2, walkObject as walkObject2, withoutImportant as withoutImportant2 } from "@pandacss/shared";
import merge from "lodash.merge";
function serializeStyle(styleObj, context) {
  const { utility, conditions } = context;
  const rule = conditions.rule();
  const result = {};
  walkObject2(styleObj, (value, paths) => {
    const important = isImportant2(value);
    const [prop, ...allConditions] = conditions.shift(paths);
    const conds = filterBaseConditions2(allConditions);
    const hasConditions = conds.length > 0;
    let { styles } = utility.transform(prop, withoutImportant2(value));
    const cssResult = toCss(styles, { important });
    if (hasConditions) {
      const segments = conditions.segment(conds);
      rule.nodes = cssResult.root.nodes;
      rule.selector = segments.selector.length > 0 ? segments.selector[0] : "&";
      rule.update();
      rule.applyConditions(segments.condition);
      styles = cssToJs(rule.toString());
    } else {
      styles = cssToJs(cssResult.css);
    }
    merge(result, styles);
  });
  return result;
}
function serializeStyles(groupedObject, context) {
  const result = {};
  for (const [scope, styles] of Object.entries(groupedObject)) {
    result[scope] ||= {};
    merge(result[scope], serializeStyle(styles, context));
  }
  return toCss(result).root;
}

// src/compositions.ts
function assignCompositions(compositions, ctx) {
  for (const [key, values] of Object.entries(compositions)) {
    const flatValues = flatten(values ?? {});
    const config = {
      layer: "compositions",
      className: key,
      values: Object.keys(flatValues),
      transform: (value) => {
        return serializeStyle(flatValues[value], ctx);
      }
    };
    ctx.utility.register(key, config);
  }
}

// src/conditions.ts
import { logger } from "@pandacss/logger";
import { isBaseCondition, withoutSpace } from "@pandacss/shared";

// src/conditional-rule.ts
import postcss5 from "postcss";
var ConditionalRule = class {
  constructor(conditionsMap) {
    this.conditionsMap = conditionsMap;
  }
  rule;
  selector = "";
  nodes = [];
  get isEmpty() {
    return this.nodes.length === 0;
  }
  update = () => {
    this.rule = postcss5.rule({ selector: this.selector, nodes: this.nodes });
  };
  applyConditions = (conditions) => {
    const sorted = this.conditionsMap.sort(conditions);
    const rule = postcss5.rule({ selector: this.selector });
    sorted.forEach((cond) => {
      if (!cond)
        return;
      const selector = cond.rawValue ?? cond.value;
      const last = getDeepestNode(rule);
      const node = last ?? rule;
      node.append(postcss5.rule({ selector }));
    });
    getDeepestNode(rule)?.append(this.nodes);
    this.rule = rule;
  };
  toString() {
    return this.rule.toString();
  }
};
function getDeepestNode(node) {
  if (node.nodes && node.nodes.length) {
    return getDeepestNode(node.nodes[node.nodes.length - 1]);
  }
  return node;
}

// src/parse-condition.ts
import "postcss";
function parseAtRule(value) {
  const result = safeParse(value);
  const rule = result.nodes[0];
  return {
    type: "at-rule",
    name: rule.name,
    value: rule.params,
    raw: value,
    rawValue: value
  };
}
function parseCondition(condition) {
  if (condition.startsWith("@")) {
    return parseAtRule(condition);
  }
  let type;
  if (condition.startsWith("&")) {
    type = "self-nesting";
  } else if (condition.endsWith(" &")) {
    type = "parent-nesting";
  } else if (condition.includes("&")) {
    type = "combinator-nesting";
  }
  if (type) {
    return { type, value: condition, raw: condition };
  }
}

// src/conditions.ts
var order = ["self-nesting", "combinator-nesting", "parent-nesting", "at-rule"];
var underscoreRegex = /^_/;
var selectorRegex = /&|@/;
var Conditions = class {
  constructor(options) {
    this.options = options;
    const { breakpoints: breakpointValues = {}, conditions = {} } = this.options;
    const breakpoints = new Breakpoints(breakpointValues);
    this.breakpoints = breakpoints;
    const entries = Object.entries(conditions).map(([key, value]) => [`_${key}`, parseCondition(value)]);
    this.values = {
      ...Object.fromEntries(entries),
      ...breakpoints.conditions
    };
  }
  values;
  breakpoints;
  finalize = (paths) => {
    return paths.map((path) => {
      if (this.has(path)) {
        return path.replace(underscoreRegex, "");
      }
      if (selectorRegex.test(path)) {
        return `[${withoutSpace(path.trim())}]`;
      }
      return path;
    });
  };
  shift = (paths) => {
    return paths.slice().sort((a, b) => {
      const aIsCondition = this.isCondition(a);
      const bIsCondition = this.isCondition(b);
      if (aIsCondition && !bIsCondition)
        return 1;
      if (!aIsCondition && bIsCondition)
        return -1;
      if (!aIsCondition && !bIsCondition)
        return -1;
      return 0;
    });
  };
  segment = (paths) => {
    const condition = [];
    const selector = [];
    for (const path of paths) {
      if (this.isCondition(path)) {
        condition.push(path);
      } else {
        selector.push(path);
      }
    }
    return { condition, selector };
  };
  has = (key) => {
    return Object.prototype.hasOwnProperty.call(this.values, key);
  };
  isCondition = (key) => {
    return this.has(key) || !!this.getRaw(key) || isBaseCondition(key);
  };
  isEmpty = () => {
    return Object.keys(this.values).length === 0;
  };
  get = (key) => {
    const result = this.values[key];
    return result?.rawValue ?? result?.value;
  };
  getRaw = (condition) => {
    try {
      return this.values[condition] ?? parseCondition(condition);
    } catch (error) {
      logger.error("core:condition", error);
    }
  };
  sort = (conditions) => {
    const rawConditions = conditions.map(this.getRaw).filter(Boolean);
    return rawConditions.sort((a, b) => order.indexOf(a.type) - order.indexOf(b.type));
  };
  normalize = (condition) => {
    return typeof condition === "string" ? this.getRaw(condition) : condition;
  };
  keys = () => {
    return Object.keys(this.values);
  };
  rule = () => {
    return new ConditionalRule(this);
  };
};

// src/keyframes.ts
import postcss6 from "postcss";
function toString(name, definition) {
  return postcss6.atRule({
    name: "keyframes",
    params: name,
    nodes: toCss(definition).root.nodes
  });
}
function toKeyframeCss(values) {
  const root = postcss6.root();
  for (const [name, definition] of Object.entries(values)) {
    root.append(toString(name, definition));
  }
  const rule = postcss6.atRule({
    name: "layer",
    params: "tokens",
    nodes: root.nodes
  });
  return rule.toString();
}

// src/merge-css.ts
import { isMatching } from "ts-pattern";

// src/optimize.ts
import postcss7 from "postcss";
import dedupe from "postcss-discard-duplicates";
import discardEmpty from "postcss-discard-empty";
import mergeRules from "postcss-merge-rules";
import nested from "postcss-nested";
import normalizeWhiteSpace from "postcss-normalize-whitespace";

// src/plugins/expand-token-fn.ts
var tokenRegex = /token\(([^)]+)\)/g;
var closingParenthesisRegex = /\)$/;
function expandTokenFn(fn) {
  return (root) => {
    root.walkDecls((decl2) => {
      if (decl2.value.includes("token(")) {
        const value = decl2.value.replace(tokenRegex, (_, token) => {
          const [tokenValue, tokenFallback] = token.split(",").map((s) => s.trim());
          const result = [tokenValue, tokenFallback].filter(Boolean).map((s) => fn?.(s) ?? s);
          if (result.length > 1) {
            const [a, b] = result;
            return a.endsWith(")") ? a.replace(closingParenthesisRegex, `, ${b})`) : `var(${a}, ${b})`;
          }
          return result[0];
        });
        decl2.value = value;
      }
    });
  };
}
expandTokenFn.postcssPlugin = "panda:expand-token-fn";
var expand_token_fn_default = expandTokenFn;

// src/plugins/merge-layers.ts
function mergeLayers() {
  return (root) => {
    const layers = /* @__PURE__ */ new Map();
    root.walkAtRules("layer", (rule) => {
      const prev = layers.get(rule.params);
      if (prev) {
        rule.remove();
        prev.append(rule.nodes);
      } else {
        layers.set(rule.params, rule);
      }
    });
  };
}
mergeLayers.postcssPlugin = "panda-merge-layers";

// src/plugins/prettify.ts
function prettifyNode(node, indent = 0) {
  node.each && node.each((child, i) => {
    if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes("\n")) {
      child.raws.before = `
${node.type !== "rule" && i > 0 ? "\n" : ""}${"  ".repeat(indent)}`;
    }
    prettifyNode(child, indent + 1);
  });
}
function prettify() {
  return (root) => {
    prettifyNode(root);
    if (root.first) {
      root.first.raws.before = "";
    }
  };
}
prettify.postcssPlugin = "panda-prettify";

// src/plugins/sort-css.ts
var styleOrder = [":link", ":visited", ":focus-within", ":focus", ":focus-visible", ":hover", ":active"];
var pseudoSelectorScore = (selector) => {
  const index = styleOrder.findIndex((pseudoClass) => selector.trim().includes(pseudoClass));
  return index + 1;
};
function sortCss() {
  const inner = (root) => {
    const catchAll = [];
    const rules = [];
    const atRules = [];
    root.each((node) => {
      switch (node.type) {
        case "rule": {
          if (node.first?.type === "atrule") {
            atRules.push(node);
          } else {
            rules.push(node);
          }
          break;
        }
        case "atrule": {
          atRules.push(node);
          break;
        }
        default: {
          catchAll.push(node);
        }
      }
    });
    rules.sort((rule1, rule2) => {
      const selector1 = rule1.selectors.length ? rule1.selectors[0] : rule1.selector;
      const selector2 = rule2.selectors.length ? rule2.selectors[0] : rule2.selector;
      return pseudoSelectorScore(selector1) - pseudoSelectorScore(selector2);
    });
    root.nodes = [...catchAll, ...rules, ...atRules];
    root.nodes.forEach((node) => {
      if ("nodes" in node) {
        inner(node);
      }
    });
  };
  return inner;
}
sortCss.postcssPlugin = "panda-sort-css";

// src/plugins/sort-at-rules.ts
var minMaxWidth = /(!?\(\s*min(-device-)?-width)(.|\n)+\(\s*max(-device)?-width/i;
var minWidth = /\(\s*min(-device)?-width/i;
var maxMinWidth = /(!?\(\s*max(-device)?-width)(.|\n)+\(\s*min(-device)?-width/i;
var maxWidth = /\(\s*max(-device)?-width/i;
var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);
var minMaxHeight = /(!?\(\s*min(-device)?-height)(.|\n)+\(\s*max(-device)?-height/i;
var minHeight = /\(\s*min(-device)?-height/i;
var maxMinHeight = /(!?\(\s*max(-device)?-height)(.|\n)+\(\s*min(-device)?-height/i;
var maxHeight = /\(\s*max(-device)?-height/i;
var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var maxValue = Number.MAX_VALUE;
function getQueryLength(query) {
  let length = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/.exec(query);
  if (length === null && (isMinWidth(query) || isMinHeight(query))) {
    length = /(\d)/.exec(query);
  }
  if (length === "0") {
    return 0;
  }
  if (length === null) {
    return maxValue;
  }
  let number = length[1];
  const unit = length[2];
  switch (unit) {
    case "ch":
      number = parseFloat(number) * 8.8984375;
      break;
    case "em":
    case "rem":
      number = parseFloat(number) * 16;
      break;
    case "ex":
      number = parseFloat(number) * 8.296875;
      break;
    case "px":
      number = parseFloat(number);
      break;
  }
  return +number;
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return function(query) {
    if (doubleTestTrue.test(query)) {
      return true;
    } else if (doubleTestFalse.test(query)) {
      return false;
    }
    return singleTest.test(query);
  };
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a);
  const isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b);
  const isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) {
      return 1;
    }
    if (isPrintOnlyA && !isPrintOnlyB) {
      return -1;
    }
    return a.localeCompare(b);
  }
  if (isPrintA) {
    return 1;
  }
  if (isPrintB) {
    return -1;
  }
  return null;
}
function createSort(config = {}) {
  const { unitlessMqAlwaysFirst } = config;
  return function sortCSSmq(a, b) {
    const testIsPrint = _testIsPrint(a, b);
    if (testIsPrint !== null) {
      return testIsPrint;
    }
    const minA = isMinWidth(a) || isMinHeight(a);
    const maxA = isMaxWidth(a) || isMaxHeight(a);
    const minB = isMinWidth(b) || isMinHeight(b);
    const maxB = isMaxWidth(b) || isMaxHeight(b);
    if (unitlessMqAlwaysFirst && (!minA && !maxA || !minB && !maxB)) {
      if (!minA && !maxA && !minB && !maxB) {
        return a.localeCompare(b);
      }
      return !minB && !maxB ? 1 : -1;
    } else {
      if (minA && maxB) {
        return -1;
      }
      if (maxA && minB) {
        return 1;
      }
      const lengthA = getQueryLength(a);
      const lengthB = getQueryLength(b);
      if (lengthA === maxValue && lengthB === maxValue) {
        return a.localeCompare(b);
      } else if (lengthA === maxValue) {
        return 1;
      } else if (lengthB === maxValue) {
        return -1;
      }
      if (lengthA > lengthB) {
        if (maxA) {
          return -1;
        }
        return 1;
      }
      if (lengthA < lengthB) {
        if (maxA) {
          return 1;
        }
        return -1;
      }
      return a.localeCompare(b);
    }
  };
}
var sortAtRules = createSort();

// src/plugins/sort-mq.ts
import { match, P } from "ts-pattern";
function sortMediaQueries() {
  const inner = (root) => {
    root.nodes.sort((a, b) => {
      return match({ a, b }).with(
        {
          a: { type: "atrule", name: "media" },
          b: { type: "atrule", name: "media" }
        },
        ({ a: a2, b: b2 }) => {
          return sortAtRules(a2.params, b2.params);
        }
      ).with({ a: { type: "atrule", name: "media" }, b: P.any }, () => {
        return 1;
      }).with({ a: P.any, b: { type: "atrule", name: "media" } }, () => {
        return -1;
      }).otherwise(() => {
        return 0;
      });
    });
    root.nodes.forEach((node) => {
      if ("nodes" in node) {
        inner(node);
      }
    });
  };
  return inner;
}
sortMediaQueries.postcssPlugin = "panda-sort-mq";

// src/optimize.ts
function optimizeCss(code, options = {}) {
  const { minify = false } = options;
  const { css } = postcss7([
    nested(),
    mergeLayers(),
    sortMediaQueries(),
    dedupe(),
    mergeRules(),
    sortCss(),
    discardEmpty(),
    minify ? normalizeWhiteSpace() : prettify()
  ]).process(code);
  return css;
}
function expandCssFunctions(code, options = {}) {
  const { token } = options;
  const { css } = postcss7([expand_token_fn_default(token)]).process(code);
  return css;
}
function discardDuplicate(code) {
  const { css } = postcss7([mergeLayers(), dedupe(), sortMediaQueries(), sortCss(), prettify()]).process(code);
  return css;
}
function expandNestedCss(code) {
  const { css } = postcss7([nested(), prettify()]).process(code);
  return css;
}
function prettifyCss(code) {
  const { css } = postcss7([prettify()]).process(code);
  return css;
}

// src/merge-css.ts
function mergeCss(oldCss, newCss) {
  const oldRoot = safeParse(oldCss);
  const newRoot = safeParse(newCss);
  const oldUtilities = oldRoot.nodes.filter(
    isMatching({
      type: "atrule",
      name: "layer",
      params: "utilities"
    })
  );
  newRoot.walkAtRules("layer", (rule) => {
    if (rule.params !== "utilities")
      return;
    oldUtilities.forEach((oldUtil) => {
      rule.append(oldUtil.nodes);
    });
  });
  return discardDuplicate(newRoot);
}

// src/recipes.ts
import { capitalize as capitalize2, dashCase, memo, splitProps } from "@pandacss/shared";
import merge2 from "lodash.merge";
var createRegex = (item) => {
  const regex = item.map((item2) => typeof item2 === "string" ? item2 : item2.source).join("|");
  return new RegExp(`^${regex}$`);
};
var sharedState = {
  /**
   * The map of recipe names to their resolved class names
   */
  classNames: /* @__PURE__ */ new Map(),
  /**
   * The map of the property to their resolved styless
   */
  styles: /* @__PURE__ */ new Map(),
  /**
   * The map of the recipes with their resolved styles
   */
  configs: /* @__PURE__ */ new Map()
};
var Recipes = class {
  constructor(recipes = {}, context) {
    this.recipes = recipes;
    this.context = context;
    this.assignRules();
  }
  /**
   * The map of the recipes to their atomic rules
   */
  rules = /* @__PURE__ */ new Map();
  getPropKey = (recipe, variant, value) => {
    return `${recipe} (${variant} = ${value})`;
  };
  get separator() {
    return this.context?.utility.separator ?? "_";
  }
  getClassName = (recipe, variant, value) => {
    return `${recipe}--${variant}${this.separator}${value}`;
  };
  save = () => {
    for (const [name, recipe] of Object.entries(this.recipes)) {
      this.assignRecipe(name, this.normalize(recipe));
    }
  };
  assignRecipe = (name, recipe) => {
    const variantKeys = Object.keys(recipe.variants ?? {});
    const jsx = recipe.jsx ?? [capitalize2(name)];
    const match3 = createRegex(jsx);
    sharedState.configs.set(name, {
      ...this.getNames(name),
      jsx,
      name,
      variantKeys,
      variantKeyMap: Object.fromEntries(
        Object.entries(recipe.variants ?? {}).map(([key, value]) => {
          return [key, Object.keys(value)];
        })
      ),
      match: match3,
      config: recipe,
      splitProps: (props) => {
        return splitProps(props, variantKeys);
      }
    });
  };
  assignRules = () => {
    if (!this.context)
      return;
    for (const name of Object.keys(this.recipes)) {
      this.rules.set(name, this.createRule(name));
    }
  };
  isEmpty = () => {
    return sharedState.configs.size === 0;
  };
  getNames = memo((name) => {
    return {
      upperName: capitalize2(name),
      dashName: dashCase(name),
      jsxName: capitalize2(name)
    };
  });
  getRecipe = memo((name) => {
    return sharedState.configs.get(name);
  });
  getConfig = memo((name) => {
    return this.recipes[name];
  });
  find = memo((jsxName) => {
    return this.details.find((node) => node.match.test(jsxName));
  });
  filter = memo((jsxName) => {
    return this.details.filter((node) => node.match.test(jsxName));
  });
  get details() {
    return Array.from(sharedState.configs.values());
  }
  get nodes() {
    return this.details.map(({ upperName, variantKeys, name, jsx, match: match3 }) => ({
      type: "recipe",
      name: upperName,
      props: variantKeys,
      baseName: name,
      jsx,
      match: match3
    }));
  }
  splitProps = (name, props) => {
    const recipe = this.find(name);
    if (!recipe)
      return [{}, props];
    return recipe.splitProps(props);
  };
  normalize = (config) => {
    const {
      name,
      jsx = [capitalize2(name)],
      base = {},
      variants = {},
      defaultVariants = {},
      description = "",
      compoundVariants = []
    } = config;
    const recipe = {
      jsx,
      name,
      description,
      base: {},
      variants: {},
      defaultVariants,
      compoundVariants
    };
    recipe.base = this.serialize(base);
    sharedState.styles.set(name, recipe.base);
    sharedState.classNames.set(name, name);
    for (const [key, variant] of Object.entries(variants)) {
      for (const [variantKey, styles] of Object.entries(variant)) {
        const propKey = this.getPropKey(name, key, variantKey);
        const className = this.getClassName(name, key, variantKey);
        const styleObject = this.serialize(styles);
        sharedState.styles.set(propKey, styleObject);
        sharedState.classNames.set(propKey, className);
        merge2(recipe.variants, {
          [key]: { [variantKey]: styleObject }
        });
      }
    }
    return recipe;
  };
  serialize = (styleObject) => {
    if (!this.context)
      return styleObject;
    const { utility, conditions } = this.context;
    return serializeStyle(styleObject, { utility, conditions });
  };
  getTransform = (name) => {
    return (variant, value) => {
      if (value === "__ignore__") {
        return {
          layer: "_base",
          className: sharedState.classNames.get(name),
          styles: sharedState.styles.get(name) ?? {}
        };
      }
      const propKey = this.getPropKey(name, variant, value);
      return {
        className: sharedState.classNames.get(propKey),
        styles: sharedState.styles.get(propKey) ?? {}
      };
    };
  };
  createRule = (name) => {
    if (!this.context) {
      throw new Error("Can't create a rule without a context");
    }
    const rule = new AtomicRule({
      ...this.context,
      transform: this.getTransform(name)
    });
    rule.layer = "recipes";
    return rule;
  };
  process = (recipeName, options) => {
    const { styles: variants } = options;
    const recipe = this.getRecipe(recipeName);
    if (!recipe)
      return;
    const { name, defaultVariants = {}, base = {} } = recipe.config;
    const styles = Object.assign({ [name]: "__ignore__" }, defaultVariants, variants);
    const keys2 = Object.keys(styles);
    if (keys2.length === 1 && Object.keys(base).length === 0) {
      return;
    }
    const rule = this.rules.get(name);
    rule?.process({ styles });
  };
  toCss = () => {
    if (!this.context)
      return "";
    return this.context.root.toString();
  };
};

// src/selector.ts
import parser2 from "postcss-selector-parser";
import { match as match2 } from "ts-pattern";
var parentNestingRegex = /\s&/g;
function extractParentSelectors(selector) {
  const result = /* @__PURE__ */ new Set();
  parser2((selectors) => {
    selectors.each((selector2) => {
      const condition = parseCondition(selector2.toString());
      match2(condition).with({ type: "parent-nesting" }, () => {
        result.add(selector2.toString().replace(parentNestingRegex, "").trim());
      }).otherwise(() => {
      });
    });
  }).processSync(selector);
  const finalized = Array.from(result).join(", ").trim();
  return result.size > 1 ? `:where(${finalized})` : finalized;
}

// src/shared-hooks.ts
import { createHooks } from "hookable";
var sharedHooks = createHooks();

// src/static-css.ts
var formatCondition = (ctx, value) => ctx.breakpoints.includes(value) ? value : `_${value}`;
function getStaticCss(options) {
  const { css = [], recipes = {} } = options;
  const results = { css: [], recipes: [] };
  return (ctx) => {
    css.forEach((rule) => {
      const conditions = rule.conditions || [];
      if (rule.responsive) {
        conditions.push(...ctx.breakpoints);
      }
      Object.entries(rule.properties).forEach(([property, values]) => {
        const computedValues = values.flatMap((value) => value === "*" ? ctx.getPropertyKeys(property) : value);
        computedValues.forEach((value) => {
          const conditionalValues = conditions.reduce(
            (acc, condition) => ({
              base: value,
              ...acc,
              [formatCondition(ctx, condition)]: value
            }),
            {}
          );
          results.css.push({
            [property]: conditions.length ? conditionalValues : value
          });
        });
      });
    });
    Object.entries(recipes).forEach(([recipe, rules]) => {
      rules.forEach((recipeRule) => {
        let rule = recipeRule;
        if (rule === "*") {
          rule = { conditions: [], responsive: true, ...ctx.getRecipeKeys(recipe) };
        }
        const { conditions: _conditions, responsive, ...variants } = rule;
        const conditions = _conditions || [];
        if (responsive) {
          conditions.push(...ctx.breakpoints);
        }
        Object.entries(variants).forEach(([variant, values]) => {
          if (!Array.isArray(values))
            return;
          const computedValues = values.flatMap((value) => {
            if (value === "*") {
              return ctx.getRecipeKeys(recipe)[variant];
            }
            return value;
          });
          computedValues.forEach((value) => {
            const conditionalValues = conditions.reduce(
              (acc, condition) => ({
                base: value,
                ...acc,
                [formatCondition(ctx, condition)]: value
              }),
              {}
            );
            results.recipes.push({
              [recipe]: {
                [variant]: conditions.length ? conditionalValues : value
              }
            });
          });
        });
      });
    });
    return results;
  };
}

// src/stylesheet.ts
import { logger as logger2 } from "@pandacss/logger";
import postcss8, { CssSyntaxError } from "postcss";
var Stylesheet = class {
  constructor(context, options) {
    this.context = context;
    this.options = options;
    const { recipes } = options ?? {};
    this.recipes = new Recipes(recipes ?? {}, context);
  }
  recipes;
  processGlobalCss = (styleObject) => {
    const { conditions, utility } = this.context;
    const css = serializeStyles(styleObject, { conditions, utility });
    const layer = postcss8.atRule({
      name: "layer",
      params: "base",
      nodes: [css]
    });
    this.context.root.append(layer);
  };
  processSelectorObject(selector, styleObject) {
    const cssString = toCss(styleObject);
    const { nodes } = safeParse(cssString);
    if (nodes.length === 0)
      return;
    const output = postcss8.rule({
      selector,
      nodes: cssString.root.nodes
    });
    this.context.root.append(output);
  }
  processObject(styleObject) {
    const result = toCss(styleObject);
    const output = result.root;
    this.context.root.append(output);
  }
  processAtomic = (...styleObject) => {
    const ruleset = new AtomicRule(this.context);
    styleObject.forEach((styles) => {
      if (!styles)
        return;
      ruleset.process({ styles });
    });
  };
  processStyleProps = (styleObject) => {
    const { css: cssObject, ...restStyles } = styleObject;
    this.processAtomic(restStyles, cssObject);
  };
  processRecipe = (config, styles) => {
    this.recipes.process(config.name, { styles });
    config.compoundVariants?.forEach((compoundVariant) => {
      this.processAtomic(compoundVariant.css);
    });
  };
  processAtomicRecipe = (recipe) => {
    const { base = {}, variants = {}, compoundVariants = [] } = recipe;
    this.processAtomic(base);
    for (const variant of Object.values(variants)) {
      for (const styles of Object.values(variant)) {
        this.processAtomic(styles);
      }
    }
    compoundVariants.forEach((compoundVariant) => {
      this.processAtomic(compoundVariant.css);
    });
  };
  toCss = ({ optimize = false, minify } = {}) => {
    try {
      const {
        conditions: { breakpoints },
        utility
      } = this.context;
      breakpoints.expandScreenAtRule(this.context.root);
      expandCssFunctions(this.context.root, { token: utility.getToken });
      let css = this.context.root.toString();
      if (optimize) {
        css = optimizeCss(css, { minify });
      }
      if (this.options?.content) {
        css = `${this.options.content}

${css}`;
      }
      return optimize ? discardDuplicate(css) : css;
    } catch (error) {
      if (error instanceof CssSyntaxError) {
        logger2.error("sheet", error.message);
        error.plugin && logger2.error("sheet", `By plugin: ${error.plugin}:`);
        if (error.source) {
          logger2.error("sheet", `Line ${error.line}:${error.column}, in:`);
          logger2.error("sheet", error.source);
        }
      }
      throw error;
    }
  };
  append = (...css) => {
    this.context.root.append(...css);
  };
  prepend = (...css) => {
    this.context.root.prepend(...css);
  };
};

// src/utility.ts
import { compact, hypenateProperty as hypenateProperty3, isFunction, isString, memo as memo2, withoutSpace as withoutSpace2 } from "@pandacss/shared";
var Utility = class {
  /**
   * The token map or dictionary of tokens
   */
  tokens;
  /**
   * The map of property names to their resolved class names
   */
  classNames = /* @__PURE__ */ new Map();
  /**
   * The map of the property to their resolved styless
   */
  styles = /* @__PURE__ */ new Map();
  /**
   * Map of shorthand properties to their longhand properties
   */
  shorthands = /* @__PURE__ */ new Map();
  /**
   * The map of possible values for each property
   */
  types = /* @__PURE__ */ new Map();
  /**
   * The map of the property keys
   */
  propertyKeys = /* @__PURE__ */ new Map();
  /**
   * The utility config
   */
  config = {};
  /**
   * Useful for reporting custom values
   */
  customValues = /* @__PURE__ */ new Map();
  /**
   * The map of property names to their transform functions
   */
  transforms = /* @__PURE__ */ new Map();
  /**
   * The map of property names to their config
   */
  configs = /* @__PURE__ */ new Map();
  separator = "_";
  prefix = "";
  constructor(options) {
    const { tokens, config = {}, separator, prefix, shorthands } = options;
    this.tokens = tokens;
    this.config = config;
    if (separator) {
      this.separator = separator;
    }
    if (prefix) {
      this.prefix = prefix;
    }
    if (shorthands) {
      this.assignShorthands();
    }
    this.assignColorPaletteProperty();
    this.assignProperties();
    this.assignPropertyTypes();
  }
  register = (property, config) => {
    this.assignProperty(property, config);
    this.assignPropertyType(property, config);
    this.config[property] = config;
  };
  assignShorthands = () => {
    for (const [property, config] of Object.entries(this.config)) {
      const { shorthand } = this.normalize(config) ?? {};
      if (!shorthand)
        continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((shorthandName) => {
        this.shorthands.set(shorthandName, property);
      });
    }
  };
  assignColorPaletteProperty = () => {
    const values = this.tokens.colorPalettes;
    this.config.colorPalette = {
      values: Object.keys(values),
      transform(value) {
        return values[value];
      }
    };
  };
  resolveShorthand = (prop) => {
    return this.shorthands.get(prop) ?? prop;
  };
  get hasShorthand() {
    return this.shorthands.size > 0;
  }
  get isEmpty() {
    return Object.keys(this.config).length === 0;
  }
  entries = () => {
    const value = Object.entries(this.config).filter(([, value2]) => !!value2?.className).map(([key, value2]) => [key, value2.className]);
    return value;
  };
  getPropKey = (prop, value) => {
    return `(${prop} = ${value})`;
  };
  hash = (prop, value) => {
    return `${prop}${this.separator}${value}`;
  };
  /**
   * Get all the possible values for the defined property
   */
  getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn?.(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return fn?.(values) ?? this.tokens.getValue(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : this.getToken.bind(this));
    }
    return values;
  };
  getToken = (path) => {
    return this.tokens.get(path);
  };
  /**
   * Normalize the property config
   */
  normalize = (value) => {
    return value;
  };
  assignProperty = (property, propertyConfig) => {
    const config = this.normalize(propertyConfig);
    this.setTransform(property, config?.transform);
    if (!config)
      return;
    this.configs.set(property, config);
    const values = this.getPropertyValues(config);
    if (!values)
      return;
    for (const [alias, raw] of Object.entries(values)) {
      const propKey = this.getPropKey(property, alias);
      this.setStyles(property, raw, alias, propKey);
      this.setClassName(property, alias);
    }
  };
  assignProperties = () => {
    for (const [property, propertyConfig] of Object.entries(this.config)) {
      if (!propertyConfig)
        continue;
      this.assignProperty(property, propertyConfig);
    }
  };
  getPropertyKeys = (property) => {
    const keys2 = this.propertyKeys.get(property);
    return keys2 ? Array.from(keys2) : [];
  };
  assignPropertyType = (property, propertyConfig) => {
    const config = this.normalize(propertyConfig);
    if (!config)
      return;
    const values = this.getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      this.types.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      this.types.set(property, keys2);
      this.propertyKeys.set(property, keys2);
    }
    const set = this.types.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      this.types.set(property, set.add(`CssProperties["${config.property}"]`));
    }
  };
  assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(this.config)) {
      if (!propertyConfig)
        continue;
      this.assignPropertyType(property, propertyConfig);
    }
  };
  /**
   * Returns the Typescript type for the define properties
   */
  getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, tokens] of this.types.entries()) {
      if (tokens.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(tokens).map((key) => {
        if (key.startsWith("CssProperties"))
          return key;
        if (key.startsWith("type:"))
          return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  defaultTransform = memo2((value, prop) => {
    const isCssVar = prop.startsWith("--");
    if (isCssVar) {
      const tokenValue = this.tokens.getTokenVar(value);
      value = typeof tokenValue === "string" ? tokenValue : value;
    }
    return { [prop]: value };
  });
  setTransform = (property, transform) => {
    const defaultTransform = (value) => this.defaultTransform(value, property);
    const transformFn = transform ?? defaultTransform;
    this.transforms.set(property, transformFn);
    return this;
  };
  setStyles = (property, raw, alias, propKey) => {
    propKey = propKey ?? this.getPropKey(property, raw);
    const defaultTransform = (value) => this.defaultTransform(value, property);
    const getStyles = this.transforms.get(property) ?? defaultTransform;
    const styles = getStyles(raw, { token: this.getToken.bind(this), raw: alias });
    this.styles.set(propKey, styles ?? {});
    return this;
  };
  formatClassName = (className) => {
    return [this.prefix, className].filter(Boolean).join("-");
  };
  setClassName = (property, raw) => {
    const propKey = this.getPropKey(property, raw);
    const config = this.configs.get(property);
    let className;
    if (!config || !config.className) {
      className = this.hash(hypenateProperty3(property), raw);
    } else {
      className = this.hash(config.className, raw);
    }
    this.classNames.set(propKey, className);
    return this;
  };
  /**
   * Whether a given property exists in the config
   */
  isProperty = (prop) => {
    return this.configs.has(prop);
  };
  /**
   * Returns the resolved className for a given property and value
   */
  getOrCreateClassName = (prop, value) => {
    const inner = (prop2, value2) => {
      const propKey = this.getPropKey(prop2, value2);
      if (!this.classNames.has(propKey)) {
        if (this.isProperty(prop2)) {
          this.customValues.set(prop2, value2);
        }
        this.setClassName(prop2, value2);
      }
      return this.classNames.get(propKey);
    };
    return inner(prop, value);
  };
  /**
   * Get or create the resolved styles for a given property and value
   */
  getOrCreateStyle = (prop, value) => {
    const propKey = this.getPropKey(prop, value);
    this.styles.get(propKey) ?? this.setStyles(prop, value, value, propKey);
    return this.styles.get(propKey);
  };
  /**
   * Returns the resolved className and styles for a given property and value
   */
  transform = (prop, value) => {
    if (value == null) {
      return { className: "", styles: {} };
    }
    const key = this.resolveShorthand(prop);
    return compact({
      layer: this.configs.get(key)?.layer,
      className: this.getOrCreateClassName(key, withoutSpace2(value)),
      styles: this.getOrCreateStyle(key, value)
    });
  };
  /**
   * All keys including shorthand keys
   */
  keys = () => {
    const shorthands = Array.from(this.shorthands.keys());
    const properties = Object.keys(this.config);
    return [...shorthands, ...properties];
  };
};
export {
  AtomicRule,
  Breakpoints,
  Conditions,
  Recipes,
  Stylesheet,
  Utility,
  assignCompositions,
  discardDuplicate,
  expandCssFunctions,
  expandNestedCss,
  extractParentSelectors,
  getStaticCss,
  mergeCss,
  optimizeCss,
  prettifyCss,
  sharedHooks,
  toCss,
  toKeyframeCss
};
