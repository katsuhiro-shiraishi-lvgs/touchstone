import { RawCondition, Dict, UtilityConfig, PropertyConfig, PatternHelpers, RecipeConfig, CssKeyframes, StaticCssOptions, SystemStyleObject } from '@pandacss/types';
import postcss, { Root, Container, ChildNode } from 'postcss';
import { TokenDictionary } from '@pandacss/token-dictionary';
import * as hookable from 'hookable';
import * as postcss_lib_no_work_result from 'postcss/lib/no-work-result';

declare class Breakpoints {
    private breakpoints;
    constructor(breakpoints: Record<string, string>);
    get sorted(): Entries;
    get values(): {
        [k: string]: {
            name: string;
            min: string;
            max?: string | null | undefined;
        };
    };
    get keys(): string[];
    get: (name: string) => {
        name: string;
        min: string;
        max?: string | null | undefined;
    };
    build: ({ min, max }: {
        min?: string | null | undefined;
        max?: string | null | undefined;
    }) => string;
    up: (name: string) => string;
    down: (name: string) => string;
    between: (minName: string, maxName: string) => string;
    only: (name: string) => string;
    get ranges(): Record<string, string>;
    get conditions(): Record<string, Cond>;
    getCondition: (key: string) => Cond | undefined;
    expandScreenAtRule: (root: Root) => void;
}
type Entries = [string, {
    name: string;
    min: string;
    max?: string | null;
}][];
type Cond = RawCondition & {
    params: string;
};

declare class ConditionalRule {
    private conditionsMap;
    rule: Container | undefined;
    selector: string;
    nodes: ChildNode[];
    constructor(conditionsMap: StylesheetContext['conditions']);
    get isEmpty(): boolean;
    update: () => void;
    applyConditions: (conditions: string[]) => void;
    toString(): string;
}

type Options = {
    conditions?: Dict<string>;
    breakpoints?: Record<string, string>;
};
declare class Conditions {
    private options;
    values: Record<string, RawCondition>;
    breakpoints: Breakpoints;
    constructor(options: Options);
    finalize: (paths: string[]) => string[];
    shift: (paths: string[]) => string[];
    segment: (paths: string[]) => {
        condition: string[];
        selector: string[];
    };
    has: (key: string) => boolean;
    isCondition: (key: string) => boolean;
    isEmpty: () => boolean;
    get: (key: string) => string;
    getRaw: (condition: string) => RawCondition | undefined;
    sort: (conditions: string[]) => RawCondition[];
    normalize: (condition: string | RawCondition) => RawCondition | undefined;
    keys: () => string[];
    rule: () => ConditionalRule;
}

type UtilityOptions = {
    config?: UtilityConfig;
    tokens: TokenDictionary;
    separator?: string;
    prefix?: string;
    shorthands?: boolean;
};
declare class Utility {
    /**
     * The token map or dictionary of tokens
     */
    tokens: TokenDictionary;
    /**
     * The map of property names to their resolved class names
     */
    classNames: Map<string, string>;
    /**
     * The map of the property to their resolved styless
     */
    styles: Map<string, Dict>;
    /**
     * Map of shorthand properties to their longhand properties
     */
    shorthands: Map<string, string>;
    /**
     * The map of possible values for each property
     */
    types: Map<string, Set<string>>;
    /**
     * The map of the property keys
     */
    propertyKeys: Map<string, Set<string>>;
    /**
     * The utility config
     */
    config: UtilityConfig;
    /**
     * Useful for reporting custom values
     */
    customValues: Map<string, string>;
    /**
     * The map of property names to their transform functions
     */
    private transforms;
    /**
     * The map of property names to their config
     */
    private configs;
    separator: string;
    prefix: string;
    constructor(options: UtilityOptions);
    register: (property: string, config: PropertyConfig) => void;
    private assignShorthands;
    private assignColorPaletteProperty;
    resolveShorthand: (prop: string) => string;
    get hasShorthand(): boolean;
    get isEmpty(): boolean;
    entries: () => [string, string][];
    private getPropKey;
    private hash;
    /**
     * Get all the possible values for the defined property
     */
    getPropertyValues: (config: PropertyConfig, resolveFn?: ((key: string) => string) | undefined) => Record<string, string> | {
        type: string;
    } | undefined;
    getToken: (path: string) => string;
    /**
     * Normalize the property config
     */
    normalize: (value: PropertyConfig | undefined) => PropertyConfig | undefined;
    private assignProperty;
    private assignProperties;
    getPropertyKeys: (property: string) => string[];
    private assignPropertyType;
    private assignPropertyTypes;
    /**
     * Returns the Typescript type for the define properties
     */
    getTypes: () => Map<string, string[]>;
    defaultTransform: (value: string, prop: string) => {
        [x: string]: string;
    };
    private setTransform;
    private setStyles;
    formatClassName: (className: string) => string;
    private setClassName;
    /**
     * Whether a given property exists in the config
     */
    private isProperty;
    /**
     * Returns the resolved className for a given property and value
     */
    private getOrCreateClassName;
    /**
     * Get or create the resolved styles for a given property and value
     */
    private getOrCreateStyle;
    /**
     * Returns the resolved className and styles for a given property and value
     */
    transform: (prop: string, value: string | undefined) => TransformResult;
    /**
     * All keys including shorthand keys
     */
    keys: () => string[];
}

type TransformResult = {
    layer?: string;
    className: string;
    styles: Dict;
};
type AtomicRuleTransform = (prop: string, value: any) => TransformResult;
type StylesheetContext = {
    root: Root;
    utility: Utility;
    conditions: Conditions;
    helpers: PatternHelpers;
    hash?: boolean;
    transform?: AtomicRuleTransform;
};
type RecipeNode = {
    /**
     * The name of the recipe
     */
    name: string;
    /**
     * The keys of the variants
     */
    variantKeys: string[];
    /**
     * The map of the variant keys to their possible values
     */
    variantKeyMap: Record<string, string[]>;
    /**
     * The jsx keys or regex to match the recipe
     */
    jsx: (string | RegExp)[];
    /**
     * The name of the recipe in upper case
     */
    upperName: string;
    /**
     * The name of the recipe in dash case
     */
    dashName: string;
    /**
     * The name of the recipe in camel case
     */
    jsxName: string;
    /**
     * The regex to match the recipe
     */
    match: RegExp;
    /**
     * The transformed recipe config
     */
    config: RecipeConfig;
    /**
     * The function to split the props
     */
    splitProps: (props: Dict) => [Dict, Dict];
};

type ProcessOptions = {
    styles: Dict;
};
declare class AtomicRule {
    private context;
    root: Root;
    layer: string;
    constructor(context: StylesheetContext);
    hashFn: (conditions: string[], className: string) => string;
    get rule(): ConditionalRule;
    get transform(): (prop: string, value: string | undefined) => TransformResult;
    process: (options: ProcessOptions) => void;
    toCss: () => string;
}

type SerializeContext = {
    conditions: Conditions;
    utility: Utility;
};

declare function assignCompositions(compositions: Dict, ctx: SerializeContext): void;

declare function toKeyframeCss(values: CssKeyframes): string;

declare function mergeCss(oldCss: string, newCss: string): string;

type OptimizeOptions = {
    minify?: boolean;
};
declare function optimizeCss(code: string, options?: OptimizeOptions): string;
declare function expandCssFunctions(code: string | Root, options?: {
    token?: (key: string) => string;
}): string;
declare function discardDuplicate(code: string | Root): string;
declare function expandNestedCss(code: string): string;
declare function prettifyCss(code: string): string;

type RecipeValues = Record<string, RecipeConfig>;
declare class Recipes {
    private recipes;
    private context?;
    /**
     * The map of the recipes to their atomic rules
     */
    rules: Map<string, AtomicRule>;
    constructor(recipes?: RecipeValues, context?: StylesheetContext | undefined);
    private getPropKey;
    private get separator();
    private getClassName;
    save: () => void;
    private assignRecipe;
    assignRules: () => void;
    isEmpty: () => boolean;
    getNames: (name: string) => {
        upperName: string;
        dashName: string;
        jsxName: string;
    };
    getRecipe: (name: string) => RecipeNode | undefined;
    getConfig: (name: string) => RecipeConfig | undefined;
    find: (jsxName: string) => RecipeNode | undefined;
    filter: (jsxName: string) => RecipeNode[];
    get details(): RecipeNode[];
    get nodes(): {
        type: "recipe";
        name: string;
        props: string[];
        baseName: string;
        jsx: (string | RegExp)[];
        match: RegExp;
    }[];
    splitProps: (name: string, props: Dict) => Dict[];
    normalize: (config: RecipeConfig) => Required<RecipeConfig>;
    private serialize;
    private getTransform;
    private createRule;
    process: (recipeName: string, options: ProcessOptions) => void;
    toCss: () => string;
}

declare function extractParentSelectors(selector: string): string;

declare const sharedHooks: hookable.Hookable<Record<string, any>, string>;

type StaticContext = {
    breakpoints: string[];
    getPropertyKeys: (property: string) => string[];
    getRecipeKeys: (recipe: string) => {
        [variant: string]: string[];
    };
};
declare function getStaticCss(options: StaticCssOptions): (ctx: StaticContext) => {
    css: Record<string, any>[];
    recipes: Record<string, any>[];
};

type StylesheetOptions = {
    content?: string;
    recipes?: Dict<RecipeConfig>;
};
declare class Stylesheet {
    private context;
    private options?;
    private recipes;
    constructor(context: StylesheetContext, options?: StylesheetOptions | undefined);
    processGlobalCss: (styleObject: Dict) => void;
    processSelectorObject(selector: string, styleObject: Dict): void;
    processObject(styleObject: SystemStyleObject): void;
    processAtomic: (...styleObject: (SystemStyleObject | undefined)[]) => void;
    processStyleProps: (styleObject: SystemStyleObject & {
        css?: SystemStyleObject;
    }) => void;
    processRecipe: (config: RecipeConfig, styles: SystemStyleObject) => void;
    processAtomicRecipe: (recipe: Pick<RecipeConfig, 'base' | 'variants' | 'compoundVariants'>) => void;
    toCss: ({ optimize, minify }?: {
        optimize?: boolean | undefined;
        minify?: boolean | undefined;
    }) => string;
    append: (...css: string[]) => void;
    prepend: (...css: string[]) => void;
}

declare function toCss(styles: Dict, { important }?: {
    important?: boolean;
}): postcss.LazyResult | postcss_lib_no_work_result.default;

export { AtomicRule, Breakpoints, Conditions, Recipes, Stylesheet, StylesheetContext, StylesheetOptions, Utility, assignCompositions, discardDuplicate, expandCssFunctions, expandNestedCss, extractParentSelectors, getStaticCss, mergeCss, optimizeCss, prettifyCss, sharedHooks, toCss, toKeyframeCss };
