'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const numericRange = require('@zag-js/numeric-range');

function getChannelDetails(color, xChannel, yChannel) {
  const channels = color.getColorSpaceAxes({ xChannel, yChannel });
  const xChannelRange = color.getChannelRange(channels.xChannel);
  const yChannelRange = color.getChannelRange(channels.yChannel);
  const { minValue: minValueX, maxValue: maxValueX, step: stepX, pageSize: pageSizeX } = xChannelRange;
  const { minValue: minValueY, maxValue: maxValueY, step: stepY, pageSize: pageSizeY } = yChannelRange;
  const xValue = color.getChannelValue(channels.xChannel);
  const yValue = color.getChannelValue(channels.yChannel);
  return {
    channels,
    xChannelStep: stepX,
    yChannelStep: stepY,
    xChannelPageStep: pageSizeX,
    yChannelPageStep: pageSizeY,
    xValue,
    yValue,
    getThumbPosition() {
      let x = (xValue - minValueX) / (maxValueX - minValueX);
      let y = 1 - (yValue - minValueY) / (maxValueY - minValueY);
      return { x, y };
    },
    incrementX(stepSize) {
      return xValue + stepSize > maxValueX ? maxValueX : numericRange.snapValueToStep(xValue + stepSize, minValueX, maxValueX, stepX);
    },
    incrementY(stepSize) {
      return yValue + stepSize > maxValueY ? maxValueY : numericRange.snapValueToStep(yValue + stepSize, minValueY, maxValueY, stepY);
    },
    decrementX(stepSize) {
      return numericRange.snapValueToStep(xValue - stepSize, minValueX, maxValueX, stepX);
    },
    decrementY(stepSize) {
      return numericRange.snapValueToStep(yValue - stepSize, minValueY, maxValueY, stepY);
    },
    getColorFromPoint(x, y) {
      let newXValue = numericRange.getPercentValue(x, minValueX, maxValueX, stepX);
      let newYValue = numericRange.getPercentValue(1 - y, minValueY, maxValueY, stepY);
      let newColor;
      if (newXValue !== xValue) {
        newXValue = numericRange.snapValueToStep(newXValue, minValueX, maxValueX, stepX);
        newColor = color.withChannelValue(channels.xChannel, newXValue);
      }
      if (newYValue !== yValue) {
        newYValue = numericRange.snapValueToStep(newYValue, minValueY, maxValueY, stepY);
        newColor = (newColor || color).withChannelValue(channels.yChannel, newYValue);
      }
      return newColor;
    }
  };
}

exports.getChannelDetails = getChannelDetails;
