import { autoResizeInput } from '@zag-js/auto-resize';
import { createMachine, guards } from '@zag-js/core';
import { contains, raf } from '@zag-js/dom-query';
import { trackFormControl } from '@zag-js/form-utils';
import { trackInteractOutside } from '@zag-js/interact-outside';
import { createLiveRegion } from '@zag-js/live-region';
import { compact, warn } from '@zag-js/utils';
import { dom } from './tags-input.dom.mjs';

const { and, not, or } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tags-input",
      initial: ctx.autoFocus ? "focused:input" : "idle",
      context: {
        log: { current: null, prev: null },
        inputValue: "",
        editedTagValue: "",
        focusedId: null,
        editedId: null,
        initialValue: [],
        value: [],
        dir: "ltr",
        max: Infinity,
        liveRegion: null,
        blurBehavior: void 0,
        addOnPaste: false,
        allowEditTag: true,
        validate: () => true,
        delimiter: ",",
        ...ctx,
        translations: {
          clearTriggerLabel: "Clear all tags",
          deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
          tagAdded: (value) => `Added tag ${value}`,
          tagsPasted: (values) => `Pasted ${values.length} tags`,
          tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
          tagUpdated: (value) => `Tag update to ${value}`,
          tagDeleted: (value) => `Tag ${value} deleted`,
          tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
          ...ctx.translations
        }
      },
      computed: {
        count: (ctx2) => ctx2.value.length,
        valueAsString: (ctx2) => JSON.stringify(ctx2.value),
        trimmedInputValue: (ctx2) => ctx2.inputValue.trim(),
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        isAtMax: (ctx2) => ctx2.count === ctx2.max,
        isOverflowing: (ctx2) => ctx2.count > ctx2.max
      },
      watch: {
        focusedId: ["invokeOnHighlight", "logFocused"],
        isOverflowing: "invokeOnInvalid",
        value: ["invokeOnChange", "dispatchChangeEvent"],
        log: "announceLog",
        inputValue: "syncInputValue",
        editedTagValue: "syncEditedTagValue"
      },
      activities: ["trackFormControlState"],
      exit: ["removeLiveRegion", "clearLog"],
      on: {
        DOUBLE_CLICK_TAG: {
          internal: true,
          guard: "allowEditTag",
          target: "editing:tag",
          actions: ["setEditedId", "initializeEditedTagValue"]
        },
        POINTER_DOWN_TAG: {
          internal: true,
          guard: not("isTagFocused"),
          target: "navigating:tag",
          actions: ["focusTag", "focusInput"]
        },
        SET_INPUT_VALUE: {
          actions: ["setInputValue"]
        },
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_TAG: {
          actions: ["deleteTag"]
        },
        SET_VALUE_AT_INDEX: {
          actions: ["setValueAtIndex"]
        },
        CLEAR_VALUE: {
          actions: ["clearTags", "clearInputValue", "focusInput"]
        },
        ADD_TAG: {
          // (!isAtMax || allowOverflow) && !inputValueIsEmpty
          guard: and(or(not("isAtMax"), "allowOverflow"), not("isInputValueEmpty")),
          actions: ["addTag", "clearInputValue"]
        },
        EXTERNAL_BLUR: [
          { guard: "addOnBlur", actions: "raiseAddTagEvent" },
          { guard: "clearOnBlur", actions: "clearInputValue" }
        ]
      },
      entry: ["setupDocument", "checkValue"],
      states: {
        idle: {
          on: {
            FOCUS: "focused:input",
            POINTER_DOWN: {
              guard: not("hasFocusedId"),
              target: "focused:input"
            }
          }
        },
        "focused:input": {
          tags: ["focused"],
          entry: ["focusInput", "clearFocusedId"],
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              actions: "setInputValue"
            },
            BLUR: [
              {
                guard: "addOnBlur",
                target: "idle",
                actions: "raiseAddTagEvent"
              },
              {
                guard: "clearOnBlur",
                target: "idle",
                actions: "clearInputValue"
              },
              { target: "idle" }
            ],
            ENTER: {
              actions: ["raiseAddTagEvent"]
            },
            DELIMITER_KEY: {
              actions: ["raiseAddTagEvent"]
            },
            ARROW_LEFT: {
              guard: and("hasTags", "isInputCaretAtStart"),
              target: "navigating:tag",
              actions: "focusLastTag"
            },
            BACKSPACE: {
              target: "navigating:tag",
              guard: and("hasTags", "isInputCaretAtStart"),
              actions: "focusLastTag"
            },
            PASTE: {
              guard: "addOnPaste",
              actions: ["setInputValue", "addTagFromPaste"]
            }
          }
        },
        "navigating:tag": {
          tags: ["focused"],
          activities: ["trackInteractOutside"],
          on: {
            ARROW_RIGHT: [
              {
                guard: and("hasTags", "isInputCaretAtStart", not("isLastTagFocused")),
                actions: "focusNextTag"
              },
              { target: "focused:input" }
            ],
            ARROW_LEFT: {
              actions: "focusPrevTag"
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedId"
            },
            ENTER: {
              guard: and("allowEditTag", "hasFocusedId"),
              target: "editing:tag",
              actions: ["setEditedId", "initializeEditedTagValue", "focusEditedTagInput"]
            },
            ARROW_DOWN: "focused:input",
            ESCAPE: "focused:input",
            TYPE: {
              target: "focused:input",
              actions: "setInputValue"
            },
            BACKSPACE: [
              {
                guard: "isFirstTagFocused",
                actions: ["deleteFocusedTag", "focusFirstTag"]
              },
              {
                actions: ["deleteFocusedTag", "focusPrevTag"]
              }
            ],
            DELETE: {
              actions: ["deleteFocusedTag", "focusTagAtIndex"]
            }
          }
        },
        "editing:tag": {
          tags: ["editing", "focused"],
          entry: "focusEditedTagInput",
          activities: ["autoResize"],
          on: {
            TAG_INPUT_TYPE: {
              actions: "setEditedTagValue"
            },
            TAG_INPUT_ESCAPE: {
              target: "navigating:tag",
              actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "focusTagAtIndex"]
            },
            TAG_INPUT_BLUR: [
              {
                guard: "isInputRelatedTarget",
                target: "navigating:tag",
                actions: ["clearEditedTagValue", "clearFocusedId", "clearEditedId"]
              },
              {
                target: "idle",
                actions: ["clearEditedTagValue", "clearFocusedId", "clearEditedId", "raiseExternalBlurEvent"]
              }
            ],
            TAG_INPUT_ENTER: {
              target: "navigating:tag",
              actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "focusTagAtIndex", "invokeOnTagUpdate"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInputRelatedTarget: (ctx2, evt) => evt.relatedTarget === dom.getInputEl(ctx2),
        isAtMax: (ctx2) => ctx2.isAtMax,
        hasFocusedId: (ctx2) => ctx2.focusedId !== null,
        isTagFocused: (ctx2, evt) => ctx2.focusedId === evt.id,
        isFirstTagFocused: (ctx2) => dom.getFirstEl(ctx2)?.id === ctx2.focusedId,
        isLastTagFocused: (ctx2) => dom.getLastEl(ctx2)?.id === ctx2.focusedId,
        isInputValueEmpty: (ctx2) => ctx2.trimmedInputValue.length === 0,
        hasTags: (ctx2) => ctx2.value.length > 0,
        allowOverflow: (ctx2) => !!ctx2.allowOverflow,
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        addOnBlur: (ctx2) => ctx2.blurBehavior === "add",
        clearOnBlur: (ctx2) => ctx2.blurBehavior === "clear",
        addOnPaste: (ctx2) => !!ctx2.addOnPaste,
        allowEditTag: (ctx2) => !!ctx2.allowEditTag,
        isInputCaretAtStart(ctx2) {
          const input = dom.getInputEl(ctx2);
          if (!input)
            return false;
          try {
            return input.selectionStart === 0 && input.selectionEnd === 0;
          } catch (e) {
            return input.value === "";
          }
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom.getInputEl(ctx2), {
            exclude(target) {
              return contains(dom.getRootEl(ctx2), target);
            },
            onInteractOutside(event) {
              ctx2.onInteractOutside?.(event);
              if (event.defaultPrevented)
                return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        trackFormControlState(ctx2) {
          return trackFormControl(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              ctx2.value = ctx2.initialValue;
            }
          });
        },
        autoResize(ctx2) {
          if (!ctx2.editedTagValue || ctx2.idx == null || !ctx2.allowEditTag)
            return;
          const input = dom.getTagInputEl(ctx2, { value: ctx2.editedTagValue, index: ctx2.idx });
          return autoResizeInput(input);
        }
      },
      actions: {
        raiseAddTagEvent(_, __, { self }) {
          self.send("ADD_TAG");
        },
        raiseExternalBlurEvent(_, evt, { self }) {
          self.send({ type: "EXTERNAL_BLUR", id: evt.id });
        },
        invokeOnHighlight(ctx2) {
          const value = dom.getFocusedTagValue(ctx2);
          ctx2.onHighlight?.({ value });
        },
        invokeOnTagUpdate(ctx2) {
          if (!ctx2.idx)
            return;
          const value = ctx2.value[ctx2.idx];
          ctx2.onTagUpdate?.({ value, index: ctx2.idx });
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ values: ctx2.value });
        },
        dispatchChangeEvent(ctx2) {
          dom.dispatchInputEvent(ctx2);
        },
        setupDocument(ctx2) {
          ctx2.liveRegion = createLiveRegion({
            level: "assertive",
            document: dom.getDoc(ctx2)
          });
        },
        focusNextTag(ctx2) {
          if (!ctx2.focusedId)
            return;
          const next = dom.getNextEl(ctx2, ctx2.focusedId);
          if (next)
            ctx2.focusedId = next.id;
        },
        focusFirstTag(ctx2) {
          raf(() => {
            const first = dom.getFirstEl(ctx2)?.id;
            if (first)
              ctx2.focusedId = first;
          });
        },
        focusLastTag(ctx2) {
          const last = dom.getLastEl(ctx2);
          if (last)
            ctx2.focusedId = last.id;
        },
        focusPrevTag(ctx2) {
          if (!ctx2.focusedId)
            return;
          const prev = dom.getPrevEl(ctx2, ctx2.focusedId);
          ctx2.focusedId = prev?.id || null;
        },
        focusTag(ctx2, evt) {
          ctx2.focusedId = evt.id;
        },
        focusTagAtIndex(ctx2) {
          raf(() => {
            if (ctx2.idx == null)
              return;
            const el = dom.getElAtIndex(ctx2, ctx2.idx);
            if (el) {
              ctx2.focusedId = el.id;
              ctx2.idx = void 0;
            }
          });
        },
        deleteTag(ctx2, evt) {
          const index = dom.getIndexOfId(ctx2, evt.id);
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          ctx2.value.splice(index, 1);
        },
        deleteFocusedTag(ctx2) {
          if (!ctx2.focusedId)
            return;
          const index = dom.getIndexOfId(ctx2, ctx2.focusedId);
          ctx2.idx = index;
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          ctx2.value.splice(index, 1);
        },
        setEditedId(ctx2, evt) {
          ctx2.editedId = evt.id ?? ctx2.focusedId;
          ctx2.idx = dom.getIndexOfId(ctx2, ctx2.editedId);
        },
        clearEditedId(ctx2) {
          ctx2.editedId = null;
        },
        clearEditedTagValue(ctx2) {
          ctx2.editedTagValue = "";
        },
        setEditedTagValue(ctx2, evt) {
          ctx2.editedTagValue = evt.value;
        },
        submitEditedTagValue(ctx2) {
          if (!ctx2.editedId)
            return;
          const index = dom.getIndexOfId(ctx2, ctx2.editedId);
          ctx2.value[index] = ctx2.editedTagValue ?? "";
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "update", value: ctx2.editedTagValue };
        },
        setValueAtIndex(ctx2, evt) {
          if (evt.value) {
            ctx2.value[evt.index] = evt.value;
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "update", value: evt.value };
          } else {
            warn("You need to provide a value for the tag");
          }
        },
        initializeEditedTagValue(ctx2) {
          if (!ctx2.editedId)
            return;
          const index = dom.getIndexOfId(ctx2, ctx2.editedId);
          ctx2.editedTagValue = ctx2.value[index];
        },
        focusEditedTagInput(ctx2) {
          raf(() => {
            dom.getEditInputEl(ctx2)?.select();
          });
        },
        setInputValue(ctx2, evt) {
          ctx2.inputValue = evt.value;
        },
        clearFocusedId(ctx2) {
          ctx2.focusedId = null;
        },
        focusInput(ctx2) {
          raf(() => {
            dom.getInputEl(ctx2)?.focus();
          });
        },
        clearInputValue(ctx2) {
          ctx2.inputValue = "";
        },
        syncInputValue(ctx2) {
          const input = dom.getInputEl(ctx2);
          if (!input)
            return;
          input.value = ctx2.inputValue;
        },
        syncEditedTagValue(ctx2, evt) {
          const id = ctx2.editedId || ctx2.focusedId || evt.id;
          if (!id)
            return;
          const el = dom.getById(ctx2, `${id}:input`);
          if (!el)
            return;
          el.value = ctx2.editedTagValue;
        },
        addTag(ctx2, evt) {
          const value = evt.value ?? ctx2.trimmedInputValue;
          const guard = ctx2.validate?.({ inputValue: value, values: ctx2.value });
          if (guard) {
            ctx2.value.push(value);
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "add", value };
          } else {
            ctx2.onInvalid?.({ reason: "invalidTag" });
          }
        },
        addTagFromPaste(ctx2) {
          raf(() => {
            const value = ctx2.trimmedInputValue;
            const guard = ctx2.validate?.({ inputValue: value, values: ctx2.value });
            if (guard) {
              const trimmedValue = ctx2.delimiter ? value.split(ctx2.delimiter).map((v) => v.trim()) : [value];
              ctx2.value.push(...trimmedValue);
              ctx2.log.prev = ctx2.log.current;
              ctx2.log.current = { type: "paste", values: trimmedValue };
            } else {
              ctx2.onInvalid?.({ reason: "invalidTag" });
            }
            ctx2.inputValue = "";
          });
        },
        clearTags(ctx2) {
          ctx2.value = [];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "clear" };
        },
        checkValue(ctx2) {
          ctx2.initialValue = ctx2.value.slice();
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        removeLiveRegion(ctx2) {
          ctx2.liveRegion?.destroy();
        },
        invokeOnInvalid(ctx2) {
          if (ctx2.isOverflowing) {
            ctx2.onInvalid?.({ reason: "rangeOverflow" });
          }
        },
        clearLog(ctx2) {
          ctx2.log = { prev: null, current: null };
        },
        logFocused(ctx2) {
          if (!ctx2.focusedId)
            return;
          const index = dom.getIndexOfId(ctx2, ctx2.focusedId);
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "select", value: ctx2.value[index] };
        },
        // queue logs with screen reader and get it announced
        announceLog(ctx2) {
          if (!ctx2.log.current || ctx2.liveRegion == null)
            return;
          const region = ctx2.liveRegion;
          const { current, prev } = ctx2.log;
          let msg;
          switch (current.type) {
            case "add":
              msg = ctx2.translations.tagAdded(current.value);
              break;
            case "delete":
              msg = ctx2.translations.tagDeleted(current.value);
              break;
            case "update":
              msg = ctx2.translations.tagUpdated(current.value);
              break;
            case "paste":
              msg = ctx2.translations.tagsPasted(current.values);
              break;
            case "select":
              msg = ctx2.translations.tagSelected(current.value);
              if (prev?.type === "delete") {
                msg = `${ctx2.translations.tagDeleted(prev.value)}. ${msg}`;
              } else if (prev?.type === "update") {
                msg = `${ctx2.translations.tagUpdated(prev.value)}. ${msg}`;
              }
              break;
          }
          if (msg)
            region.announce(msg);
        }
      }
    }
  );
}

export { machine };
