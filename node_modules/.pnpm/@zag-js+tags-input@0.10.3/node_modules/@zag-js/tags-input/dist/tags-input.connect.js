'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const domEvent = require('@zag-js/dom-event');
const domQuery = require('@zag-js/dom-query');
const tagsInput_anatomy = require('./tags-input.anatomy.js');
const tagsInput_dom = require('./tags-input.dom.js');

function connect(state, send, normalize) {
  const isInteractive = state.context.isInteractive;
  const isDisabled = state.context.disabled;
  const isReadOnly = state.context.readOnly;
  const isInvalid = state.context.invalid || state.context.isOverflowing;
  const translations = state.context.translations;
  const isInputFocused = state.hasTag("focused");
  const isEditingTag = state.matches("editing:tag");
  const isEmpty = state.context.count === 0;
  return {
    /**
     * Whether the tags are empty
     */
    isEmpty,
    /**
     * The value of the tags entry input.
     */
    inputValue: state.context.trimmedInputValue,
    /**
     * The value of the tags as an array of strings.
     */
    value: state.context.value,
    /**
     * The value of the tags as a string.
     */
    valueAsString: state.context.valueAsString,
    /**
     * The number of the tags.
     */
    count: state.context.count,
    /**
     * Whether the tags have reached the max limit.
     */
    isAtMax: state.context.isAtMax,
    /**
     * Function to set the value of the tags.
     */
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    /**
     * Function to clear the value of the tags.
     */
    clearValue(id) {
      if (id) {
        send({ type: "CLEAR_TAG", id });
      } else {
        send("CLEAR_VALUE");
      }
    },
    /**
     * Function to add a tag to the tags.
     */
    addValue(value) {
      send({ type: "ADD_TAG", value });
    },
    /**
     * Function to set the value of a tag at the given index.
     */
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE_AT_INDEX", index, value });
    },
    /**
     * Function to set the value of the tags entry input.
     */
    setInputValue(value) {
      send({ type: "SET_INPUT_VALUE", value });
    },
    /**
     * Function to clear the value of the tags entry input.
     */
    clearInputValue() {
      send({ type: "SET_INPUT_VALUE", value: "" });
    },
    /**
     * Function to focus the tags entry input.
     */
    focus() {
      tagsInput_dom.dom.getInputEl(state.context)?.focus();
    },
    rootProps: normalize.element({
      dir: state.context.dir,
      ...tagsInput_anatomy.parts.root.attrs,
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-readonly": domQuery.dataAttr(isReadOnly),
      "data-disabled": domQuery.dataAttr(isDisabled),
      "data-focus": domQuery.dataAttr(isInputFocused),
      "data-empty": domQuery.dataAttr(isEmpty),
      id: tagsInput_dom.dom.getRootId(state.context),
      onPointerDown() {
        if (!isInteractive)
          return;
        send("POINTER_DOWN");
      }
    }),
    labelProps: normalize.label({
      ...tagsInput_anatomy.parts.label.attrs,
      "data-disabled": domQuery.dataAttr(isDisabled),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-readonly": domQuery.dataAttr(isReadOnly),
      id: tagsInput_dom.dom.getLabelId(state.context),
      htmlFor: tagsInput_dom.dom.getInputId(state.context)
    }),
    controlProps: normalize.element({
      id: tagsInput_dom.dom.getControlId(state.context),
      ...tagsInput_anatomy.parts.control.attrs,
      tabIndex: isReadOnly ? 0 : void 0,
      "data-disabled": domQuery.dataAttr(isDisabled),
      "data-readonly": domQuery.dataAttr(isReadOnly),
      "data-invalid": domQuery.dataAttr(isInvalid),
      "data-focus": domQuery.dataAttr(isInputFocused)
    }),
    inputProps: normalize.input({
      ...tagsInput_anatomy.parts.input.attrs,
      "data-invalid": domQuery.dataAttr(isInvalid),
      "aria-invalid": domQuery.ariaAttr(isInvalid),
      "data-readonly": domQuery.dataAttr(isReadOnly),
      maxLength: state.context.maxLength,
      id: tagsInput_dom.dom.getInputId(state.context),
      defaultValue: state.context.inputValue,
      autoComplete: "off",
      autoCorrect: "off",
      autoCapitalize: "none",
      disabled: isDisabled || isReadOnly,
      onChange(event) {
        const evt = domEvent.getNativeEvent(event);
        if (evt.inputType === "insertFromPaste")
          return;
        let value = event.target.value;
        if (value.endsWith(state.context.delimiter)) {
          send("DELIMITER_KEY");
        } else {
          send({ type: "TYPE", value, key: evt.inputType });
        }
      },
      onFocus() {
        send("FOCUS");
      },
      onPaste(event) {
        const value = event.clipboardData.getData("text/plain");
        send({ type: "PASTE", value });
      },
      onKeyDown(event) {
        const target = event.currentTarget;
        const isCombobox = target.getAttribute("role") === "combobox";
        const isExpanded = target.ariaExpanded === "true";
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowLeft() {
            if (isCombobox && isExpanded)
              return;
            send("ARROW_LEFT");
          },
          ArrowRight() {
            if (state.context.focusedId) {
              event.preventDefault();
            }
            if (isCombobox && isExpanded)
              return;
            send("ARROW_RIGHT");
          },
          Escape(event2) {
            event2.preventDefault();
            send("ESCAPE");
          },
          Backspace() {
            send("BACKSPACE");
          },
          Delete() {
            send("DELETE");
          },
          Enter(event2) {
            event2.preventDefault();
            send("ENTER");
          }
        };
        const key = domEvent.getEventKey(event, state.context);
        const exec = keyMap[key];
        if (exec) {
          exec(event);
          return;
        }
      }
    }),
    hiddenInputProps: normalize.input({
      ...tagsInput_anatomy.parts.hiddenInput.attrs,
      type: "text",
      hidden: true,
      name: state.context.name,
      form: state.context.form,
      id: tagsInput_dom.dom.getHiddenInputId(state.context),
      defaultValue: state.context.valueAsString
    }),
    getTagProps(options) {
      const { value } = options;
      const id = tagsInput_dom.dom.getTagId(state.context, options);
      return normalize.element({
        ...tagsInput_anatomy.parts.tag.attrs,
        id,
        hidden: isEditingTag ? state.context.editedId === id : false,
        "data-value": value,
        "data-disabled": domQuery.dataAttr(isDisabled),
        "data-selected": domQuery.dataAttr(id === state.context.focusedId),
        onPointerDown(event) {
          if (!isInteractive)
            return;
          event.preventDefault();
          send({ type: "POINTER_DOWN_TAG", id });
        },
        onDoubleClick() {
          if (!isInteractive)
            return;
          send({ type: "DOUBLE_CLICK_TAG", id });
        }
      });
    },
    getTagInputProps(options) {
      const id = tagsInput_dom.dom.getTagId(state.context, options);
      const active = state.context.editedId === id;
      return normalize.input({
        ...tagsInput_anatomy.parts.tagInput.attrs,
        "aria-label": translations.tagEdited(options.value),
        "aria-hidden": true,
        disabled: isDisabled,
        id: tagsInput_dom.dom.getTagInputId(state.context, options),
        type: "text",
        tabIndex: -1,
        hidden: isEditingTag ? !active : true,
        defaultValue: active ? state.context.editedTagValue : "",
        onChange(event) {
          send({ type: "TAG_INPUT_TYPE", value: event.target.value });
        },
        onBlur(event) {
          send({ type: "TAG_INPUT_BLUR", target: event.relatedTarget, id });
        },
        onKeyDown(event) {
          const keyMap = {
            Enter() {
              send("TAG_INPUT_ENTER");
            },
            Escape() {
              send("TAG_INPUT_ESCAPE");
            }
          };
          const exec = keyMap[event.key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getTagDeleteTriggerProps(options) {
      const id = tagsInput_dom.dom.getTagId(state.context, options);
      return normalize.button({
        ...tagsInput_anatomy.parts.tagDeleteTrigger.attrs,
        id: tagsInput_dom.dom.getTagDeleteTriggerId(state.context, options),
        type: "button",
        disabled: isDisabled,
        "aria-label": translations.deleteTagTriggerLabel(options.value),
        tabIndex: -1,
        onPointerDown(event) {
          if (!isInteractive) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!isInteractive)
            return;
          tagsInput_dom.dom.setHoverIntent(event.currentTarget);
        },
        onPointerLeave(event) {
          if (!isInteractive)
            return;
          tagsInput_dom.dom.clearHoverIntent(event.currentTarget);
        },
        onClick() {
          if (!isInteractive)
            return;
          send({ type: "CLEAR_TAG", id });
        }
      });
    },
    clearTriggerProps: normalize.button({
      ...tagsInput_anatomy.parts.clearTrigger.attrs,
      id: tagsInput_dom.dom.getClearTriggerId(state.context),
      type: "button",
      "data-readonly": domQuery.dataAttr(isReadOnly),
      disabled: isDisabled,
      "aria-label": translations.clearTriggerLabel,
      hidden: isEmpty,
      onClick() {
        if (!isInteractive)
          return;
        send("CLEAR_VALUE");
      }
    })
  };
}

exports.connect = connect;
