import { createMachine } from '@zag-js/core';
import { trackPointerMove } from '@zag-js/dom-event';
import { raf } from '@zag-js/dom-query';
import { trackElementSize } from '@zag-js/element-size';
import { trackFormControl } from '@zag-js/form-utils';
import { getValuePercent, clampValue } from '@zag-js/numeric-range';
import { compact } from '@zag-js/utils';
import { dom } from './slider.dom.mjs';
import { constrainValue, decrement, increment } from './slider.utils.mjs';

function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        disabled: false,
        threshold: 5,
        dir: "ltr",
        origin: "start",
        orientation: "horizontal",
        initialValue: null,
        value: 0,
        step: 1,
        min: 0,
        max: 100,
        ...ctx
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize !== null,
        valuePercent: (ctx2) => 100 * getValuePercent(ctx2.value, ctx2.min, ctx2.max)
      },
      watch: {
        value: ["invokeOnChange", "dispatchChangeEvent"]
      },
      activities: ["trackFormControlState", "trackThumbSize"],
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        INCREMENT: {
          actions: "increment"
        },
        DECREMENT: {
          actions: "decrement"
        }
      },
      entry: ["checkValue"],
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setPointerValue", "invokeOnChangeStart", "focusThumb"]
            },
            FOCUS: "focus"
          }
        },
        focus: {
          entry: "focusThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setPointerValue", "invokeOnChangeStart", "focusThumb"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: "decrement"
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: "increment"
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: "increment"
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: "decrement"
            },
            PAGE_UP: {
              actions: "increment"
            },
            PAGE_DOWN: {
              actions: "decrement"
            },
            HOME: {
              actions: "setToMin"
            },
            END: {
              actions: "setToMax"
            },
            BLUR: "idle"
          }
        },
        dragging: {
          entry: "focusThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        isVertical: (ctx2) => ctx2.isVertical
      },
      activities: {
        trackFormControlState(ctx2) {
          return trackFormControl(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              if (ctx2.initialValue != null) {
                ctx2.value = ctx2.initialValue;
              }
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbSize(ctx2, _evt) {
          if (ctx2.thumbAlignment !== "contain")
            return;
          return trackElementSize(dom.getThumbEl(ctx2), (size) => {
            if (size)
              ctx2.thumbSize = size;
          });
        }
      },
      actions: {
        checkValue(ctx2) {
          const value = constrainValue(ctx2, ctx2.value);
          ctx2.value = value;
          ctx2.initialValue = value;
        },
        invokeOnChangeStart(ctx2) {
          ctx2.onChangeStart?.({ value: ctx2.value });
        },
        invokeOnChangeEnd(ctx2) {
          ctx2.onChangeEnd?.({ value: ctx2.value });
        },
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        dispatchChangeEvent(ctx2) {
          dom.dispatchChangeEvent(ctx2);
        },
        setPointerValue(ctx2, evt) {
          const value = dom.getValueFromPoint(ctx2, evt.point);
          if (value == null)
            return;
          ctx2.value = clampValue(value, ctx2.min, ctx2.max);
        },
        focusThumb(ctx2) {
          raf(() => dom.getThumbEl(ctx2)?.focus());
        },
        decrement(ctx2, evt) {
          ctx2.value = decrement(ctx2, evt.step);
        },
        increment(ctx2, evt) {
          ctx2.value = increment(ctx2, evt.step);
        },
        setToMin(ctx2) {
          ctx2.value = ctx2.min;
        },
        setToMax(ctx2) {
          ctx2.value = ctx2.max;
        },
        setValue(ctx2, evt) {
          ctx2.value = constrainValue(ctx2, evt.value);
        }
      }
    }
  );
}

export { machine };
