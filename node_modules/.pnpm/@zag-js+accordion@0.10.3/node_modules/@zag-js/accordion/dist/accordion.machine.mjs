import { createMachine, guards } from '@zag-js/core';
import { compact, remove, toArray, add, isString, warn } from '@zag-js/utils';
import { dom } from './accordion.dom.mjs';

const { and, not } = guards;
const valueMismatchMessage = `[accordion/invalid-value] Expected value for multiple accordion to be an 'array' but received 'string'. Value will be coarsed to 'array'`;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: null,
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "sanitizeValue",
        multiple: "sanitizeValue"
      },
      created: "sanitizeValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue", "invokeOnChange"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNext"
            },
            "GOTO.PREV": {
              actions: "focusPrev"
            },
            "TRIGGER.CLICK": [
              {
                guard: and("isExpanded", "canToggle"),
                actions: ["collapse", "invokeOnChange"]
              },
              {
                guard: not("isExpanded"),
                actions: ["expand", "invokeOnChange"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirst"
            },
            "GOTO.LAST": {
              actions: "focusLast"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => {
          if (ctx2.multiple && Array.isArray(ctx2.value)) {
            return ctx2.value.includes(evt.value);
          }
          return ctx2.value === evt.value;
        }
      },
      actions: {
        invokeOnChange(ctx2) {
          ctx2.onChange?.({ value: ctx2.value });
        },
        collapse(ctx2, evt) {
          ctx2.value = ctx2.multiple ? remove(toArray(ctx2.value), evt.value) : null;
        },
        expand(ctx2, evt) {
          ctx2.value = ctx2.multiple ? add(toArray(ctx2.value), evt.value) : evt.value;
        },
        focusFirst(ctx2) {
          dom.getFirstTriggerEl(ctx2)?.focus();
        },
        focusLast(ctx2) {
          dom.getLastTriggerEl(ctx2)?.focus();
        },
        focusNext(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        focusPrev(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          el?.focus();
        },
        setFocusedValue(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        clearFocusedValue(ctx2) {
          ctx2.focusedValue = null;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        sanitizeValue(ctx2) {
          if (ctx2.multiple && isString(ctx2.value)) {
            warn(valueMismatchMessage);
            ctx2.value = [ctx2.value];
          } else if (!ctx2.multiple && Array.isArray(ctx2.value) && ctx2.value.length > 0) {
            ctx2.value = ctx2.value[0];
          }
        }
      }
    }
  );
}

export { machine };
